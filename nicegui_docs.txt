
____________________________________________________________
Section: 1. URL: http://localhost:8080/documentation/


Installation Features Demos Documentation Examples Why? search


Reference, Demos and more


Overview

It has a very gentle learning curve while still offering the option for advanced customizations.
It handles all the web development details.
You can focus on writing Python code.
This makes it ideal for a wide range of projects including short
scripts, dashboards, robotics projects, IoT solutions, smart home automation, and machine learning.


How to use this guide

This documentation explains how to use NiceGUI.
Each of the tiles covers a NiceGUI topic in detail.
It is recommended to start by reading this entire introduction page, then refer to other sections as needed.


Basic concepts

Your app assembles these components into pages .
When the user interacts with an item on a page, NiceGUI triggers an event (or action ).
You define code to handle each event, such as what to do when a user clicks a button, modifies a value or operates a slider.
Elements can also be bound to a model (data object), which automatically updates the user interface when the model value changes.
Elements are arranged on a page using a "declarative UI" or "code-based UI".
That means that you also write structures like grids, cards, tabs, carousels, expansions, menus, and other layout elements directly in code.
This concept has been made popular with Flutter and SwiftUI.
For readability, NiceGUI utilizes Python's with ... statement.
This context manager provides a nice way to indent the code to resemble the layout of the UI.
Styling and appearance can be controlled in several ways.
Most elements accept optional arguments for common styling and behavior changes, such as button icons or text color.
Because NiceGUI is a web framework, you can change almost any appearance of an element with CSS.
But elements also provide .classes and .props methods to apply Tailwind CSS and Quasar properties
which are more high-level and simpler to use day-to-day after you get the hang of it.


Actions, Events and Tasks

This section shows how to handle user input and other events like timers and keyboard bindings.
It also describes helper functions to wrap long-running tasks in asynchronous functions to keep the UI responsive.
Keep in mind that all UI updates must happen on the main thread with its event loop.


Implementation

If you already know HTML, everything will feel very familiar.
If you don't know HTML, that's fine too!


Running NiceGUI Apps

There are several options for deploying NiceGUI.
By default, NiceGUI runs a server on localhost and runs your app as a private web page on the local machine.
When run this way, your app appears in a web browser window.
You can also run NiceGUI in a native window separate from a web browser.
Or you can run NiceGUI on a server that handles many clients - the website you're reading right now is served from NiceGUI.
After creating your app pages with components, you call ui.run() to start the NiceGUI server.
Optional parameters to ui.run set things like the network address and port the server binds to,
whether the app runs in native mode, initial window size, and many other options.
The section Configuration and Deployment covers the options to the ui.run() function and the FastAPI framework it is based on.


Customization

If you want more customization in your app, you can use the underlying Tailwind classes and Quasar components
to control the style or behavior of your components.
You can also extend the available components by subclassing existing NiceGUI components or importing new ones from Quasar.
All of this is optional.
Out of the box, NiceGUI provides everything you need to make modern, stylish, responsive user interfaces.


Testing

You can utilize the screen fixture which starts a real (headless) browser to interact with your application.
This is great if you have browser-specific behavior to test.
But most of the time, NiceGUI's newly introduced user fixture is more suited:
It only simulates the user interaction on a Python level and, hence, is blazing fast.
That way the classical test pyramid ,
where UI tests are considered slow and expensive, does not apply anymore.
This can have a huge impact on your development speed, quality and confidence.


Text Elements

Elements like ui.label , ui.markdown , ui.restructured_text and ui.html can be used to display text and other content.
Controls

Audiovisual Elements

You can use elements like ui.image , ui.audio , ui.video , etc. to display audiovisual content.
Data Elements

There are several elements for displaying data, e.g. ui.table , ui.aggrid , ui.highchart , ui.echart , etc.
Binding Properties

To update UI elements automatically, you can bind them to each other or to your data model.
Page Layout

This section covers fundamental techniques as well as several elements to structure your UI.
Styling & Appearance

Action & Events

This section covers timers, UI events, and the lifecycle of NiceGUI apps.
Pages & Routing

A NiceGUI app can consist of multiple pages and other FastAPI endpoints.
Configuration & Deployment

Whether you want to run your app locally or on a server, native or in a browser, we got you covered.
Testing

Write automated UI tests which run in a headless browser (slow) or fully simulated in Python (fast).




____________________________________________________________
Section: 2. URL: http://localhost:8080/documentation/section_text_elements

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Text Elements Label Link Chat Message Generic Element Markdown Element ReStructuredText Mermaid Diagrams HTML Element


Text Elements


Label


Displays some text.

text: the content of the label


Coding example:
from nicegui import ui

ui.label('some label')

ui.run()


Link


Create a hyperlink.
To jump to a specific location within a page you can place linkable anchors with ui.link_target("name") and link to it with ui.link(target="#name") .

text: display text
target: page function, NiceGUI element on the same page or string that is a an absolute URL or relative path from base URL
new_tab: open link in new tab (default: False)


Coding example:
from nicegui import ui

ui.link('NiceGUI on GitHub', 'https://github.com/zauberzeug/nicegui')

ui.run()


Chat Message


Based on Quasar's Chat Message component.

text: the message body (can be a list of strings for multiple message parts)
name: the name of the message author
label: renders a label header/section only
stamp: timestamp of the message
avatar: URL to an avatar
sent: render as a sent message (so from current user) (default: False)
text_html: render text as HTML (default: False)


Coding example:
from nicegui import ui

ui.chat_message('Hello NiceGUI!',
                name='Robot',
                stamp='now',
                avatar='https://robohash.org/ui')

ui.run()


Generic Element


This class is the base class for all other UI elements.
But you can use it to create elements with arbitrary HTML tags.

tag: HTML tag of the element
_client: client for this element (for internal use only)


Coding example:
from nicegui import ui

with ui.element('div').classes('p-2 bg-blue-100'):
    ui.label('inside a colored div')

ui.run()


Markdown Element


Renders Markdown onto the page.

content: the Markdown content to be displayed
extras: list of markdown2 extensions (default: ['fenced-code-blocks', 'tables'])


Coding example:
from nicegui import ui

ui.markdown('This is **Markdown**.')

ui.run()


ReStructuredText


Renders ReStructuredText onto the page.

content: the ReStructuredText content to be displayed


Coding example:
from nicegui import ui

ui.restructured_text('This is **reStructuredText**.')

ui.run()


Mermaid Diagrams


Renders diagrams and charts written in the Markdown-inspired Mermaid language.
The mermaid syntax can also be used inside Markdown elements by providing the extension string 'mermaid' to the ui.markdown element.
The optional configuration dictionary is passed directly to mermaid before the first diagram is rendered.
This can be used to set such options as {'securityLevel': 'loose', ...} - allow running JavaScript when a node is clicked {'logLevel': 'info', ...} - log debug info to the console
Refer to the Mermaid documentation for the mermaid.initialize() method for a full list of options.

content: the Mermaid content to be displayed
config: configuration dictionary to be passed to mermaid.initialize()


Coding example:
from nicegui import ui

ui.mermaid('''
graph LR;
    A --> B;
    A --> C;
''')

ui.run()


HTML Element


Renders arbitrary HTML onto the page, wrapped in the specified tag. Tailwind can be used for styling.
You can also use ui.add_head_html to add html code into the head of the document and ui.add_body_html to add it into the body.

content: the HTML code to be displayed
tag: the HTML tag to wrap the content in (default: "div")


Coding example:
from nicegui import ui

ui.html('This is <strong>HTML</strong>.')

ui.run()




____________________________________________________________
Section: 3. URL: http://localhost:8080/documentation/section_controls

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Controls Button Button Group Dropdown Button Badge Chip Toggle Radio Selection Dropdown Selection Checkbox Switch Slider Range Joystick Text Input Textarea CodeMirror Number Input Knob Color Input Color Picker Date Input Time Input File Upload


Controls


Button


This element is based on Quasar's QBtn component.
The color parameter accepts a Quasar color, a Tailwind color, or a CSS color.
If a Quasar color is used, the button will be styled according to the Quasar theme including the color of the text.
Note that there are colors like "red" being both a Quasar color and a CSS color.
In such cases the Quasar color will be used.

text: the label of the button
on_click: callback which is invoked when button is pressed
color: the color of the button (either a Quasar, Tailwind, or CSS color or None, default: 'primary')
icon: the name of an icon to be displayed on the button (default: None)


Coding example:
from nicegui import ui

ui.button('Click me!', on_click=lambda: ui.notify('You clicked me!'))

ui.run()


Button Group


This element is based on Quasar's QBtnGroup component.
You must use the same design props on both the parent button group and the children buttons.


Coding example:
from nicegui import ui

with ui.button_group():
    ui.button('One', on_click=lambda: ui.notify('You clicked Button 1!'))
    ui.button('Two', on_click=lambda: ui.notify('You clicked Button 2!'))
    ui.button('Three', on_click=lambda: ui.notify('You clicked Button 3!'))

ui.run()


Dropdown Button


This element is based on Quasar's QBtnDropDown component.
The color parameter accepts a Quasar color, a Tailwind color, or a CSS color.
If a Quasar color is used, the button will be styled according to the Quasar theme including the color of the text.
Note that there are colors like "red" being both a Quasar color and a CSS color.
In such cases the Quasar color will be used.

text: the label of the button
value: if the dropdown is open or not (default: False)
on_value_change:
 callback which is invoked when the dropdown is opened or closed
on_click: callback which is invoked when button is pressed
color: the color of the button (either a Quasar, Tailwind, or CSS color or None, default: 'primary')
icon: the name of an icon to be displayed on the button (default: None)
auto_close: whether the dropdown should close automatically when an item is clicked (default: False)
split: whether to split the dropdown icon into a separate button (default: False)


Coding example:
from nicegui import ui

with ui.dropdown_button('Open me!', auto_close=True):
    ui.item('Item 1', on_click=lambda: ui.notify('You clicked item 1'))
    ui.item('Item 2', on_click=lambda: ui.notify('You clicked item 2'))

ui.run()


Badge


A badge element wrapping Quasar's QBadge component.

text: the initial value of the text field
color: the color name for component (either a Quasar, Tailwind, or CSS color or None, default: "primary")
text_color: text color (either a Quasar, Tailwind, or CSS color or None, default: None)
outline: use 'outline' design (colored text and borders only) (default: False)


Coding example:
from nicegui import ui

with ui.button('Click me!', on_click=lambda: badge.set_text(int(badge.text) + 1)):
    badge = ui.badge('0', color='red').props('floating')

ui.run()


Chip


A chip element wrapping Quasar's QChip component.
It can be clickable, selectable and removable.

text: the initial value of the text field (default: "")
icon: the name of an icon to be displayed on the chip (default: None)
color: the color name for component (either a Quasar, Tailwind, or CSS color or None, default: "primary")
text_color: text color (either a Quasar, Tailwind, or CSS color or None, default: None)
on_click: callback which is invoked when chip is clicked. Makes the chip clickable if set
selectable: whether the chip is selectable (default: False)
selected: whether the chip is selected (default: False)
on_selection_change:
 callback which is invoked when the chip's selection state is changed
removable: whether the chip is removable. Shows a small "x" button if True (default: False)
on_value_change:
 callback which is invoked when the chip is removed or unremoved


Coding example:
from nicegui import ui

with ui.row().classes('gap-1'):
    ui.chip('Click me', icon='ads_click', on_click=lambda: ui.notify('Clicked'))
    ui.chip('Selectable', selectable=True, icon='bookmark', color='orange')
    ui.chip('Removable', removable=True, icon='label', color='indigo-3')
    ui.chip('Styled', icon='star', color='green').props('outline square')
    ui.chip('Disabled', icon='block', color='red').set_enabled(False)

ui.run()


Toggle


This element is based on Quasar's QBtnToggle component.
The options can be specified as a list of values, or as a dictionary mapping values to labels.
After manipulating the options, call update() to update the options in the UI.

options: a list ['value1', ...] or dictionary {'value1':'label1', ...} specifying the options
value: the initial value
on_change: callback to execute when selection changes
clearable: whether the toggle can be cleared by clicking the selected option


Coding example:
from nicegui import ui

toggle1 = ui.toggle([1, 2, 3], value=1)
toggle2 = ui.toggle({1: 'A', 2: 'B', 3: 'C'}).bind_value(toggle1, 'value')

ui.run()


Radio Selection


This element is based on Quasar's QRadio component.
The options can be specified as a list of values, or as a dictionary mapping values to labels.
After manipulating the options, call update() to update the options in the UI.

options: a list ['value1', ...] or dictionary {'value1':'label1', ...} specifying the options
value: the initial value
on_change: callback to execute when selection changes


Coding example:
from nicegui import ui

radio1 = ui.radio([1, 2, 3], value=1).props('inline')
radio2 = ui.radio({1: 'A', 2: 'B', 3: 'C'}).props('inline').bind_value(radio1, 'value')

ui.run()


Dropdown Selection


This element is based on Quasar's QSelect component.
The options can be specified as a list of values, or as a dictionary mapping values to labels.
After manipulating the options, call update() to update the options in the UI.
If with_input is True, an input field is shown to filter the options.
If new_value_mode is not None, it implies with_input=True and the user can enter new values in the input field.
See Quasar's documentation for details.
Note that this mode is ineffective when setting the value property programmatically.
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too long!': lambda value: len(value) < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.

options: a list ['value1', ...] or dictionary {'value1':'label1', ...} specifying the options
label: the label to display above the selection
value: the initial value
on_change: callback to execute when selection changes
with_input: whether to show an input field to filter the options
new_value_mode: handle new values from user input (default: None, i.e. no new values)
multiple: whether to allow multiple selections
clearable: whether to add a button to clear the selection
validation: dictionary of validation rules or a callable that returns an optional error message
key_generator: a callback or iterator to generate a dictionary key for new values


Coding example:
from nicegui import ui

select1 = ui.select([1, 2, 3], value=1)
select2 = ui.select({1: 'One', 2: 'Two', 3: 'Three'}).bind_value(select1, 'value')

ui.run()


Checkbox


This element is based on Quasar's QCheckbox component.

text: the label to display next to the checkbox
value: whether it should be checked initially (default: False)
on_change: callback to execute when value changes


Coding example:
from nicegui import ui

checkbox = ui.checkbox('check me')
ui.label('Check!').bind_visibility_from(checkbox, 'value')

ui.run()


Switch


This element is based on Quasar's QToggle component.

text: the label to display next to the switch
value: whether it should be active initially (default: False)
on_change: callback which is invoked when state is changed by the user


Coding example:
from nicegui import ui

switch = ui.switch('switch me')
ui.label('Switch!').bind_visibility_from(switch, 'value')

ui.run()


Slider


This element is based on Quasar's QSlider component.

min: lower bound of the slider
max: upper bound of the slider
step: step size
value: initial value to set position of the slider
on_change: callback which is invoked when the user releases the slider


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=100, value=50)
ui.label().bind_text_from(slider, 'value')

ui.run()


Range


This element is based on Quasar's QRange component.

min: lower bound of the range
max: upper bound of the range
step: step size
value: initial value to set min and max position of the range
on_change: callback which is invoked when the user releases the range


Coding example:
from nicegui import ui

min_max_range = ui.range(min=0, max=100, value={'min': 20, 'max': 80})
ui.label().bind_text_from(min_max_range, 'value',
                          backward=lambda v: f'min: {v["min"]}, max: {v["max"]}')

ui.run()


Joystick


Create a joystick based on nipple.js .

on_start: callback for when the user touches the joystick
on_move: callback for when the user moves the joystick
on_end: callback for when the user releases the joystick
throttle: throttle interval in seconds for the move event (default: 0.05)
options: arguments like color which should be passed to the underlying nipple.js library


Coding example:
from nicegui import ui

ui.joystick(color='blue', size=50,
            on_move=lambda e: coordinates.set_text(f'{e.x:.3f}, {e.y:.3f}'),
            on_end=lambda _: coordinates.set_text('0, 0'))
coordinates = ui.label('0, 0')

ui.run()


Text Input


This element is based on Quasar's QInput component.
The on_change event is called on every keystroke and the value updates accordingly.
If you want to wait until the user confirms the input, you can register a custom event callback, e.g. ui.input(...).on('keydown.enter', ...) or ui.input(...).on('blur', ...) .
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too long!': lambda value: len(value) < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.
Note about styling the input:
Quasar's QInput component is a wrapper around a native input element.
This means that you cannot style the input directly,
but you can use the input-class and input-style props to style the native input element.
See the "Style" props section on the QInput documentation for more details.

label: displayed label for the text input
placeholder: text to show if no value is entered
value: the current value of the text input
password: whether to hide the input (default: False)
password_toggle_button:
 whether to show a button to toggle the password visibility (default: False)
on_change: callback to execute when the value changes
autocomplete: optional list of strings for autocompletion
validation: dictionary of validation rules or a callable that returns an optional error message


Coding example:
from nicegui import ui

ui.input(label='Text', placeholder='start typing',
         on_change=lambda e: result.set_text('you typed: ' + e.value),
         validation={'Input too long': lambda value: len(value) < 20})
result = ui.label()

ui.run()


Textarea


This element is based on Quasar's QInput component.
The type is set to textarea to create a multi-line text input.
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too long!': lambda value: len(value) < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.

label: displayed name for the textarea
placeholder: text to show if no value is entered
value: the initial value of the field
on_change: callback to execute when the value changes
validation: dictionary of validation rules or a callable that returns an optional error message


Coding example:
from nicegui import ui

ui.textarea(label='Text', placeholder='start typing',
            on_change=lambda e: result.set_text('you typed: ' + e.value))
result = ui.label()

ui.run()


CodeMirror


An element to create a code editor using CodeMirror .
It supports syntax highlighting for over 140 languages, more than 30 themes, line numbers, code folding, (limited) auto-completion, and more. Supported languages and themes:
Languages: A list of supported languages can be found in the @codemirror/language-data package.
Themes: A list can be found in the @uiw/codemirror-themes-all package.
At runtime, the methods supported_languages and supported_themes can be used to get supported languages and themes.

value: initial value of the editor (default: "")
on_change: callback to be executed when the value changes (default: None)
language: initial language of the editor (case-insensitive, default: None)
theme: initial theme of the editor (default: "basicLight")
indent: string to use for indentation (any string consisting entirely of the same whitespace character, default: "    ")
line_wrapping: whether to wrap lines (default: False)
highlight_whitespace:
 whether to highlight whitespace (default: False)


Coding example:
from nicegui import ui

editor = ui.codemirror('print("Edit me!")', language='Python').classes('h-32')
ui.select(editor.supported_languages, label='Language', clearable=True) \
    .classes('w-32').bind_value(editor, 'language')
ui.select(editor.supported_themes, label='Theme') \
    .classes('w-32').bind_value(editor, 'theme')

ui.run()


Number Input


This element is based on Quasar's QInput component.
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too small!': lambda value: value < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.

label: displayed name for the number input
placeholder: text to show if no value is entered
value: the initial value of the field
min: the minimum value allowed
max: the maximum value allowed
precision: the number of decimal places allowed (default: no limit, negative: decimal places before the dot)
step: the step size for the stepper buttons
prefix: a prefix to prepend to the displayed value
suffix: a suffix to append to the displayed value
format: a string like "%.2f" to format the displayed value
on_change: callback to execute when the value changes
validation: dictionary of validation rules or a callable that returns an optional error message


Coding example:
from nicegui import ui

ui.number(label='Number', value=3.1415927, format='%.2f',
          on_change=lambda e: result.set_text(f'you entered: {e.value}'))
result = ui.label()

ui.run()


Knob


This element is based on Quasar's QKnob component.
The element is used to take a number input from the user through mouse/touch panning.

value: the initial value (default: 0.0)
min: the minimum value (default: 0.0)
max: the maximum value (default: 1.0)
step: the step size (default: 0.01)
color: knob color (either a Quasar, Tailwind, or CSS color or None, default: "primary")
center_color: color name for the center part of the component, examples: primary, teal-10
track_color: color name for the track of the component, examples: primary, teal-10
size: size in CSS units, including unit name or standard size name (xs|sm|md|lg|xl), examples: 16px, 2rem
show_value: whether to show the value as text
on_change: callback to execute when the value changes


Coding example:
from nicegui import ui

knob = ui.knob(0.3, show_value=True)

with ui.knob(color='orange', track_color='grey-2').bind_value(knob, 'value'):
    ui.icon('volume_up')

ui.run()


Color Input


This element extends Quasar's QInput component with a color picker.

label: displayed label for the color input
placeholder: text to show if no color is selected
value: the current color value
on_change: callback to execute when the value changes
preview: change button background to selected color (default: False)


Coding example:
from nicegui import ui

label = ui.label('Change my color!')
ui.color_input(label='Color', value='#000000',
               on_change=lambda e: label.style(f'color:{e.value}'))

ui.run()


Color Picker


This element is based on Quasar's QMenu and QColor components.

on_pick: callback to execute when a color is picked
value: whether the menu is already opened (default: False)


Coding example:
from nicegui import ui

with ui.button(icon='colorize') as button:
    ui.color_picker(on_pick=lambda e: button.style(f'background-color:{e.color}!important'))

ui.run()


Date Input


This element is based on Quasar's QDate component.
The date is a string in the format defined by the mask parameter.
Coding example:
ui.date({'from': '2023-01-01', 'to': '2023-01-05'}).props('range')
ui.date(['2023-01-01', '2023-01-02', '2023-01-03']).props('multiple')
ui.date([{'from': '2023-01-01', 'to': '2023-01-05'}, '2023-01-07']).props('multiple range')


value: the initial date
mask: the format of the date string (default: 'YYYY-MM-DD')
on_change: callback to execute when changing the date


Coding example:
from nicegui import ui

ui.date(value='2023-01-01', on_change=lambda e: result.set_text(e.value))
result = ui.label()

ui.run()


Time Input


This element is based on Quasar's QTime component.
The time is a string in the format defined by the mask parameter.

value: the initial time
mask: the format of the time string (default: 'HH:mm')
on_change: callback to execute when changing the time


Coding example:
from nicegui import ui

ui.time(value='12:00', on_change=lambda e: result.set_text(e.value))
result = ui.label()

ui.run()


File Upload


Based on Quasar's QUploader component.

multiple: allow uploading multiple files at once (default: False)
max_file_size: maximum file size in bytes (default: 0)
max_total_size: maximum total size of all files in bytes (default: 0)
max_files: maximum number of files (default: 0)
on_upload: callback to execute for each uploaded file
on_multi_upload:
 callback to execute after multiple files have been uploaded
on_rejected: callback to execute for each rejected file
label: label for the uploader (default: '')
auto_upload: automatically upload files when they are selected (default: False)


Coding example:
from nicegui import ui

ui.upload(on_upload=lambda e: ui.notify(f'Uploaded {e.name}')).classes('max-w-full')

ui.run()




____________________________________________________________
Section: 4. URL: http://localhost:8080/documentation/section_audiovisual_elements

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Audiovisual Elements Image Captions and Overlays Interactive Image Audio Video Icon Avatar SVG


Audiovisual Elements


Image


Displays an image.
This element is based on Quasar's QImg component.

source: the source of the image; can be a URL, local file path, a base64 string or a PIL image


Coding example:
from nicegui import ui

ui.image('https://picsum.photos/id/377/640/360')

ui.run()


Captions and Overlays

By nesting elements inside a ui.image you can create augmentations.
Use Quasar classes for positioning and styling captions.
To overlay an SVG, make the viewBox exactly the size of the image and provide 100% width/height to match the actual rendered size.


Coding example:
from nicegui import ui

with ui.image('https://picsum.photos/id/29/640/360'):
    ui.label('Nice!').classes('absolute-bottom text-subtitle2 text-center')

with ui.image('https://cdn.stocksnap.io/img-thumbs/960w/airplane-sky_DYPWDEEILG.jpg'):
    ui.html('''
        <svg viewBox="0 0 960 638" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
        <circle cx="445" cy="300" r="100" fill="none" stroke="red" stroke-width="10" />
        </svg>
    ''').classes('w-full bg-transparent')

ui.run()


Interactive Image


Create an image with an SVG overlay that handles mouse events and yields image coordinates.
It is also the best choice for non-flickering image updates.
If the source URL changes faster than images can be loaded by the browser, some images are simply skipped.
Thereby repeatedly updating the image source will automatically adapt to the available bandwidth.
See OpenCV Webcam for an example.
The mouse event handler is called with mouse event arguments containing
type (the name of the JavaScript event),
image_x and image_y (image coordinates in pixels),
button and buttons (mouse button numbers from the JavaScript event), as well as
alt , ctrl , meta , and shift (modifier keys from the JavaScript event).
You can also pass a tuple of width and height instead of an image source.
This will create an empty image with the given size.

source: the source of the image; can be an URL, local file path, a base64 string or just an image size
content: SVG content which should be overlaid; viewport has the same dimensions as the image
size: size of the image (width, height) in pixels; only used if source is not set
on_mouse: callback for mouse events (contains image coordinates image_x and image_y in pixels)
events: list of JavaScript events to subscribe to (default: ['click'])
cross: whether to show crosshairs or a color string (default: False)


Coding example:
from nicegui import events, ui

def mouse_handler(e: events.MouseEventArguments):
    color = 'SkyBlue' if e.type == 'mousedown' else 'SteelBlue'
    ii.content += f'<circle cx="{e.image_x}" cy="{e.image_y}" r="15" fill="none" stroke="{color}" stroke-width="4" />'
    ui.notify(f'{e.type} at ({e.image_x:.1f}, {e.image_y:.1f})')

src = 'https://picsum.photos/id/565/640/360'
ii = ui.interactive_image(src, on_mouse=mouse_handler, events=['mousedown', 'mouseup'], cross=True)

ui.run()


Audio


Displays an audio player.

src: URL or local file path of the audio source
controls: whether to show the audio controls, like play, pause, and volume (default: True)
autoplay: whether to start playing the audio automatically (default: False)
muted: whether the audio should be initially muted (default: False)
loop: whether the audio should loop (default: False)
See here for a list of events you can subscribe to using the generic event subscription on() .


Coding example:
from nicegui import ui

a = ui.audio('https://cdn.pixabay.com/download/audio/2022/02/22/audio_d1718ab41b.mp3')
a.on('ended', lambda _: ui.notify('Audio playback completed'))

ui.button(on_click=lambda: a.props('muted'), icon='volume_off').props('outline')
ui.button(on_click=lambda: a.props(remove='muted'), icon='volume_up').props('outline')

ui.run()


Video


Displays a video.

src: URL or local file path of the video source
controls: whether to show the video controls, like play, pause, and volume (default: True)
autoplay: whether to start playing the video automatically (default: False)
muted: whether the video should be initially muted (default: False)
loop: whether the video should loop (default: False)
See here for a list of events you can subscribe to using the generic event subscription on() .


Coding example:
from nicegui import ui

v = ui.video('https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/360/Big_Buck_Bunny_360_10s_1MB.mp4')
v.on('ended', lambda _: ui.notify('Video playback completed'))

ui.run()


Icon


This element is based on Quasar's QIcon component.
Here is a reference of possible names.

name: name of the icon (snake case, e.g. add_circle)
size: size in CSS units, including unit name or standard size name (xs|sm|md|lg|xl), examples: 16px, 2rem
color: icon color (either a Quasar, Tailwind, or CSS color or None, default: None)


Coding example:
from nicegui import ui

ui.icon('thumb_up', color='primary').classes('text-5xl')

ui.run()


Avatar


A avatar element wrapping Quasar's QAvatar component.

icon: name of the icon or image path with "img:" prefix (e.g. "map", "img:path/to/image.png")
color: background color (either a Quasar, Tailwind, or CSS color or None, default: "primary")
text_color: color name from the Quasar Color Palette (e.g. "primary", "teal-10")
size: size in CSS units, including unit name or standard size name (xs|sm|md|lg|xl) (e.g. "16px", "2rem")
font_size: size in CSS units, including unit name, of the content (icon, text) (e.g. "18px", "2rem")
square: removes border-radius so borders are squared (default: False)
rounded: applies a small standard border-radius for a squared shape of the component (default: False)


Coding example:
from nicegui import ui

ui.avatar('favorite_border', text_color='grey-11', square=True)
ui.avatar('img:https://nicegui.io/logo_square.png', color='blue-2')

ui.run()


SVG

You can add Scalable Vector Graphics using the ui.html element.


Coding example:
from nicegui import ui

content = '''
    <svg viewBox="0 0 200 200" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
    <circle cx="100" cy="100" r="78" fill="#ffde34" stroke="black" stroke-width="3" />
    <circle cx="80" cy="85" r="8" />
    <circle cx="120" cy="85" r="8" />
    <path d="m60,120 C75,150 125,150 140,120" style="fill:none; stroke:black; stroke-width:8; stroke-linecap:round" />
    </svg>'''
ui.html(content)

ui.run()




____________________________________________________________
Section: 5. URL: http://localhost:8080/documentation/section_data_elements

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Data Elements Table AG Grid Apache EChart Pyplot Context Matplotlib Line Plot Plotly Element Linear Progress Circular Progress Spinner 3D Scene Leaflet map Tree Log View Editor Code JSONEditor


Data Elements


Table


A table based on Quasar's QTable component.

columns: list of column objects
rows: list of row objects
row_key: name of the column containing unique data identifying the row (default: "id")
title: title of the table
selection: selection type ("single" or "multiple"; default: None)
pagination: a dictionary correlating to a pagination object or number of rows per page (None hides the pagination, 0 means "infinite"; default: None).
on_select: callback which is invoked when the selection changes
on_pagination_change:
 callback which is invoked when the pagination changes
If selection is 'single' or 'multiple', then a selected property is accessible containing the selected rows.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name', 'required': True, 'align': 'left'},
    {'name': 'age', 'label': 'Age', 'field': 'age', 'sortable': True},
]
rows = [
    {'name': 'Alice', 'age': 18},
    {'name': 'Bob', 'age': 21},
    {'name': 'Carol'},
]
ui.table(columns=columns, rows=rows, row_key='name')

ui.run()


AG Grid


An element to create a grid using AG Grid .
The methods run_grid_method and run_column_method can be used to interact with the AG Grid instance on the client.

options: dictionary of AG Grid options
html_columns: list of columns that should be rendered as HTML (default: [])
theme: AG Grid theme (default: 'balham')
auto_size_columns:
 whether to automatically resize columns to fit the grid width (default: True)


Coding example:
from nicegui import ui

grid = ui.aggrid({
    'defaultColDef': {'flex': 1},
    'columnDefs': [
        {'headerName': 'Name', 'field': 'name'},
        {'headerName': 'Age', 'field': 'age'},
        {'headerName': 'Parent', 'field': 'parent', 'hide': True},
    ],
    'rowData': [
        {'name': 'Alice', 'age': 18, 'parent': 'David'},
        {'name': 'Bob', 'age': 21, 'parent': 'Eve'},
        {'name': 'Carol', 'age': 42, 'parent': 'Frank'},
    ],
    'rowSelection': 'multiple',
}).classes('max-h-40')

def update():
    grid.options['rowData'][0]['age'] += 1
    grid.update()

ui.button('Update', on_click=update)
ui.button('Select all', on_click=lambda: grid.run_grid_method('selectAll'))
ui.button('Show parent', on_click=lambda: grid.run_column_method('setColumnVisible', 'parent', True))

ui.run()


Apache EChart


An element to create a chart using ECharts .
Updates can be pushed to the chart by changing the options property.
After data has changed, call the update method to refresh the chart.

options: dictionary of EChart options
on_click_point: callback that is invoked when a point is clicked
enable_3d: enforce importing the echarts-gl library


Coding example:
from nicegui import ui
from random import random

echart = ui.echart({
    'xAxis': {'type': 'value'},
    'yAxis': {'type': 'category', 'data': ['A', 'B'], 'inverse': True},
    'legend': {'textStyle': {'color': 'gray'}},
    'series': [
        {'type': 'bar', 'name': 'Alpha', 'data': [0.1, 0.2]},
        {'type': 'bar', 'name': 'Beta', 'data': [0.3, 0.4]},
    ],
})

def update():
    echart.options['series'][0]['data'][0] = random()
    echart.update()

ui.button('Update', on_click=update)

ui.run()


Pyplot Context


Create a context to configure a Matplotlib plot.

close: whether the figure should be closed after exiting the context; set to False if you want to update it later (default: True)
kwargs: arguments like figsize which should be passed to pyplot.figure


Coding example:
import numpy as np
from matplotlib import pyplot as plt
from nicegui import ui

with ui.pyplot(figsize=(3, 2)):
    x = np.linspace(0.0, 5.0)
    y = np.cos(2 * np.pi * x) * np.exp(-x)
    plt.plot(x, y, '-')

ui.run()


Matplotlib


Create a Matplotlib element rendering a Matplotlib figure.
The figure is automatically updated when leaving the figure context.

kwargs: arguments like figsize which should be passed to matplotlib.figure.Figure


Coding example:
import numpy as np
from nicegui import ui

with ui.matplotlib(figsize=(3, 2)).figure as fig:
    x = np.linspace(0.0, 5.0)
    y = np.cos(2 * np.pi * x) * np.exp(-x)
    ax = fig.gca()
    ax.plot(x, y, '-')

ui.run()


Line Plot


Create a line plot using pyplot.
The push method provides live updating when utilized in combination with ui.timer .

n: number of lines
limit: maximum number of datapoints per line (new points will displace the oldest)
update_every: update plot only after pushing new data multiple times to save CPU and bandwidth
close: whether the figure should be closed after exiting the context; set to False if you want to update it later (default: True)
kwargs: arguments like figsize which should be passed to pyplot.figure


Coding example:
import math
from datetime import datetime
from nicegui import ui

line_plot = ui.line_plot(n=2, limit=20, figsize=(3, 2), update_every=5) \
    .with_legend(['sin', 'cos'], loc='upper center', ncol=2)

def update_line_plot() -> None:
    now = datetime.now()
    x = now.timestamp()
    y1 = math.sin(x)
    y2 = math.cos(x)
    line_plot.push([now], [[y1], [y2]])

line_updates = ui.timer(0.1, update_line_plot, active=False)
line_checkbox = ui.checkbox('active').bind_value(line_updates, 'active')

ui.run()


Plotly Element


Renders a Plotly chart.
There are two ways to pass a Plotly figure for rendering, see parameter figure :
Pass a go.Figure object, see https://plotly.com/python/
Pass a Python dict object with keys data , layout , config (optional), see https://plotly.com/javascript/
For best performance, use the declarative dict approach for creating a Plotly chart.

figure: Plotly figure to be rendered. Can be either a go.Figure instance, or
a dict object with keys data, layout, config (optional).


Coding example:
import plotly.graph_objects as go
from nicegui import ui

fig = go.Figure(go.Scatter(x=[1, 2, 3, 4], y=[1, 2, 3, 2.5]))
fig.update_layout(margin=dict(l=0, r=0, t=0, b=0))
ui.plotly(fig).classes('w-full h-40')

ui.run()


Linear Progress


A linear progress bar wrapping Quasar's QLinearProgress component.

value: the initial value of the field (from 0.0 to 1.0)
size: the height of the progress bar (default: "20px" with value label and "4px" without)
show_value: whether to show a value label in the center (default: True)
color: color (either a Quasar, Tailwind, or CSS color or None, default: "primary")


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=1, step=0.01, value=0.5)
ui.linear_progress().bind_value_from(slider, 'value')

ui.run()


Circular Progress


A circular progress bar wrapping Quasar's QCircularProgress .

value: the initial value of the field
min: the minimum value (default: 0.0)
max: the maximum value (default: 1.0)
size: the size of the progress circle (default: "xl")
show_value: whether to show a value label in the center (default: True)
color: color (either a Quasar, Tailwind, or CSS color or None, default: "primary")


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=1, step=0.01, value=0.5)
ui.circular_progress().bind_value_from(slider, 'value')

ui.run()


Spinner


This element is based on Quasar's QSpinner component.

type: type of spinner (e.g. "audio", "ball", "bars", ..., default: "default")
size: size of the spinner (e.g. "3em", "10px", "xl", ..., default: "1em")
color: color of the spinner (either a Quasar, Tailwind, or CSS color or None, default: "primary")
thickness: thickness of the spinner (applies to the "default" spinner only, default: 5.0)


Coding example:
from nicegui import ui

with ui.row():
    ui.spinner(size='lg')
    ui.spinner('audio', size='lg', color='green')
    ui.spinner('dots', size='lg', color='red')

ui.run()


3D Scene


Display a 3D scene using three.js .
Currently NiceGUI supports boxes, spheres, cylinders/cones, extrusions, straight lines, curves and textured meshes.
Objects can be translated, rotated and displayed with different color, opacity or as wireframes.
They can also be grouped to apply joint movements.

width: width of the canvas
height: height of the canvas
grid: whether to display a grid (boolean or tuple of size and divisions for Three.js' GridHelper, default: 100x100)
camera: camera definition, either instance of ui.scene.perspective_camera (default) or ui.scene.orthographic_camera
on_click: callback to execute when a 3D object is clicked
on_drag_start: callback to execute when a 3D object is dragged
on_drag_end: callback to execute when a 3D object is dropped
drag_constraints:
 comma-separated JavaScript expression for constraining positions of dragged objects (e.g. 'x = 0, z = y / 2')
background_color:
 background color of the scene (default: "#eee")


Coding example:
from nicegui import ui

with ui.scene().classes('w-full h-64') as scene:
    scene.sphere().material('#4488ff')
    scene.cylinder(1, 0.5, 2, 20).material('#ff8800', opacity=0.5).move(-2, 1)
    scene.extrusion([[0, 0], [0, 1], [1, 0.5]], 0.1).material('#ff8888').move(2, -1)

    with scene.group().move(z=2):
        scene.box().move(x=2)
        scene.box().move(y=2).rotate(0.25, 0.5, 0.75)
        scene.box(wireframe=True).material('#888888').move(x=2, y=2)

    scene.line([-4, 0, 0], [-4, 2, 0]).material('#ff0000')
    scene.curve([-4, 0, 0], [-4, -1, 0], [-3, -1, 0], [-3, 0, 0]).material('#008800')

    logo = 'https://avatars.githubusercontent.com/u/2843826'
    scene.texture(logo, [[[0.5, 2, 0], [2.5, 2, 0]],
                         [[0.5, 0, 0], [2.5, 0, 0]]]).move(1, -3)

    teapot = 'https://upload.wikimedia.org/wikipedia/commons/9/93/Utah_teapot_(solid).stl'
    scene.stl(teapot).scale(0.2).move(-3, 4)

    avocado = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/Avocado/glTF-Binary/Avocado.glb'
    scene.gltf(avocado).scale(40).move(-2, -3, 0.5)

    scene.text('2D', 'background: rgba(0, 0, 0, 0.2); border-radius: 5px; padding: 5px').move(z=2)
    scene.text3d('3D', 'background: rgba(0, 0, 0, 0.2); border-radius: 5px; padding: 5px').move(y=-2).scale(.05)

ui.run()


Leaflet map


This element is a wrapper around the Leaflet JavaScript library.

center: initial center location of the map (latitude/longitude, default: (0.0, 0.0))
zoom: initial zoom level of the map (default: 13)
draw_control: whether to show the draw toolbar (default: False)
options: additional options passed to the Leaflet map (default: {})


Coding example:
from nicegui import ui

m = ui.leaflet(center=(51.505, -0.09))
ui.label().bind_text_from(m, 'center', lambda center: f'Center: {center[0]:.3f}, {center[1]:.3f}')
ui.label().bind_text_from(m, 'zoom', lambda zoom: f'Zoom: {zoom}')

with ui.grid(columns=2):
    ui.button('London', on_click=lambda: m.set_center((51.505, -0.090)))
    ui.button('Berlin', on_click=lambda: m.set_center((52.520, 13.405)))
    ui.button(icon='zoom_in', on_click=lambda: m.set_zoom(m.zoom + 1))
    ui.button(icon='zoom_out', on_click=lambda: m.set_zoom(m.zoom - 1))

ui.run()


Tree


Display hierarchical data using Quasar's QTree component.
If using IDs, make sure they are unique within the whole tree.
To use checkboxes and on_tick , set the tick_strategy parameter to "leaf", "leaf-filtered" or "strict".

nodes: hierarchical list of node objects
node_key: property name of each node object that holds its unique id (default: "id")
label_key: property name of each node object that holds its label (default: "label")
children_key: property name of each node object that holds its list of children (default: "children")
on_select: callback which is invoked when the node selection changes
on_expand: callback which is invoked when the node expansion changes
on_tick: callback which is invoked when a node is ticked or unticked
tick_strategy: whether and how to use checkboxes ("leaf", "leaf-filtered" or "strict"; default: None)


Coding example:
from nicegui import ui

ui.tree([
    {'id': 'numbers', 'children': [{'id': '1'}, {'id': '2'}]},
    {'id': 'letters', 'children': [{'id': 'A'}, {'id': 'B'}]},
], label_key='id', on_select=lambda e: ui.notify(e.value))

ui.run()


Log View


Create a log view that allows to add new lines without re-transmitting the whole history to the client.

max_lines: maximum number of lines before dropping oldest ones (default: None)


Coding example:
from datetime import datetime
from nicegui import ui

log = ui.log(max_lines=10).classes('w-full h-20')
ui.button('Log time', on_click=lambda: log.push(datetime.now().strftime('%X.%f')[:-5]))

ui.run()


Editor


A WYSIWYG editor based on Quasar's QEditor .
The value is a string containing the formatted text as HTML code.

value: initial value
on_change: callback to be invoked when the value changes


Coding example:
from nicegui import ui

editor = ui.editor(placeholder='Type something here')
ui.markdown().bind_content_from(editor, 'value',
                                backward=lambda v: f'HTML code:\n```\n{v}\n```')

ui.run()


Code


This element displays a code block with syntax highlighting.

content: code to display
language: language of the code (default: "python")


Coding example:
from nicegui import ui

ui.code('''
    from nicegui import ui

    ui.label('Code inception!')

    ui.run()
''').classes('w-full')

ui.run()


JSONEditor


An element to create a JSON editor using JSONEditor .
Updates can be pushed to the editor by changing the properties property.
After data has changed, call the update method to refresh the editor.

properties: dictionary of JSONEditor properties
on_select: callback which is invoked when some of the content has been selected
on_change: callback which is invoked when the content has changed


Coding example:
from nicegui import ui

json = {
    'array': [1, 2, 3],
    'boolean': True,
    'color': '#82b92c',
    None: None,
    'number': 123,
    'object': {
        'a': 'b',
        'c': 'd',
    },
    'time': 1575599819000,
    'string': 'Hello World',
}
ui.json_editor({'content': {'json': json}},
               on_select=lambda e: ui.notify(f'Select: {e}'),
               on_change=lambda e: ui.notify(f'Change: {e}'))

ui.run()




____________________________________________________________
Section: 6. URL: http://localhost:8080/documentation/section_binding_properties

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Binding Properties Bindings Bind to dictionary Bind to variable Bind to storage Bindable properties for maximum performance


Binding Properties


Bindings

Binding is possible for UI element properties like text, value or visibility and for model properties that are (nested) class attributes.
Each element provides methods like bind_value and bind_visibility to create a two-way binding with the corresponding property.
To define a one-way binding use the _from and _to variants of these methods.
Just pass a property of the model as parameter to these methods to create the binding.
The values will be updated immediately and whenever one of them changes.


Coding example:
from nicegui import ui

class Demo:
    def __init__(self):
        self.number = 1

demo = Demo()
v = ui.checkbox('visible', value=True)
with ui.column().bind_visibility_from(v, 'value'):
    ui.slider(min=1, max=3).bind_value(demo, 'number')
    ui.toggle({1: 'A', 2: 'B', 3: 'C'}).bind_value(demo, 'number')
    ui.number().bind_value(demo, 'number')

ui.run()


Bind to dictionary

Here we are binding the text of labels to a dictionary.


Coding example:
from nicegui import ui

data = {'name': 'Bob', 'age': 17}

ui.label().bind_text_from(data, 'name', backward=lambda n: f'Name: {n}')
ui.label().bind_text_from(data, 'age', backward=lambda a: f'Age: {a}')

ui.button('Turn 18', on_click=lambda: data.update(age=18))

ui.run()


Bind to variable

Here we are binding the value from the datepicker to a bare variable.
Therefore we use the dictionary globals() which contains all global variables.
This demo is based on the official datepicker example .


Coding example:
from nicegui import ui

date = '2023-01-01'

with ui.input('Date').bind_value(globals(), 'date') as date_input:
    with ui.menu() as menu:
        ui.date(on_change=lambda: ui.notify(f'Date: {date}')).bind_value(date_input)
    with date_input.add_slot('append'):
        ui.icon('edit_calendar').on('click', menu.open).classes('cursor-pointer')

ui.run()


Bind to storage

Bindings also work with app.storage .
Here we are storing the value of a textarea between visits.
The note is also shared between all tabs of the same user.


Coding example:
from nicegui import app, ui

@ui.page('/')
def index():
    ui.textarea('This note is kept between visits')
        .classes('w-full').bind_value(app.storage.user, 'note')

ui.run()


Bindable properties for maximum performance

There are two types of bindings:
"Bindable properties" automatically detect write access and trigger the value propagation.
Most NiceGUI elements use these bindable properties, like value in ui.input or text in ui.label .
Basically all properties with bind() methods support this type of binding.
All other bindings are sometimes called "active links".
If you bind a label text to some dictionary entry or an attribute of a custom data model,
This is done in a refresh_loop() which runs every 0.1 seconds.
The interval can be configured via binding_refresh_interval in ui.run() .
The "bindable properties" are very efficient and don't cost anything as long as the values don't change.
But the "active links" need to check all bound values 10 times per second.
This can get costly, especially if you bind to complex objects like lists or dictionaries.
Because it is crucial not to block the main thread for too long,
we show a warning if one step of the refresh_loop() takes too long.
You can configure the threshold via binding.MAX_PROPAGATION_TIME which defaults to 0.01 seconds.
But often the warning is a valuable indicator for a performance or memory issue.
If your CPU would be busy updating bindings a significant duration,
nothing else could happen on the main thread and the UI "hangs".
The following demo shows how to define and use bindable properties for a Demo class like in the first demo.
The number property is now a BindableProperty ,
which allows NiceGUI to detect write access and trigger the value propagation immediately.


Coding example:
from nicegui import binding, ui

class Demo:
    number = binding.BindableProperty()

    def __init__(self):
        self.number = 1

demo = Demo()
ui.slider(min=1, max=3).bind_value(demo, 'number')
ui.toggle({1: 'A', 2: 'B', 3: 'C'}).bind_value(demo, 'number')
ui.number(min=1, max=3).bind_value(demo, 'number')

ui.run()




____________________________________________________________
Section: 7. URL: http://localhost:8080/documentation/section_page_layout

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Page Layout Auto-context Card Column Element Row Element Grid Element List Clear Containers Teleport Expansion Element Scroll Area Separator Space Skeleton Splitter Tabs Stepper Timeline Carousel Pagination Menu Context Menu Tooltip Notification Notification element Dialog


Page Layout


Auto-context

In order to allow writing intuitive UI descriptions, NiceGUI automatically tracks the context in which elements are created.
This means that there is no explicit parent parameter.
Instead the parent context is defined using a with statement.
It is also passed to event handlers and timers.
In the demo, the label "Card content" is added to the card.
And because the ui.button is also added to the card, the label "Click!" will also be created in this context.
The label "Tick!", which is added once after one second, is also added to the card.
This design decision allows for easily creating modular components that keep working after moving them around in the UI.
For example, you can move label and button somewhere else, maybe wrap them in another container, and the code will still work.


Coding example:
from nicegui import ui

with ui.card():
    ui.label('Card content')
    ui.button('Add label', on_click=lambda: ui.label('Click!'))
    ui.timer(1.0, lambda: ui.label('Tick!'), once=True)

ui.run()


Card


This element is based on Quasar's QCard component.
It provides a container with a dropped shadow.
Note:
There are subtle differences between the Quasar component and this element.
In contrast to this element, the original QCard has no padding by default and hides outer borders of nested elements.
If you want the original behavior, use the tight method.
If you want the padding and borders for nested children, move the children into another container.

align_items: alignment of the items in the card (default: None)


Coding example:
from nicegui import ui

with ui.card().tight():
    ui.image('https://picsum.photos/id/684/640/360')
    with ui.card_section():
        ui.label('Lorem ipsum dolor sit amet, consectetur adipiscing elit, ...')

ui.run()


Column Element


Provides a container which arranges its child in a column.

wrap: whether to wrap the content (default: False)
align_items: alignment of the items in the column (default: None)


Coding example:
from nicegui import ui

with ui.column():
    ui.label('label 1')
    ui.label('label 2')
    ui.label('label 3')

ui.run()


Row Element


Provides a container which arranges its child in a row.

wrap: whether to wrap the content (default: True)
align_items: alignment of the items in the row (default: None)


Coding example:
from nicegui import ui

with ui.row():
    ui.label('label 1')
    ui.label('label 2')
    ui.label('label 3')

ui.run()


Grid Element


Provides a container which arranges its child in a grid.

rows: number of rows in the grid or a string with the grid-template-rows CSS property (e.g. 'auto 1fr')
columns: number of columns in the grid or a string with the grid-template-columns CSS property (e.g. 'auto 1fr')


Coding example:
from nicegui import ui

with ui.grid(columns=2):
    ui.label('Name:')
    ui.label('Tom')

    ui.label('Age:')
    ui.label('42')

    ui.label('Height:')
    ui.label('1.80m')

ui.run()


List


A list element based on Quasar's QList component.
It provides a container for ui.item elements.


Coding example:
from nicegui import ui

with ui.list().props('dense separator'):
    ui.item('3 Apples')
    ui.item('5 Bananas')
    ui.item('8 Strawberries')
    ui.item('13 Walnuts')

ui.run()


Clear Containers

To remove all elements from a row, column or card container, use can call
Coding example:
container.clear()

Alternatively, you can remove individual elements by calling
container.remove(element: Element) ,
container.remove(index: int) , or
element.delete() .


Coding example:
from nicegui import ui

container = ui.row()

def add_face():
    with container:
        ui.icon('face')
add_face()

ui.button('Add', on_click=add_face)
ui.button('Remove', on_click=lambda: container.remove(0) if list(container) else None)
ui.button('Clear', on_click=container.clear)

ui.run()


Teleport


An element that allows us to transmit the content from within a component to any location on the page.

to: NiceGUI element or CSS selector of the target element for the teleported content


Coding example:
from nicegui import ui

markdown = ui.markdown('Enter your **name**!')

def inject_input():
    with ui.teleport(f'#c{markdown.id} strong'):
        ui.input('name').classes('inline-flex').props('dense outlined')

ui.button('inject input', on_click=inject_input)

ui.run()


Expansion Element


Provides an expandable container based on Quasar's QExpansionItem component.

text: title text
caption: optional caption (or sub-label) text
icon: optional icon (default: None)
group: optional group name for coordinated open/close state within the group a.k.a. "accordion mode"
value: whether the expansion should be opened on creation (default: False)
on_value_change:
 callback to execute when value changes


Coding example:
from nicegui import ui

with ui.expansion('Expand!', icon='work').classes('w-full'):
    ui.label('inside the expansion')

ui.run()


Scroll Area


A way of customizing the scrollbars by encapsulating your content.
This element exposes the Quasar ScrollArea component.

on_scroll: function to be called when the scroll position changes


Coding example:
from nicegui import ui

with ui.row():
    with ui.scroll_area().classes('w-32 h-32 border'):
        ui.label('I scroll. ' * 20)
    with ui.column().classes('p-4 w-32 h-32 border'):
        ui.label('I will not scroll. ' * 10)

ui.run()


Separator


This element is based on Quasar's QSeparator component.
It serves as a separator for cards, menus and other component containers and is similar to HTML's <hr> tag.


Coding example:
from nicegui import ui

ui.label('text above')
ui.separator()
ui.label('text below')

ui.run()


Space


This element is based on Quasar's QSpace component.
Its purpose is to simply fill all available space inside of a flexbox element.


Coding example:
from nicegui import ui

with ui.row().classes('w-full border'):
    ui.label('Left')
    ui.space()
    ui.label('Right')

ui.run()


Skeleton


This element is based on Quasar's QSkeleton component.
It serves as a placeholder for loading content in cards, menus and other component containers.
See the Quasar documentation for a list of available types.

type: type of skeleton to display (default: "rect")
tag: HTML tag to use for this element (default: "div")
animation: animation effect of the skeleton placeholder (default: "wave")
animation_speed:
 animation speed in seconds (default: 1.5)
square: whether to remover border-radius so borders are squared (default: False)
bordered: whether to apply a default border to the component (default: False)
size: size in CSS units (overrides width and height)
width: width in CSS units (overridden by size if set)
height: height in CSS units (overridden by size if set)


Coding example:
from nicegui import ui

ui.skeleton().classes('w-full')

ui.run()


Splitter


The ui.splitter element divides the screen space into resizable sections,
allowing for flexible and responsive layouts in your application.
Based on Quasar's Splitter component: Splitter
It provides three customizable slots, before , after , and separator ,
which can be used to embed other elements within the splitter.

horizontal: Whether to split horizontally instead of vertically
limits: Two numbers representing the minimum and maximum split size of the two panels
value: Size of the first panel (or second if using reverse)
reverse: Whether to apply the model size to the second panel instead of the first
on_change: callback which is invoked when the user releases the splitter


Coding example:
from nicegui import ui

with ui.splitter() as splitter:
    with splitter.before:
        ui.label('This is some content on the left hand side.').classes('mr-2')
    with splitter.after:
        ui.label('This is some content on the right hand side.').classes('ml-2')

ui.run()


Tabs

The elements ui.tabs , ui.tab , ui.tab_panels , and ui.tab_panel resemble Quasar's tabs and tab panels API.
ui.tabs creates a container for the tabs. This could be placed in a ui.header for example. ui.tab_panels creates a container for the tab panels with the actual content.
Each ui.tab_panel is associated with a ui.tab element.


Coding example:
from nicegui import ui

with ui.tabs().classes('w-full') as tabs:
    one = ui.tab('One')
    two = ui.tab('Two')
with ui.tab_panels(tabs, value=two).classes('w-full'):
    with ui.tab_panel(one):
        ui.label('First tab')
    with ui.tab_panel(two):
        ui.label('Second tab')

ui.run()


Stepper


This element represents Quasar's QStepper component.
It contains individual steps.
To avoid issues with dynamic elements when switching steps,
this element uses Vue's keep-alive component.
If client-side performance is an issue, you can disable this feature.

value: ui.step or name of the step to be initially selected (default: None meaning the first step)
on_value_change:
 callback to be executed when the selected step changes
keep_alive: whether to use Vue's keep-alive component on the content (default: True)


Coding example:
from nicegui import ui

with ui.stepper().props('vertical').classes('w-full') as stepper:
    with ui.step('Preheat'):
        ui.label('Preheat the oven to 350 degrees')
        with ui.stepper_navigation():
            ui.button('Next', on_click=stepper.next)
    with ui.step('Ingredients'):
        ui.label('Mix the ingredients')
        with ui.stepper_navigation():
            ui.button('Next', on_click=stepper.next)
            ui.button('Back', on_click=stepper.previous).props('flat')
    with ui.step('Bake'):
        ui.label('Bake for 20 minutes')
        with ui.stepper_navigation():
            ui.button('Done', on_click=lambda: ui.notify('Yay!', type='positive'))
            ui.button('Back', on_click=stepper.previous).props('flat')

ui.run()


Timeline


This element represents Quasar's QTimeline component.

side: Side ("left" or "right"; default: "left").
layout: Layout ("dense", "comfortable" or "loose"; default: "dense").
color: Color of the icons.


Coding example:
from nicegui import ui

with ui.timeline(side='right'):
    ui.timeline_entry('Rodja and Falko start working on NiceGUI.',
                      title='Initial commit',
                      subtitle='May 07, 2021')
    ui.timeline_entry('The first PyPI package is released.',
                      title='Release of 0.1',
                      subtitle='May 14, 2021')
    ui.timeline_entry('Large parts are rewritten to remove JustPy '
                      'and to upgrade to Vue 3 and Quasar 2.',
                      title='Release of 1.0',
                      subtitle='December 15, 2022',
                      icon='rocket')

ui.run()


Carousel


This element represents Quasar's QCarousel component.
It contains individual carousel slides.

value: ui.carousel_slide or name of the slide to be initially selected (default: None meaning the first slide)
on_value_change:
 callback to be executed when the selected slide changes
animated: whether to animate slide transitions (default: False)
arrows: whether to show arrows for manual slide navigation (default: False)
navigation: whether to show navigation dots for manual slide navigation (default: False)


Coding example:
from nicegui import ui

with ui.carousel(animated=True, arrows=True, navigation=True).props('height=180px'):
    with ui.carousel_slide().classes('p-0'):
        ui.image('https://picsum.photos/id/30/270/180').classes('w-[270px]')
    with ui.carousel_slide().classes('p-0'):
        ui.image('https://picsum.photos/id/31/270/180').classes('w-[270px]')
    with ui.carousel_slide().classes('p-0'):
        ui.image('https://picsum.photos/id/32/270/180').classes('w-[270px]')

ui.run()


Pagination


A pagination element wrapping Quasar's QPagination component.

min: minimum page number
max: maximum page number
direction_links:
 whether to show first/last page links
value: initial page (defaults to min if no value is provided)
on_change: callback to be invoked when the value changes


Coding example:
from nicegui import ui

p = ui.pagination(1, 5, direction_links=True)
ui.label().bind_text_from(p, 'value', lambda v: f'Page {v}')

ui.run()


Menu


Creates a menu based on Quasar's QMenu component.
The menu should be placed inside the element where it should be shown.
Advanced tip:
Use the auto-close prop to automatically close the menu on any click event directly without a server round-trip.

value: whether the menu is already opened (default: False)


Coding example:
from nicegui import ui

with ui.row().classes('w-full items-center'):
    result = ui.label().classes('mr-auto')
    with ui.button(icon='menu'):
        with ui.menu() as menu:
            ui.menu_item('Menu item 1', lambda: result.set_text('Selected item 1'))
            ui.menu_item('Menu item 2', lambda: result.set_text('Selected item 2'))
            ui.menu_item('Menu item 3 (keep open)',
                         lambda: result.set_text('Selected item 3'), auto_close=False)
            ui.separator()
            ui.menu_item('Close', menu.close)

ui.run()


Context Menu


Creates a context menu based on Quasar's QMenu component.
The context menu should be placed inside the element where it should be shown.
It is automatically opened when the user right-clicks on the element and appears at the mouse position.


Coding example:
from nicegui import ui

with ui.image('https://picsum.photos/id/377/640/360'):
    with ui.context_menu():
        ui.menu_item('Flip horizontally')
        ui.menu_item('Flip vertically')
        ui.separator()
        ui.menu_item('Reset', auto_close=False)

ui.run()


Tooltip


This element is based on Quasar's QTooltip component.
It can be placed in another element to show additional information on hover.
Instead of passing a string as the first argument, you can also nest other elements inside the tooltip.

text: the content of the tooltip (default: '')


Coding example:
from nicegui import ui

with ui.button(icon='thumb_up'):
    ui.tooltip('I like this').classes('bg-green')

ui.run()


Notification


Displays a notification on the screen.

message: content of the notification
position: position on the screen ("top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right" or "center", default: "bottom")
close_button: optional label of a button to dismiss the notification (default: False)
type: optional type ("positive", "negative", "warning", "info" or "ongoing")
color: optional color name
multi_line: enable multi-line notifications
Note: You can pass additional keyword arguments according to Quasar's Notify API .


Coding example:
from nicegui import ui

ui.button('Say hi!', on_click=lambda: ui.notify('Hi!', close_button='OK'))

ui.run()


Notification element


Displays a notification on the screen.
In contrast to ui.notify , this element allows to update the notification message and other properties once the notification is displayed.
The notification can be removed with dismiss() .

message: content of the notification
position: position on the screen ("top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right" or "center", default: "bottom")
close_button: optional label of a button to dismiss the notification (default: False)
type: optional type ("positive", "negative", "warning", "info" or "ongoing")
color: optional color name
multi_line: enable multi-line notifications
icon: optional name of an icon to be displayed in the notification (default: None)
spinner: display a spinner in the notification (default: False)
timeout: optional timeout in seconds after which the notification is dismissed (default: 5.0)
on_dismiss: optional callback to be invoked when the notification is dismissed
options: optional dictionary with all options (overrides all other arguments)
Note: You can pass additional keyword arguments according to Quasar's Notify API .


Coding example:
import asyncio
from nicegui import ui

async def compute():
    n = ui.notification(timeout=None)
    for i in range(10):
        n.message = f'Computing {i/10:.0%}'
        n.spinner = True
        await asyncio.sleep(0.2)
    n.message = 'Done!'
    n.spinner = False
    await asyncio.sleep(1)
    n.dismiss()

ui.button('Compute', on_click=compute)

ui.run()


Dialog


Creates a dialog based on Quasar's QDialog component.
By default it is dismissible by clicking or pressing ESC.
To make it persistent, set .props('persistent') on the dialog element.
NOTE: The dialog is an element.
That means it is not removed when closed, but only hidden.
You should either create it only once and then reuse it, or remove it with .clear() after dismissal.

value: whether the dialog should be opened on creation (default: False)


Coding example:
from nicegui import ui

with ui.dialog() as dialog, ui.card():
    ui.label('Hello world!')
    ui.button('Close', on_click=dialog.close)

ui.button('Open a dialog', on_click=dialog.open)

ui.run()




____________________________________________________________
Section: 8. URL: http://localhost:8080/documentation/section_styling_appearance

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Styling & Appearance Styling Try styling NiceGUI elements! Tailwind CSS Tailwind CSS Layers ElementFilter Query Selector Color Theming CSS Variables Overwrite Tailwind's Default Style Dark mode Add CSS style definitions to the page


Styling & Appearance


Styling

Each NiceGUI element provides a props method whose content is passed to the Quasar component :
Have a look at the Quasar documentation for all styling props.
Props with a leading : can contain JavaScript expressions that are evaluated on the client.
You can also apply Tailwind CSS utility classes with the classes method.
If you really need to apply CSS, you can use the style method. Here the delimiter is ; instead of a blank space.
All three functions also provide remove and replace parameters in case the predefined look is not wanted in a particular styling.


Coding example:
from nicegui import ui

ui.radio(['x', 'y', 'z'], value='x').props('inline color=green')
ui.button(icon='touch_app').props('outline round').classes('shadow-lg')
ui.label('Stylish!').style('color: #6E93D6; font-size: 200%; font-weight: 300')

ui.run()


Try styling NiceGUI elements!

Try out how Tailwind CSS classes , Quasar props ,
and CSS styles affect NiceGUI elements.

Select an element from those available and start styling it!


ui.button
arrow_drop_down


Coding example:
from nicegui import ui

element = ui.button('element')


element.classes('


')


element.props('


')


element.style('


')

Coding example:
ui.run()


element


Tailwind CSS

Tailwind CSS is a CSS framework for rapidly building custom user interfaces.
You can discover available classes by navigating the methods of the tailwind property.
The builder pattern allows you to chain multiple classes together (as shown with "Label A").
You can also call the tailwind property with a list of classes (as shown with "Label B").
Although this is very similar to using the classes method, it is more convenient for Tailwind classes due to auto-completion.
Last but not least, you can also predefine a style and apply it to multiple elements (labels C and D).
Note that sometimes Tailwind is overruled by Quasar styles, e.g. when using ui.button('Button').tailwind('bg-red-500') .
This is a known limitation and not fully in our control.
But we try to provide solutions like the color parameter: ui.button('Button', color='red-500') .


Coding example:
from nicegui import Tailwind, ui

ui.label('Label A').tailwind.font_weight('extrabold').text_color('blue-600').background_color('orange-200')
ui.label('Label B').tailwind('drop-shadow', 'font-bold', 'text-green-600')

red_style = Tailwind().text_color('red-600').font_weight('bold')
label_c = ui.label('Label C')
red_style.apply(label_c)
ui.label('Label D').tailwind(red_style)

ui.run()


Tailwind CSS Layers

Tailwind CSS' @layer directive allows you to define custom classes that can be used in your HTML.
This way, you can define your own classes and use them in your UI elements.
In the example below, we define a custom class blue-box and apply it to two labels.
Note that the style tag is of type text/tailwindcss and not text/css .


Coding example:
from nicegui import ui

ui.add_head_html('''
    <style type="text/tailwindcss">
        @layer components {
            .blue-box {
                @apply bg-blue-500 p-12 text-center shadow-lg rounded-lg text-white;
            }
        }
    </style>
''')

with ui.row():
    ui.label('Hello').classes('blue-box')
    ui.label('world').classes('blue-box')

ui.run()


ElementFilter


Sometimes it is handy to search the Python element tree of the current page. ElementFilter() allows powerful filtering by kind of elements, markers and content.
It also provides a fluent interface to apply more filters like excluding elements or filtering for elements within a specific parent.
The filter can be used as an iterator to iterate over the found elements and is always applied while iterating and not when being instantiated.
And element is yielded if it matches all of the following conditions:
The element is of the specified kind (if specified).
The element is none of the excluded kinds.
The element has all of the specified markers.
The element has none of the excluded markers.
The element contains all of the specified content.
The element contains none of the excluded content.
Its ancestors include all of the specified instances defined via within .
Its ancestors include none of the specified instances defined via not_within .
Its ancestors include all of the specified kinds defined via within .
Its ancestors include none of the specified kinds defined via not_within .
Its ancestors include all of the specified markers defined via within .
Its ancestors include none of the specified markers defined via not_within .
Element "content" includes its text, label, icon, placeholder, value, message, content, source.
Partial matches like "Hello" in "Hello World!" are sufficient for content filtering.

kind: filter by element type; the iterator will be of type kind
marker: filter by element markers; can be a list of strings or a single string where markers are separated by whitespace
content: filter for elements which contain content in one of their content attributes like .text, .value, .source, ...; can be a singe string or a list of strings which all must match
local_scope: if True, only elements within the current scope are returned; by default the whole page is searched (this default behavior can be changed with ElementFilter.DEFAULT_LOCAL_SCOPE = True)


Coding example:
from nicegui import ElementFilter, ui

with ui.card():
    ui.button('button A')
    ui.label('label A')

with ui.card().mark('important'):
    ui.button('button B')
    ui.label('label B')

ElementFilter(kind=ui.label).within(marker='important').classes('text-xl')

ui.run()


Query Selector


To manipulate elements like the document body, you can use the ui.query function.
With the query result you can add classes, styles, and attributes like with every other UI element.
This can be useful for example to change the background color of the page (e.g. ui.query('body').classes('bg-green') ).

selector: the CSS selector (e.g. "body", "#my-id", ".my-class", "div > p")


Coding example:
from nicegui import ui

def set_background(color: str) -> None:
    ui.query('body').style(f'background-color: {color}')

ui.button('Blue', on_click=lambda: set_background('#ddeeff'))
ui.button('Orange', on_click=lambda: set_background('#ffeedd'))

ui.run()


Color Theming


Sets the main colors (primary, secondary, accent, ...) used by Quasar .


Coding example:
from nicegui import ui

ui.button('Default', on_click=lambda: ui.colors())
ui.button('Gray', on_click=lambda: ui.colors(primary='#555'))

ui.run()


CSS Variables

You can customize the appearance of NiceGUI by setting CSS variables.
Currently, the following variables with their default values are available:
--nicegui-default-padding: 1rem
--nicegui-default-gap: 1rem


Coding example:
from nicegui import ui

ui.add_css('''
    :root {
        --nicegui-default-padding: 0.5rem;
        --nicegui-default-gap: 3rem;
    }
''')
with ui.card():
    ui.label('small padding')
    ui.label('large gap')

ui.run()


Overwrite Tailwind's Default Style

Tailwind resets the default style of HTML elements, like the font size of h2 elements in this example.
You can overwrite these defaults by adding a style tag with type text/tailwindcss .
Without this type, the style will be evaluated too early and will be overwritten by Tailwind.


Coding example:
from nicegui import ui

ui.add_head_html('''
    <style type="text/tailwindcss">
        h2 {
            font-size: 150%;
        }
    </style>
''')
ui.html('<h2>Hello world!</h2>')

ui.run()


Dark mode


You can use this element to enable, disable or toggle dark mode on the page.
The value None represents auto mode, which uses the client's system preference.
Note that this element overrides the dark parameter of the ui.run function and page decorators.

value: Whether dark mode is enabled. If None, dark mode is set to auto.
on_change: Callback that is invoked when the value changes.


Coding example:
from nicegui import ui

dark = ui.dark_mode()
ui.label('Switch mode:')
ui.button('Dark', on_click=dark.enable)
ui.button('Light', on_click=dark.disable)

ui.run()


Add CSS style definitions to the page


This function can be used to add CSS style definitions to the head of the HTML page.

content: CSS content (string or file path)


Coding example:
from nicegui import ui

ui.add_css('''
    .red {
        color: red;
    }
''')
ui.label('This is red with CSS.').classes('red')

ui.run()




____________________________________________________________
Section: 9. URL: http://localhost:8080/documentation/section_action_events

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Action & Events Timer Keyboard UI Updates Refreshable UI functions Async event handlers Generic Events Running CPU-bound tasks Running I/O-bound tasks Run JavaScript Read and write to the clipboard Events Shut down NiceGUI Storage


Action & Events


Timer


One major drive behind the creation of NiceGUI was the necessity to have a simple approach to update the interface in regular intervals,
for example to show a graph with incoming measurements.
A timer will execute a callback repeatedly with a given interval.

interval: the interval in which the timer is called (can be changed during runtime)
callback: function or coroutine to execute when interval elapses
active: whether the callback should be executed or not (can be changed during runtime)
once: whether the callback is only executed once after a delay specified by interval (default: False)


Coding example:
from datetime import datetime
from nicegui import ui

label = ui.label()
ui.timer(1.0, lambda: label.set_text(f'{datetime.now():%X}'))

ui.run()


Keyboard


Adds global keyboard event tracking.
The on_key callback receives a KeyEventArguments object with the following attributes:
sender : the Keyboard element
client : the client object
action : a KeyboardAction object with the following attributes:
keydown : whether the key was pressed
keyup : whether the key was released
repeat : whether the key event was a repeat
key : a KeyboardKey object with the following attributes:
name : the name of the key (e.g. "a", "Enter", "ArrowLeft"; see here for a list of possible values)
code : the code of the key (e.g. "KeyA", "Enter", "ArrowLeft")
location : the location of the key (0 for standard keys, 1 for left keys, 2 for right keys, 3 for numpad keys)
modifiers : a KeyboardModifiers object with the following attributes:
alt : whether the alt key was pressed
ctrl : whether the ctrl key was pressed
meta : whether the meta key was pressed
shift : whether the shift key was pressed For convenience, the KeyboardKey object also has the following properties:
is_cursorkey : whether the key is a cursor (arrow) key
number : the integer value of a number key (0-9, None for other keys)
backspace , tab , enter , shift , control , alt , pause , caps_lock , escape , space , page_up , page_down , end , home , arrow_left , arrow_up , arrow_right , arrow_down , print_screen , insert , delete , meta , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 : whether the key is the respective key

on_key: callback to be executed when keyboard events occur.
active: boolean flag indicating whether the callback should be executed or not (default: True)
repeating: boolean flag indicating whether held keys should be sent repeatedly (default: True)
ignore: ignore keys when one of these element types is focussed (default: ['input', 'select', 'button', 'textarea'])


Coding example:
from nicegui import ui
from nicegui.events import KeyEventArguments

def handle_key(e: KeyEventArguments):
    if e.key == 'f' and not e.action.repeat:
        if e.action.keyup:
            ui.notify('f was just released')
        elif e.action.keydown:
            ui.notify('f was just pressed')
    if e.modifiers.shift and e.action.keydown:
        if e.key.arrow_left:
            ui.notify('going left')
        elif e.key.arrow_right:
            ui.notify('going right')
        elif e.key.arrow_up:
            ui.notify('going up')
        elif e.key.arrow_down:
            ui.notify('going down')

keyboard = ui.keyboard(on_key=handle_key)
ui.label('Key events can be caught globally by using the keyboard element.')
ui.checkbox('Track key events').bind_value_to(keyboard, 'active')

ui.run()


UI Updates

e.g. when a label text, an input value or style/classes/props of an element have changed.
In other cases, you can explicitly call element.update() or ui.update(*elements) to update.
The demo code shows both methods for a ui.echart , where it is difficult to automatically detect changes in the options dictionary.


Coding example:
from nicegui import ui
from random import random

chart = ui.echart({
    'xAxis': {'type': 'value'},
    'yAxis': {'type': 'value'},
    'series': [{'type': 'line', 'data': [[0, 0], [1, 1]]}],
})

def add():
    chart.options['series'][0]['data'].append([random(), random()])
    chart.update()

def clear():
    chart.options['series'][0]['data'].clear()
    ui.update(chart)

with ui.row():
    ui.button('Add', on_click=add)
    ui.button('Clear', on_click=clear)

ui.run()


Refreshable UI functions


The @ui.refreshable decorator allows you to create functions that have a refresh method.
This method will automatically delete all elements created by the function and recreate them.


Coding example:
import random
from nicegui import ui

numbers = []

@ui.refreshable
def number_ui() -> None:
    ui.label(', '.join(str(n) for n in sorted(numbers)))

def add_number() -> None:
    numbers.append(random.randint(0, 100))
    number_ui.refresh()

number_ui()
ui.button('Add random number', on_click=add_number)

ui.run()


Async event handlers

Most elements also support asynchronous event handlers.
Note: You can also pass a functools.partial into the on_click property to wrap async functions with parameters.


Coding example:
import asyncio
from nicegui import ui

async def async_task():
    ui.notify('Asynchronous task started')
    await asyncio.sleep(5)
    ui.notify('Asynchronous task finished')

ui.button('start async task', on_click=async_task)

ui.run()


Generic Events

Most UI elements come with predefined events.
For example, a ui.button like "A" in the demo has an on_click parameter that expects a coroutine or function.
But you can also use the on method to register a generic event handler like for "B".
This allows you to register handlers for any event that is supported by JavaScript and Quasar.
For example, you can register a handler for the mousemove event like for "C", even though there is no on_mousemove parameter for ui.button .
Some events, like mousemove , are fired very often.
To avoid performance issues, you can use the throttle parameter to only call the handler every throttle seconds ("D").
The generic event handler can be synchronous or asynchronous and optionally takes GenericEventArguments as argument ("E").
You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler ("F").
This can reduce the amount of data that needs to be transferred between the server and the client.
Here you can find more information about the events that are supported:
https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements
https://quasar.dev/vue-components for Quasar-based elements (see the "Events" tab on the individual component page)


Coding example:
from nicegui import ui

with ui.row():
    ui.button('A', on_click=lambda: ui.notify('You clicked the button A.'))
    ui.button('B').on('click', lambda: ui.notify('You clicked the button B.'))
with ui.row():
    ui.button('C').on('mousemove', lambda: ui.notify('You moved on button C.'))
    ui.button('D').on('mousemove', lambda: ui.notify('You moved on button D.'), throttle=0.5)
with ui.row():
    ui.button('E').on('mousedown', lambda e: ui.notify(e))
    ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])

ui.run()


Running CPU-bound tasks

This is useful for long-running computations that would otherwise block the event loop and make the UI unresponsive.
The function returns a future that can be awaited.
Note:
The function needs to transfer the whole state of the passed function to the process, which is done with pickle.
It is encouraged to create free functions or static methods which get all the data as simple parameters (i.e. no class or UI logic)
and return the result, instead of writing it in class properties or global variables.


Coding example:
import time
from nicegui import run, ui

def compute_sum(a: float, b: float) -> float:
    time.sleep(1)  # simulate a long-running computation
    return a + b

async def handle_click():
    result = await run.cpu_bound(compute_sum, 1, 2)
    ui.notify(f'Sum is {result}')

ui.button('Compute', on_click=handle_click)

ui.run()


Running I/O-bound tasks

This is useful for long-running I/O operations that would otherwise block the event loop and make the UI unresponsive.
The function returns a future that can be awaited.


Coding example:
import requests
from nicegui import run, ui

async def handle_click():
    URL = 'https://httpbin.org/delay/1'
    response = await run.io_bound(requests.get, URL, timeout=3)
    ui.notify(f'Downloaded {len(response.content)} bytes')

ui.button('Download', on_click=handle_click)

ui.run()


Run JavaScript


This function runs arbitrary JavaScript code on a page that is executed in the browser.
The client must be connected before this function is called.
To access a client-side object by ID, use the JavaScript function getElement() .
If the function is awaited, the result of the JavaScript code is returned.
Otherwise, the JavaScript code is executed without waiting for a response.

code: JavaScript code to run
timeout: timeout in seconds (default: 1.0)
return: AwaitableResponse that can be awaited to get the result of the JavaScript code


Coding example:
from nicegui import ui

def alert():
    ui.run_javascript('alert("Hello!")')

async def get_date():
    time = await ui.run_javascript('Date()')
    ui.notify(f'Browser time: {time}')

def access_elements():
    ui.run_javascript(f'getElement({label.id}).innerText += " Hello!"')

ui.button('fire and forget', on_click=alert)
ui.button('receive result', on_click=get_date)
ui.button('access elements', on_click=access_elements)
label = ui.label()

ui.run()


Read and write to the clipboard

The following demo shows how to use ui.clipboard.read() and ui.clipboard.write() to interact with the clipboard.
Because auto-index page can be accessed by multiple browser tabs simultaneously, reading the clipboard is not supported on this page.
This is only possible within page-builder functions decorated with ui.page , as shown in this demo.
Note that your browser may ask for permission to access the clipboard or may not support this feature at all.


Coding example:
from nicegui import ui

@ui.page('/')
async def index():
    ui.button('Write', on_click=lambda: ui.clipboard.write('Hi!'))

    async def read() -> None:
        ui.notify(await ui.clipboard.read())
    ui.button('Read', on_click=read)

ui.run()


Events

You can register coroutines or functions to be called for the following events:
app.on_startup : called when NiceGUI is started or restarted
app.on_shutdown : called when NiceGUI is shut down or restarted
app.on_connect : called for each client which connects (optional argument: nicegui.Client)
app.on_disconnect : called for each client which disconnects (optional argument: nicegui.Client)
app.on_exception : called when an exception occurs (optional argument: exception)
When NiceGUI is shut down or restarted, all tasks still in execution will be automatically canceled.


Coding example:
from datetime import datetime
from nicegui import app, ui

dt = datetime.now()

def handle_connection():
    global dt
    dt = datetime.now()
app.on_connect(handle_connection)

label = ui.label()
ui.timer(1, lambda: label.set_text(f'Last new connection: {dt:%H:%M:%S}'))

ui.run()


Shut down NiceGUI


This will programmatically stop the server.


Coding example:
from nicegui import app, ui

ui.button('shutdown', on_click=app.shutdown)

ui.run(reload=False)


Storage

It features five built-in storage types:
app.storage.tab :
Stored server-side in memory, this dictionary is unique to each tab session and can hold arbitrary objects.
Data will be lost when restarting the server until https://github.com/zauberzeug/nicegui/discussions/2841 is implemented.
This storage is only available within page builder functions and requires an established connection, obtainable via await client.connected() .
app.storage.client :
Also stored server-side in memory, this dictionary is unique to each client connection and can hold arbitrary objects.
Data will be discarded when the page is reloaded or the user navigates to another page.
Unlike data stored in app.storage.tab which can be persisted on the server even for days, app.storage.client helps caching resource-hungry objects such as a streaming or database connection you need to keep alive
for dynamic site updates but would like to discard as soon as the user leaves the page or closes the browser.
This storage is only available within page builder functions .
app.storage.user :
Stored server-side, each dictionary is associated with a unique identifier held in a browser session cookie.
Unique to each user, this storage is accessible across all their browser tabs. app.storage.browser['id'] is used to identify the user.
app.storage.general :
Also stored server-side, this dictionary provides a shared storage space accessible to all users.
app.storage.browser :
Unlike the previous types, this dictionary is stored directly as the browser session cookie, shared among all browser tabs for the same user.
However, app.storage.user is generally preferred due to its advantages in reducing data payload, enhancing security, and offering larger storage capacity.
By default, NiceGUI holds a unique identifier for the browser session in app.storage.browser['id'] .
The user storage and browser storage are only available within page builder functions </documentation/page> _
because they are accessing the underlying Request object from FastAPI.
Additionally these two types require the storage_secret parameter in ui.run() to sign the browser session cookie.

Storage type tab client user general browser
Location Server Server Server Server Browser
Across tabs No No Yes Yes Yes
Across browsers No No No Yes No
Across server restarts No No No Yes No
Across page reloads Yes No Yes Yes Yes
Needs page builder function Yes Yes Yes No Yes
Needs client connection Yes No No No No
Write only before response No No No No Yes
Needs serializable data No No Yes Yes Yes


Coding example:
from nicegui import app, ui

@ui.page('/')
def index():
    app.storage.user['count'] = app.storage.user.get('count', 0) + 1
    with ui.row():
       ui.label('your own page visits:')
       ui.label().bind_text_from(app.storage.user, 'count')

ui.run(storage_secret='private key to secure the browser session cookie')




____________________________________________________________
Section: 10. URL: http://localhost:8080/documentation/section_pages_routing

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Pages & Routing Page Auto-index page Page Layout Parameter injection Page title Navigation functions ui.open Download Add a directory of static files Add directory of media files Add HTML to the page API Responses


Pages & Routing


Page


This decorator marks a function to be a page builder.
Each user accessing the given route will see a new instance of the page.
This means it is private to the user and not shared with others
(as it is done when placing elements outside of a page decorator ).
Note:
The name of the decorated function is unused and can be anything.
The page route is determined by the path argument and registered globally.

path: route of the new page (path must start with '/')
title: optional page title
viewport: optional viewport meta tag content
favicon: optional relative filepath or absolute URL to a favicon (default: None, NiceGUI icon will be used)
dark: whether to use Quasar's dark mode (defaults to dark argument of run command)
language: language of the page (defaults to language argument of run command)
response_timeout:
 maximum time for the decorated function to build the page (default: 3.0 seconds)
reconnect_timeout:
 maximum time the server waits for the browser to reconnect (default: 0.0 seconds)
api_router: APIRouter instance to use, can be left None to use the default
kwargs: additional keyword arguments passed to FastAPI's @app.get method


Coding example:
from nicegui import ui

@ui.page('/other_page')
def other_page():
    ui.label('Welcome to the other side')

@ui.page('/dark_page', dark=True)
def dark_page():
    ui.label('Welcome to the dark side')

ui.link('Visit other page', other_page)
ui.link('Visit dark page', dark_page)

ui.run()


Auto-index page

Pages created with the @ui.page decorator are "private".
Their content is re-created for each client.
Thus, in the demo to the right, the displayed ID on the private page changes when the browser reloads the page.
UI elements that are not wrapped in a decorated page function are placed on an automatically generated index page at route "/".
This auto-index page is created once on startup and shared across all clients that might connect.
Thus, each connected client will see the same elements.
In the demo to the right, the displayed ID on the auto-index page remains constant when the browser reloads the page.


Coding example:
from nicegui import ui
from uuid import uuid4

@ui.page('/private_page')
async def private_page():
    ui.label(f'private page with ID {uuid4()}')

ui.label(f'shared auto-index page with ID {uuid4()}')
ui.link('private page', private_page)

ui.run()


Page Layout

With ui.header , ui.footer , ui.left_drawer and ui.right_drawer you can add additional layout elements to a page.
The fixed argument controls whether the element should scroll or stay fixed on the screen.
The top_corner and bottom_corner arguments indicate whether a drawer should expand to the top or bottom of the page.
See https://quasar.dev/layout/header-and-footer and https://quasar.dev/layout/drawer for more information about possible props.
With ui.page_sticky you can place an element "sticky" on the screen.
See https://quasar.dev/layout/page-sticky for more information.


Coding example:
from nicegui import ui

@ui.page('/page_layout')
def page_layout():
    ui.label('CONTENT')
    [ui.label(f'Line {i}') for i in range(100)]
    with ui.header(elevated=True).style('background-color: #3874c8').classes('items-center justify-between'):
        ui.label('HEADER')
        ui.button(on_click=lambda: right_drawer.toggle(), icon='menu').props('flat color=white')
    with ui.left_drawer(top_corner=True, bottom_corner=True).style('background-color: #d7e3f4'):
        ui.label('LEFT DRAWER')
    with ui.right_drawer(fixed=False).style('background-color: #ebf1fa').props('bordered') as right_drawer:
        ui.label('RIGHT DRAWER')
    with ui.footer().style('background-color: #3874c8'):
        ui.label('FOOTER')

ui.link('show page with fancy layout', page_layout)

ui.run()


Parameter injection

Thanks to FastAPI, a page function accepts optional parameters to provide path parameters , query parameters or the whole incoming request for accessing
the body payload, headers, cookies and more.


Coding example:
from nicegui import ui

@ui.page('/icon/{icon}')
def icons(icon: str, amount: int = 1):
    ui.label(icon).classes('text-h3')
    with ui.row():
        [ui.icon(icon).classes('text-h3') for _ in range(amount)]
ui.link('Star', '/icon/star?amount=5')
ui.link('Home', '/icon/home')
ui.link('Water', '/icon/water_drop?amount=3')

ui.run()


Page title


Set the page title for the current client.

title: page title


Coding example:
from nicegui import ui

ui.button('Change page title', on_click=lambda: ui.page_title('New Title'))

ui.run()


Navigation functions


These functions allow you to navigate within the browser history and to external URLs.


Coding example:
from nicegui import ui

with ui.row():
    ui.button('Back', on_click=ui.navigate.back)
    ui.button('Forward', on_click=ui.navigate.forward)
    ui.button(icon='savings',
              on_click=lambda: ui.navigate.to('https://github.com/sponsors/zauberzeug'))

ui.run()


ui.open

The ui.open function is deprecated.
Use ui.navigate.to instead.


Download


Function to trigger the download of a file, URL or bytes.

src: target URL, local path of a file or raw data which should be downloaded
filename: name of the file to download (default: name of the file on the server)
media_type: media type of the file to download (default: "")


Coding example:
from nicegui import ui

ui.button('Logo', on_click=lambda: ui.download('https://nicegui.io/logo.png'))

ui.run()


Add a directory of static files


add_static_files() makes a local directory available at the specified endpoint, e.g. '/static' .
This is useful for providing local data like images to the frontend.
Otherwise the browser would not be able to access the files.
Do only put non-security-critical files in there, as they are accessible to everyone.
To make a single file accessible, you can use add_static_file() .
For media files which should be streamed, you can use add_media_files() or add_media_file() instead.

url_path: string that starts with a slash "/" and identifies the path at which the files should be served
local_directory:
 local folder with files to serve as static content
follow_symlink: whether to follow symlinks (default: False)


Coding example:
from nicegui import app, ui

app.add_static_files('/examples', 'examples')
ui.label('Some NiceGUI Examples').classes('text-h5')
ui.link('AI interface', '/examples/ai_interface/main.py')
ui.link('Custom FastAPI app', '/examples/fastapi/main.py')
ui.link('Authentication', '/examples/authentication/main.py')

ui.run()


Add directory of media files


add_media_files() allows a local files to be streamed from a specified endpoint, e.g. '/media' .
This should be used for media files to support proper streaming.
Otherwise the browser would not be able to access and load the the files incrementally or jump to different positions in the stream.
Do only put non-security-critical files in there, as they are accessible to everyone.
To make a single file accessible via streaming, you can use add_media_file() .
For small static files, you can use add_static_files() or add_static_file() instead.

url_path: string that starts with a slash "/" and identifies the path at which the files should be served
local_directory:
 local folder with files to serve as media content


Coding example:
import requests
from nicegui import app, ui
from pathlib import Path

media = Path('media')
media.mkdir(exist_ok=True)
r = requests.get('https://cdn.coverr.co/videos/coverr-cloudy-sky-2765/1080p.mp4')
(media  / 'clouds.mp4').write_bytes(r.content)
app.add_media_files('/my_videos', media)
ui.video('/my_videos/clouds.mp4')

ui.run()


Add HTML to the page

You can add HTML to the page by calling ui.add_head_html or ui.add_body_html .
This is useful for adding custom CSS styles or JavaScript code.


Coding example:
from nicegui import ui

ui.add_head_html('''
    <style>
        .my-red-label {
            color: Crimson;
            font-weight: bold;
        }
    </style>
''')
ui.label('RED').classes('my-red-label')

ui.run()


API Responses

This means you can use all of FastAPI's features.
For example, you can implement a RESTful API in addition to your graphical user interface.
You simply import the app object from nicegui .
Or you can run NiceGUI on top of your own FastAPI app by using ui.run_with(app) instead of starting a server automatically with ui.run() .
You can also return any other FastAPI response object inside a page function.
For example, you can return a RedirectResponse to redirect the user to another page if certain conditions are met.
This is used in our authentication demo .


Coding example:
import random
from nicegui import app, ui

@app.get('/random/{max}')
def generate_random_number(max: int):
    return {'min': 0, 'max': max, 'value': random.randint(0, max)}

max = ui.number('max', value=100)
ui.button('generate random number',
          on_click=lambda: ui.navigate.to(f'/random/{max.value:.0f}'))

ui.run()




____________________________________________________________
Section: 11. URL: http://localhost:8080/documentation/section_configuration_deployment

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Configuration & Deployment URLs ui.run Native Mode Environment Variables Server Hosting Package for Installation NiceGUI On Air


Configuration & Deployment


URLs

You can access the list of all URLs on which the NiceGUI app is available via app.urls .
The URLs are not available in app.on_startup because the server is not yet running.
Instead, you can access them in a page function or register a callback with app.urls.on_change .


Coding example:
from nicegui import app, ui

@ui.page('/')
def index():
    for url in app.urls:
        ui.link(url, target=url)

ui.run()


ui.run


You can call ui.run() with optional arguments.
Most of them only apply after stopping and fully restarting the app and do not apply with auto-reloading.

host: start server with this host (defaults to '127.0.0.1 in native mode, otherwise '0.0.0.0')
port: use this port (default: 8080 in normal mode, and an automatically determined open port in native mode)
title: page title (default: 'NiceGUI', can be overwritten per page)
viewport: page meta viewport content (default: 'width=device-width, initial-scale=1', can be overwritten per page)
favicon: relative filepath, absolute URL to a favicon (default: None, NiceGUI icon will be used) or emoji (e.g. '🚀', works for most browsers)
dark: whether to use Quasar's dark mode (default: False, use None for "auto" mode)
language: language for Quasar elements (default: 'en-US')
binding_refresh_interval:
 time between binding updates (default: 0.1 seconds, bigger is more CPU friendly)
reconnect_timeout:
 maximum time the server waits for the browser to reconnect (default: 3.0 seconds)
show: automatically open the UI in a browser tab (default: True)
on_air: tech preview: allows temporary remote access if set to True (default: disabled)
native: open the UI in a native window of size 800x600 (default: False, deactivates show, automatically finds an open port)
window_size: open the UI in a native window with the provided size (e.g. (1024, 786), default: None, also activates native)
fullscreen: open the UI in a fullscreen window (default: False, also activates native)
frameless: open the UI in a frameless window (default: False, also activates native)
reload: automatically reload the UI on file changes (default: True)
uvicorn_logging_level:
 logging level for uvicorn server (default: 'warning')
uvicorn_reload_dirs:
 string with comma-separated list for directories to be monitored (default is current working directory only)
uvicorn_reload_includes:
 string with comma-separated list of glob-patterns which trigger reload on modification (default: '*.py')
uvicorn_reload_excludes:
 string with comma-separated list of glob-patterns which should be ignored for reload (default: '.*, .py[cod], .sw.*, ~*')
tailwind: whether to use Tailwind (experimental, default: True)
prod_js: whether to use the production version of Vue and Quasar dependencies (default: True)
endpoint_documentation:
 control what endpoints appear in the autogenerated OpenAPI docs (default: 'none', options: 'none', 'internal', 'page', 'all')
storage_secret: secret key for browser-based storage (default: None, a value is required to enable ui.storage.individual and ui.storage.browser)
show_welcome_message:
 whether to show the welcome message (default: True)
kwargs: additional keyword arguments are passed to uvicorn.run


Coding example:
from nicegui import ui

ui.label('page with custom title')

ui.run(title='My App')


My App


Native Mode

You can enable native mode for NiceGUI by specifying native=True in the ui.run function.
To customize the initial window size and display mode, use the window_size and fullscreen parameters respectively.
Additionally, you can provide extra keyword arguments via app.native.window_args and app.native.start_args .
Pick any parameter as it is defined by the internally used pywebview module for the webview.create_window and webview.start functions.
Note that these keyword arguments will take precedence over the parameters defined in ui.run .
Additionally, you can change webview.settings via app.native.settings .
In native mode the app.native.main_window object allows you to access the underlying window.
It is an async version of Window from pywebview .


Coding example:
from nicegui import app, ui

app.native.window_args['resizable'] = False
app.native.start_args['debug'] = True
app.native.settings['ALLOW_DOWNLOADS'] = True

ui.label('app running in native mode')
ui.button('enlarge', on_click=lambda: app.native.main_window.resize(1000, 700))

ui.run(native=True, window_size=(400, 300), fullscreen=False)


If webview has trouble finding required libraries, you may get an error relating to "WebView2Loader.dll".
To work around this issue, try moving the DLL file up a directory, e.g.:
from .venv/Lib/site-packages/webview/lib/x64/WebView2Loader.dll
to .venv/Lib/site-packages/webview/lib/WebView2Loader.dll


Environment Variables

You can set the following environment variables to configure NiceGUI:
MATPLOTLIB (default: true) can be set to false to avoid the potentially costly import of Matplotlib.
This will make ui.pyplot and ui.line_plot unavailable.
NICEGUI_STORAGE_PATH (default: local ".nicegui") can be set to change the location of the storage files.
MARKDOWN_CONTENT_CACHE_SIZE (default: 1000): The maximum number of Markdown content snippets that are cached in memory.
RST_CONTENT_CACHE_SIZE (default: 1000): The maximum number of ReStructuredText content snippets that are cached in memory.


Coding example:
from nicegui import ui
from nicegui.elements import markdown

ui.label(f'Markdown content cache size is {markdown.prepare_content.cache_info().maxsize}')

ui.run()


Server Hosting

To deploy your NiceGUI app on a server, you will need to execute your main.py (or whichever file contains your ui.run(...) ) on your cloud infrastructure.
You can, for example, just install the NiceGUI python package via pip and use systemd or similar service to start the main script.
In most cases, you will set the port to 80 (or 443 if you want to use HTTPS) with the ui.run command to make it easily accessible from the outside.
A convenient alternative is the use of our pre-built multi-arch Docker image which contains all necessary dependencies.
With this command you can launch the script main.py in the current directory on the public port 80:


bash


Coding example:
docker run -it --restart always \
-p 80:8080 \
-e PUID=$(id -u) \
-e PGID=$(id -g) \
-v $(pwd)/:/app/ \
zauberzeug/nicegui:latest


The demo assumes main.py uses the port 8080 in the ui.run command (which is the default).
The -d tells docker to run in background and --restart always makes sure the container is restarted if the app crashes or the server reboots.
Of course this can also be written in a Docker compose file:


docker-compose.yml


Coding example:
app:
    image: zauberzeug/nicegui:latest
    restart: always
    ports:
        - 80:8080
    environment:
        - PUID=1000 # change this to your user id
        - PGID=1000 # change this to your group id
    volumes:
        - ./:/app/


There are other handy features in the Docker image like non-root user execution and signal pass-through.
For more details we recommend to have a look at our Docker example .
To serve your application with HTTPS encryption, you can provide SSL certificates in multiple ways.
For instance, you can directly provide your certificates to Uvicorn , which NiceGUI is based on, by passing the
relevant options to ui.run() :


Coding example:
from nicegui import ui

ui.run(
    port=443,
    ssl_certfile="<path_to_certfile>",
    ssl_keyfile="<path_to_keyfile>",
)


In production we also like using reverse proxies like Traefik or NGINX to handle these details for us.
See our development docker-compose.yml as an example based on traefik or this example nginx.conf file showing how NGINX can be used to handle the SSL certificates and
reverse proxy to your NiceGUI app.
You may also have a look at our demo for using a custom FastAPI app .
This will allow you to do very flexible deployments as described in the FastAPI documentation .
Note that there are additional steps required to allow multiple workers.


Package for Installation

This allows you to distribute your app as a single file that can be executed on any computer.
Just make sure to call ui.run with reload=False in your main script to disable the auto-reload feature.
Running the nicegui-pack command below will create an executable myapp in the dist folder:


Coding example:
from nicegui import native, ui

ui.label('Hello from PyInstaller')

ui.run(reload=False, port=native.find_open_port())


bash


Coding example:
nicegui-pack --onefile --name "myapp" main.py


Packaging Tips:

When building a PyInstaller app, your main script can use a native window (rather than a browser window) by
using ui.run(reload=False, native=True) .
The native parameter can be True or False depending on whether you want a native window or to launch a
page in the user's browser - either will work in the PyInstaller generated app.

Specifying --windowed to nicegui-pack will prevent a terminal console from appearing.
However you should only use this option if you have also specified native=True in your ui.run command.
Without a terminal console the user won't be able to exit the app by pressing Ctrl-C.
With the native=True option, the app will automatically close when the window is closed, as expected.

Specifying --windowed to nicegui-pack will create an .app file on Mac which may be more convenient to distribute.
When you double-click the app to run it, it will not show any console output.
You can also run the app from the command line with ./myapp.app/Contents/MacOS/myapp to see the console output.

Specifying --onefile to nicegui-pack will create a single executable file.
Whilst convenient for distribution, it will be slower to start up.
This is not NiceGUI's fault but just the way Pyinstaller zips things into a single file, then unzips everything
into a temporary directory before running.
You can mitigate this by removing --onefile from the nicegui-pack command,
and zip up the generated dist directory yourself, distribute it,
and your end users can unzip once and be good to go,
without the constant expansion of files due to the --onefile flag.

Summary of user experience for different options:

nicegui-pack ui.run(...) Explanation
onefile native=False Single executable generated in dist/, runs in browser
onefile native=True Single executable generated in dist/, runs in popup window
onefile and windowed native=True Single executable generated in dist/ (on Mac a proper dist/myapp.app generated incl. icon), runs in popup window, no console appears
onefile and windowed native=False Avoid (no way to exit the app)
Specify neither  A dist/myapp directory created which can be zipped manually and distributed; run with dist/myapp/myapp

If you are using a Python virtual environment, ensure you pip install pyinstaller within your virtual environment
so that the correct PyInstaller is used, or you may get broken apps due to the wrong version of PyInstaller being picked up.
That is why the nicegui-pack invokes PyInstaller using python -m PyInstaller rather than just pyinstaller .


bash


Coding example:
python -m venv venv
source venv/bin/activate
pip install nicegui
pip install pyinstaller


Note:
If you're getting an error "TypeError: a bytes-like object is required, not 'str'", try adding the following lines to the top of your main.py file:
Coding example:
import sys
sys.stdout = open('logs.txt', 'w')

See https://github.com/zauberzeug/nicegui/issues/681 for more information.

macOS Packaging
Add the following snippet before anything else in your main app's file, to prevent new processes from being spawned in an endless loop:
Coding example:
# macOS packaging support
from multiprocessing import freeze_support  # noqa
freeze_support()  # noqa

# all your other imports and code

The # noqa comment instructs Pylance or autopep8 to not apply any PEP rule on those two lines, guaranteeing they remain on top of anything else.
This is key to prevent process spawning.


By using ui.run(on_air=True) you can share your local app with others over the internet 🧞.
When accessing the on-air URL, all libraries (like Vue, Quasar, ...) are loaded from our CDN.
Thereby only the raw content and events need to be transmitted by your local app.
This makes it blazing fast even if your app only has a poor internet connection (e.g. a mobile robot in the field).
By setting on_air=True you will get a random URL which is valid for 1 hour.
If you sign-up at https://on-air.nicegui.io , you can setup an organization and device name to get a fixed URL: https://on-air.nicegui.io/<my-org>/<my_device_name> .
The device is then identified by a unique, private token which you can use instead of a boolean flag: ui.run(on_air='<your token>') .
If you sponsor us ,
we will enable multi-device management and provide built-in passphrase protection for each device.
Currently On Air is available as a tech preview and can be used free of charge.
We will gradually improve stability and extend the service with usage statistics, remote terminal access and more.
Please let us know your feedback on GitHub , Reddit , or Discord .
Data Privacy: We take your privacy very serious.




____________________________________________________________
Section: 12. URL: http://localhost:8080/documentation/section_testing

menu
Installation Features Demos Documentation Examples Why? search


← Overview

Testing Project Structure User Fixture Screen Fixture


Testing


Project Structure

The NiceGUI package provides a pytest plugin which can be activated via pytest_plugins = ['nicegui.testing.plugin'] .
This makes specialized fixtures available for testing your NiceGUI user interface.
With the screen fixture you can run the tests through a headless browser (slow)
and with the user fixture fully simulated in Python (fast).
There are a multitude of ways to structure your project and tests.
Here we only present two approaches which we found useful,
one for small apps and experiments and a modular one for larger projects .
You can find more information in the pytest documentation .


User Fixture

We recommend utilizing the user fixture instead of the screen fixture wherever possible
because execution is as fast as unit tests and it does not need Selenium as a dependency.
The user fixture cuts away the browser and replaces it by a lightweight simulation entirely in Python.
You can assert to "see" specific elements or content, click buttons, type into inputs and trigger events.
We aimed for a nice API to write acceptance tests which read like a story and are easy to understand.
Due to the fast execution, the classical test pyramid ,
where UI tests are considered slow and expensive, does not apply anymore.


example


Coding example:
await user.open('/')
user.find('Username').type('user1')
user.find('Password').type('pass1').trigger('keydown.enter')
await user.should_see('Hello user1!')
user.find('logout').click()
await user.should_see('Log in')


NOTE: The user fixture is quite new and still misses some features.
Please let us know in separate feature requests over on GitHub .


Screen Fixture

The screen fixture starts a real (headless) browser to interact with your application.
This is only necessary if you have browser-specific behavior to test.
So only use it if you have to.


example


Coding example:
from selenium.webdriver.common.keys import Keys

screen.open('/')
screen.type(Keys.TAB) # to focus on the first input
screen.type('user1')
screen.type(Keys.TAB) # to focus the second input
screen.type('pass1')
screen.click('Log in')
screen.should_contain('Hello user1!')
screen.click('logout')
screen.should_contain('Log in')




____________________________________________________________
Section: 13. URL: http://localhost:8080/documentation/label

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.label Label Change Appearance Depending on the Content Reference Properties Methods Inheritance


ui. label


Label


Displays some text.

text: the content of the label


Coding example:
from nicegui import ui

ui.label('some label')

ui.run()


Change Appearance Depending on the Content

You can overwrite the _handle_text_change method to update other attributes of a label depending on its content.
This technique also works for bindings as shown in the example below.


Coding example:
from nicegui import ui

class status_label(ui.label):
    def _handle_text_change(self, text: str) -> None:
        super()._handle_text_change(text)
        if text == 'ok':
            self.classes(replace='text-positive')
        else:
            self.classes(replace='text-negative')

model = {'status': 'error'}
status_label().bind_text_from(model, 'status')
ui.switch(on_change=lambda e: model.update(status='ok' if e.value else 'error'))

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

text : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
Element
Visibility




____________________________________________________________
Section: 14. URL: http://localhost:8080/documentation/link

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.link Link Navigate on large pages Links to other pages Link from images and other elements Reference Properties Methods Inheritance


ui.


Link


Create a hyperlink.
To jump to a specific location within a page you can place linkable anchors with ui.link_target("name") and link to it with ui.link(target="#name") .

text: display text
target: page function, NiceGUI element on the same page or string that is a an absolute URL or relative path from base URL
new_tab: open link in new tab (default: False)


Coding example:
from nicegui import ui

ui.link('NiceGUI on GitHub', 'https://github.com/zauberzeug/nicegui')

ui.run()


Navigate on large pages

To jump to a specific location within a page you can place linkable anchors with ui.link_target('target_name') or simply pass a NiceGUI element as link target.


Coding example:
from nicegui import ui

navigation = ui.row()
ui.link_target('target_A')
ui.label(
    'Lorem ipsum dolor sit amet, consectetur adipiscing elit, '
    'sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.'
)
label_B = ui.label(
    'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. '
    'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. '
    'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'
)
with navigation:
    ui.link('Goto A', '#target_A')
    ui.link('Goto B', label_B)

ui.run()


Links to other pages

You can link to other pages by providing the link target as path or function reference.


Coding example:
from nicegui import ui

@ui.page('/some_other_page')
def my_page():
    ui.label('This is another page')

ui.label('Go to other page')
ui.link('... with path', '/some_other_page')
ui.link('... with function reference', my_page)

ui.run()


Link from images and other elements

By nesting elements inside a link you can make the whole element clickable.
This works with all elements but is most useful for non-interactive elements like ui.image , ui.avatar etc.


Coding example:
from nicegui import ui

with ui.link(target='https://github.com/zauberzeug/nicegui'):
    ui.image('https://picsum.photos/id/41/640/360').classes('w-64')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

text : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
Element
Visibility




____________________________________________________________
Section: 15. URL: http://localhost:8080/documentation/chat_message

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.chat_message Chat Message HTML text Newline Multi-part messages Chat message with child elements Reference Properties Methods Inheritance


ui. chat_message


Chat Message


Based on Quasar's Chat Message component.

text: the message body (can be a list of strings for multiple message parts)
name: the name of the message author
label: renders a label header/section only
stamp: timestamp of the message
avatar: URL to an avatar
sent: render as a sent message (so from current user) (default: False)
text_html: render text as HTML (default: False)


Coding example:
from nicegui import ui

ui.chat_message('Hello NiceGUI!',
                name='Robot',
                stamp='now',
                avatar='https://robohash.org/ui')

ui.run()


HTML text

Using the text_html parameter, you can send HTML text to the chat.


Coding example:
from nicegui import ui

ui.chat_message('Without <strong>HTML</strong>')
ui.chat_message('With <strong>HTML</strong>', text_html=True)

ui.run()


Newline

You can use newlines in the chat message.


Coding example:
from nicegui import ui

ui.chat_message('This is a\nlong line!')

ui.run()


Multi-part messages

You can send multiple message parts by passing a list of strings.


Coding example:
from nicegui import ui

ui.chat_message(['Hi! 😀', 'How are you?']
                )

ui.run()


Chat message with child elements

You can add child elements to a chat message.


Coding example:
from nicegui import ui

with ui.chat_message():
    ui.label('Guess where I am!')
    ui.image('https://picsum.photos/id/249/640/360').classes('w-64')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 16. URL: http://localhost:8080/documentation/element

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.element Generic Element Move elements Move elements to slots Default props Default classes Default style Reference Properties Methods Inheritance


ui. element


Generic Element


This class is the base class for all other UI elements.
But you can use it to create elements with arbitrary HTML tags.

tag: HTML tag of the element
_client: client for this element (for internal use only)


Coding example:
from nicegui import ui

with ui.element('div').classes('p-2 bg-blue-100'):
    ui.label('inside a colored div')

ui.run()


Move elements

This demo shows how to move elements between or within containers.


Coding example:
from nicegui import ui

with ui.card() as a:
    ui.label('A')
    x = ui.label('X')

with ui.card() as b:
    ui.label('B')

ui.button('Move X to A', on_click=lambda: x.move(a))
ui.button('Move X to B', on_click=lambda: x.move(b))
ui.button('Move X to top', on_click=lambda: x.move(target_index=0))

ui.run()


Move elements to slots

This demo shows how to move elements between slots within an element.


Coding example:
from nicegui import ui

with ui.card() as card:
    name = ui.input('Name', value='Paul')
    name.add_slot('append')
    icon = ui.icon('face')

ui.button('Move into input', on_click=lambda: icon.move(name, target_slot='append'))
ui.button('Move out of input', on_click=lambda: icon.move(card))

ui.run()


Default props

You can set default props for all elements of a certain class.
This way you can avoid repeating the same props over and over again.
Default props only apply to elements created after the default props were set.
Subclasses inherit the default props of their parent class.


Coding example:
from nicegui import ui

ui.button.default_props('rounded outline')
ui.button('Button A')
ui.button('Button B')

ui.run()


Default classes

You can set default classes for all elements of a certain class.
This way you can avoid repeating the same classes over and over again.
Default classes only apply to elements created after the default classes were set.
Subclasses inherit the default classes of their parent class.


Coding example:
from nicegui import ui

ui.label.default_classes('bg-blue-100 p-2')
ui.label('Label A')
ui.label('Label B')

ui.run()


Default style

You can set a default style for all elements of a certain class.
This way you can avoid repeating the same style over and over again.
A default style only applies to elements created after the default style was set.
Subclasses inherit the default style of their parent class.


Coding example:
from nicegui import ui

ui.label.default_style('color: tomato')
ui.label('Label A')
ui.label('Label B')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

@classmethod default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

@classmethod default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

@classmethod default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Visibility




____________________________________________________________
Section: 17. URL: http://localhost:8080/documentation/markdown

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.markdown Markdown Element Markdown with indentation Markdown with code blocks Markdown tables Change Markdown content Reference Properties Methods Inheritance


ui. markdown


Markdown Element


Renders Markdown onto the page.

content: the Markdown content to be displayed
extras: list of markdown2 extensions (default: ['fenced-code-blocks', 'tables'])


Coding example:
from nicegui import ui

ui.markdown('This is **Markdown**.')

ui.run()


Markdown with indentation

Common indentation is automatically stripped from the beginning of each line.
So you can indent markdown elements, and they will still be rendered correctly.


Coding example:
from nicegui import ui

ui.markdown('''
    ## Example

    This line is not indented.

        This block is indented.
        Thus it is rendered as source code.

    This is normal text again.
''')

ui.run()


Markdown with code blocks

You can use code blocks to show code examples.
If you specify the language after the opening triple backticks, the code will be syntax highlighted.
See the Pygments website for a list of supported languages.


Coding example:
from nicegui import ui

ui.markdown('''
    ```python
    from nicegui import ui

    ui.label('Hello World!')

    ui.run(dark=True)
    ```
''')

ui.run()


Markdown tables

By activating the "tables" extra, you can use Markdown tables.
See the markdown2 documentation for a list of available extras.


Coding example:
from nicegui import ui

ui.markdown('''
    | First name | Last name |
    | ---------- | --------- |
    | Max        | Planck    |
    | Marie      | Curie     |
''', extras=['tables'])

ui.run()


Change Markdown content

You can change the content of a Markdown element by setting its content property or calling set_content .


Coding example:
from nicegui import ui

markdown = ui.markdown('Sample content')
ui.button('Change Content', on_click=lambda: markdown.set_content('This is new content'))

ui.run()


Reference


Properties


content : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_content (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_content_from (target_object: Any, target_name: str = 'content', backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_content_to (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_content (content: str) -> None


Set the content of this element.

param content: The new content.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ContentElement
Element
Visibility




____________________________________________________________
Section: 18. URL: http://localhost:8080/documentation/restructured_text

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.restructured_text ReStructuredText reStructuredText with indentation reStructuredText with code blocks reStructuredText with tables Reference Properties Methods Inheritance


ui. restructured_text


ReStructuredText


Renders ReStructuredText onto the page.

content: the ReStructuredText content to be displayed


Coding example:
from nicegui import ui

ui.restructured_text('This is **reStructuredText**.')

ui.run()


reStructuredText with indentation

You can indent reStructuredText elements to create a hierarchy.
Common indentation is automatically stripped from the beginning of each line to preserve the relative indentation,
so you can indent multiline strings.


Coding example:
from nicegui import ui

ui.restructured_text('''
    This is an example of a reStructuredText paragraph with several indentation levels.

    You can use multiple levels of indentation to structure your content.
    Each level of indentation represents a different level of hierarchy.

    - Level 1
        - Level 2
            - Level 3
                - Level 4
                    - Level 5
''')

ui.run()


reStructuredText with code blocks

You can use code blocks to show code examples.
If you specify the language, the code will be syntax-highlighted.
See this link for a list of supported languages.


Coding example:
from nicegui import ui

ui.restructured_text('''
    .. code-block:: python3

        from nicegui import ui

        ui.label('Hello World!')

        ui.run()
''')

ui.run()


reStructuredText with tables

See the sphinx documentation for more information about reStructuredText tables.


Coding example:
from nicegui import ui

ui.restructured_text('''
    +-------+-------+---------+--------+
    | A     | B     | A and B | A or B |
    +=======+=======+=========+========+
    | False | False | False   | False  |
    +-------+-------+---------+--------+
    | True  | False | False   | True   |
    +-------+-------+---------+--------+
    | False | True  | False   | True   |
    +-------+-------+---------+--------+
    | True  | True  | True    | True   |
    +-------+-------+---------+--------+
''')

ui.run()


Reference


Properties


content : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_content (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_content_from (target_object: Any, target_name: str = 'content', backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_content_to (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_content (content: str) -> None


Set the content of this element.

param content: The new content.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Markdown
ContentElement
Element
Visibility




____________________________________________________________
Section: 19. URL: http://localhost:8080/documentation/mermaid

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.mermaid Mermaid Diagrams Handle click events Handle errors Reference Properties Methods Inheritance


ui. mermaid


Mermaid Diagrams


Renders diagrams and charts written in the Markdown-inspired Mermaid language.
The mermaid syntax can also be used inside Markdown elements by providing the extension string 'mermaid' to the ui.markdown element.
The optional configuration dictionary is passed directly to mermaid before the first diagram is rendered.
This can be used to set such options as {'securityLevel': 'loose', ...} - allow running JavaScript when a node is clicked {'logLevel': 'info', ...} - log debug info to the console
Refer to the Mermaid documentation for the mermaid.initialize() method for a full list of options.

content: the Mermaid content to be displayed
config: configuration dictionary to be passed to mermaid.initialize()


Coding example:
from nicegui import ui

ui.mermaid('''
graph LR;
    A --> B;
    A --> C;
''')

ui.run()


Handle click events

You can register to click events by adding a click directive to a node and emitting a custom event.
Make sure to set the securityLevel to loose in the config parameter to allow JavaScript execution.


Coding example:
from nicegui import ui

ui.mermaid('''
graph LR;
    A((Click me!));
    click A call emitEvent("mermaid_click", "You clicked me!")
''', config={'securityLevel': 'loose'})
ui.on('mermaid_click', lambda e: ui.notify(e.args))

ui.run()


Handle errors

You can handle errors by listening to the error event.
The event args contain the properties hash , message , str and an error object with additional information.


Coding example:
from nicegui import ui

ui.mermaid('''
graph LR;
    A --> B;
    A -> C;
''').on('error', lambda e: print(e.args['message']))

ui.run()


Reference


Properties


content : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_content (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_content_from (target_object: Any, target_name: str = 'content', backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_content_to (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_content (content: str) -> None


Set the content of this element.

param content: The new content.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ContentElement
Element
Visibility




____________________________________________________________
Section: 20. URL: http://localhost:8080/documentation/html

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.html HTML Element Producing in-line elements Reference Properties Methods Inheritance


ui. html


HTML Element


Renders arbitrary HTML onto the page, wrapped in the specified tag. Tailwind can be used for styling.
You can also use ui.add_head_html to add html code into the head of the document and ui.add_body_html to add it into the body.

content: the HTML code to be displayed
tag: the HTML tag to wrap the content in (default: "div")


Coding example:
from nicegui import ui

ui.html('This is <strong>HTML</strong>.')

ui.run()


Producing in-line elements

Use the tag parameter to produce something other than a div.


Coding example:
from nicegui import ui

ui.html('This is <u>emphasized</u>.', tag='em')

ui.run()


Reference


Properties


content : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_content (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_content_from (target_object: Any, target_name: str = 'content', backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_content_to (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_content (content: str) -> None


Set the content of this element.

param content: The new content.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ContentElement
Element
Visibility




____________________________________________________________
Section: 21. URL: http://localhost:8080/documentation/element_filter

menu
Installation Features Demos Documentation Examples Why? search


← back

ElementFilter ElementFilter Find all elements with text property Markers Reference Methods


ElementFilter


ElementFilter


Sometimes it is handy to search the Python element tree of the current page. ElementFilter() allows powerful filtering by kind of elements, markers and content.
It also provides a fluent interface to apply more filters like excluding elements or filtering for elements within a specific parent.
The filter can be used as an iterator to iterate over the found elements and is always applied while iterating and not when being instantiated.
And element is yielded if it matches all of the following conditions:
The element is of the specified kind (if specified).
The element is none of the excluded kinds.
The element has all of the specified markers.
The element has none of the excluded markers.
The element contains all of the specified content.
The element contains none of the excluded content.
Its ancestors include all of the specified instances defined via within .
Its ancestors include none of the specified instances defined via not_within .
Its ancestors include all of the specified kinds defined via within .
Its ancestors include none of the specified kinds defined via not_within .
Its ancestors include all of the specified markers defined via within .
Its ancestors include none of the specified markers defined via not_within .
Element "content" includes its text, label, icon, placeholder, value, message, content, source.
Partial matches like "Hello" in "Hello World!" are sufficient for content filtering.

kind: filter by element type; the iterator will be of type kind
marker: filter by element markers; can be a list of strings or a single string where markers are separated by whitespace
content: filter for elements which contain content in one of their content attributes like .text, .value, .source, ...; can be a singe string or a list of strings which all must match
local_scope: if True, only elements within the current scope are returned; by default the whole page is searched (this default behavior can be changed with ElementFilter.DEFAULT_LOCAL_SCOPE = True)


Coding example:
from nicegui import ElementFilter, ui

with ui.card():
    ui.button('button A')
    ui.label('label A')

with ui.card().mark('important'):
    ui.button('button B')
    ui.label('label B')

ElementFilter(kind=ui.label).within(marker='important').classes('text-xl')

ui.run()


Find all elements with text property

The text property is provided by a mixin called TextElement .
If we filter by such a mixin, the ElementFilter itself will provide a typed iterable.


Coding example:
from nicegui import ElementFilter, ui
from nicegui.elements.mixins.text_element import TextElement

with ui.card():
    ui.button('button')
    ui.icon('home')
    ui.label('label A')
    ui.label('label B')
    ui.html('HTML')

ui.label(', '.join(b.text for b in ElementFilter(kind=TextElement)))

ui.run()


Markers

Markers are a simple way to tag elements with a string which can be queried by an ElementFilter .


Coding example:
from nicegui import ElementFilter, ui

with ui.card().mark('red'):
    ui.label('label A')
with ui.card().mark('strong'):
    ui.label('label B')
with ui.card().mark('red strong'):
    ui.label('label C')

ElementFilter(marker='red').classes('bg-red-200')
ElementFilter(marker='strong').classes('text-bold')
ElementFilter(marker='red strong').classes('bg-red-600 text-white')

ui.run()


Reference


Methods


classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

exclude (kind: Optional[Type[Element]] = None, marker: Optional[str] = None, content: Optional[str] = None) -> Self


Exclude elements with specific element type, marker or content.

not_within (kind: Optional[Type[Element]] = None, marker: Optional[str] = None, instance: Union[Element, List[Element], None] = None) -> Self


Exclude elements which have a parent of a specific type or marker.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

within (kind: Optional[Type[Element]] = None, marker: Optional[str] = None, instance: Union[Element, List[Element], None] = None) -> Self


Filter elements which have a specific match in the parent hierarchy.




____________________________________________________________
Section: 22. URL: http://localhost:8080/documentation/image

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.image Image Local files Base64 string PIL image Lottie files Image link Force reload Reference Properties Methods Inheritance


ui. image


Image


Displays an image.
This element is based on Quasar's QImg component.

source: the source of the image; can be a URL, local file path, a base64 string or a PIL image


Coding example:
from nicegui import ui

ui.image('https://picsum.photos/id/377/640/360')

ui.run()


Local files

You can use local images as well by passing a path to the image file.


Coding example:
from nicegui import ui

ui.image('website/static/logo.png').classes('w-16')

ui.run()


Base64 string

You can also use a Base64 string as image source.


Coding example:
from nicegui import ui

base64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='
ui.image(base64).classes('w-2 h-2 m-auto')

ui.run()


PIL image

You can also use a PIL image as image source.


Coding example:
import numpy as np
from nicegui import ui
from PIL import Image

image = Image.fromarray(np.random.randint(0, 255, (100, 100), dtype=np.uint8))
ui.image(image).classes('w-32')

ui.run()


Lottie files

You can also use Lottie files with animations.


Coding example:
from nicegui import ui

ui.add_body_html('<script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>')

src = 'https://assets1.lottiefiles.com/datafiles/HN7OcWNnoqje6iXIiZdWzKxvLIbfeCGTmvXmEm1h/data.json'
ui.html(f'<lottie-player src="{src}" loop autoplay />').classes('w-full')

ui.run()


Image link

Images can link to another page by wrapping them in a ui.link .


Coding example:
from nicegui import ui

with ui.link(target='https://github.com/zauberzeug/nicegui'):
    ui.image('https://picsum.photos/id/41/640/360').classes('w-64')

ui.run()


Force reload

You can force an image to reload by calling the force_reload method.
It will append a timestamp to the image URL, which will make the browser reload the image.


Coding example:
from nicegui import ui

img = ui.image('https://picsum.photos/640/360').classes('w-64')

ui.button('Force reload', on_click=img.force_reload)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

source : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_source (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_source_from (target_object: Any, target_name: str = 'source', backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_source_to (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

force_reload () -> None


Force the image to reload from the source.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_source (source: Union[str, pathlib.Path, ForwardRef('PIL_Image')]) -> None

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

SourceElement
Element
Visibility




____________________________________________________________
Section: 23. URL: http://localhost:8080/documentation/button

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.button Button Icons Await button click Disable button with a context manager Custom toggle button Floating Action Button Expandable Floating Action Button Reference Properties Methods Inheritance


ui. button


Button


This element is based on Quasar's QBtn component.
The color parameter accepts a Quasar color, a Tailwind color, or a CSS color.
If a Quasar color is used, the button will be styled according to the Quasar theme including the color of the text.
Note that there are colors like "red" being both a Quasar color and a CSS color.
In such cases the Quasar color will be used.

text: the label of the button
on_click: callback which is invoked when button is pressed
color: the color of the button (either a Quasar, Tailwind, or CSS color or None, default: 'primary')
icon: the name of an icon to be displayed on the button (default: None)


Coding example:
from nicegui import ui

ui.button('Click me!', on_click=lambda: ui.notify('You clicked me!'))

ui.run()


Icons

You can also add an icon to a button.


Coding example:
from nicegui import ui

with ui.row():
    ui.button('demo', icon='history')
    ui.button(icon='thumb_up')
    with ui.button():
        ui.label('sub-elements')
        ui.image('https://picsum.photos/id/377/640/360') \
            .classes('rounded-full w-16 h-16 ml-4')

ui.run()


Await button click

Sometimes it is convenient to wait for a button click before continuing the execution.


Coding example:
from nicegui import ui

@ui.page('/')
async def index():
    b = ui.button('Step')
    await b.clicked()
    ui.label('One')
    await b.clicked()
    ui.label('Two')
    await b.clicked()
    ui.label('Three')

ui.run()


Disable button with a context manager

This showcases a context manager that can be used to disable a button for the duration of an async process.


Coding example:
import httpx
from contextlib import contextmanager
from nicegui import ui

@contextmanager
def disable(button: ui.button):
    button.disable()
    try:
        yield
    finally:
        button.enable()

async def get_slow_response(button: ui.button) -> None:
    with disable(button):
        async with httpx.AsyncClient() as client:
            response = await client.get('https://httpbin.org/delay/1', timeout=5)
            ui.notify(f'Response code: {response.status_code}')

ui.button('Get slow response', on_click=lambda e: get_slow_response(e.sender))

ui.run()


Custom toggle button

As with all other elements, you can implement your own subclass with specialized logic.
Like this red/green toggle button with an internal boolean state.


Coding example:
from nicegui import ui

class ToggleButton(ui.button):

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._state = False
        self.on('click', self.toggle)

    def toggle(self) -> None:
        """Toggle the button state."""
        self._state = not self._state
        self.update()

    def update(self) -> None:
        self.props(f'color={"green" if self._state else "red"}')
        super().update()

ToggleButton('Toggle me')

ui.run()


Floating Action Button

As described in the Quasar documentation ,
a Floating Action Button (FAB) is simply a "page-sticky" with a button inside.
With the "fab" prop, the button will be rounded and gets a shadow.
Color can be freely chosen, but most often it is an accent color.


Coding example:
from nicegui import ui

ui.colors(accent='#6AD4DD')
with ui.page_sticky(x_offset=18, y_offset=18):
    ui.button(icon='home', on_click=lambda: ui.notify('home')) \
        .props('fab color=accent')

ui.run()


Expandable Floating Action Button

The Quasar FAB (q-fab) ,
is a button that reveals multiple actions when clicked.
While it is not a separate element in NiceGUI, it can be easily created using the generic ui.element .


Coding example:
from nicegui import ui

with ui.element('q-fab').props('icon=navigation color=green'):
    ui.element('q-fab-action').props('icon=train color=green-5') \
        .on('click', lambda: ui.notify('train'))
    ui.element('q-fab-action').props('icon=sailing color=green-5') \
        .on('click', lambda: ui.notify('boat'))
    ui.element('q-fab-action').props('icon=rocket color=green-5') \
        .on('click', lambda: ui.notify('rocket'))

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

text : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

clicked () -> None


Wait until the button is clicked.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_click (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the button is clicked.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
DisableableElement
BackgroundColorElement
Element
Visibility




____________________________________________________________
Section: 24. URL: http://localhost:8080/documentation/button_group

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.button_group Button Group Button group with dropdown button Button group styling Reference Properties Methods Inheritance


ui. button_group


Button Group


This element is based on Quasar's QBtnGroup component.
You must use the same design props on both the parent button group and the children buttons.


Coding example:
from nicegui import ui

with ui.button_group():
    ui.button('One', on_click=lambda: ui.notify('You clicked Button 1!'))
    ui.button('Two', on_click=lambda: ui.notify('You clicked Button 2!'))
    ui.button('Three', on_click=lambda: ui.notify('You clicked Button 3!'))

ui.run()


Button group with dropdown button

You can also add a dropdown button to a button group.


Coding example:
from nicegui import ui

with ui.button_group():
    ui.button('One')
    ui.button('Two')
    with ui.dropdown_button('Dropdown'):
        ui.item('Item 1', on_click=lambda: ui.notify('Item 1'))
        ui.item('Item 2', on_click=lambda: ui.notify('Item 2'))

ui.run()


Button group styling

You can apply the same styling options to a button group as to a button, like "flat", "outline", "push", ...
However, you must always use the same design props for the button group and its containing buttons.


Coding example:
from nicegui import ui

with ui.button_group().props('rounded'):
    ui.button('One')
    ui.button('Two')
    ui.button('Three')
with ui.button_group().props('push glossy'):
    ui.button('One', color='red').props('push')
    ui.button('Two', color='orange').props('push text-color=black')
    ui.button('Three', color='yellow').props('push text-color=black')
with ui.button_group().props('outline'):
    ui.button('One').props('outline')
    ui.button('Two').props('outline')
    ui.button('Three').props('outline')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 25. URL: http://localhost:8080/documentation/button_dropdown

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.dropdown_button Dropdown Button Custom elements inside dropdown button Reference Properties Methods Inheritance


ui. dropdown_button


Dropdown Button


This element is based on Quasar's QBtnDropDown component.
The color parameter accepts a Quasar color, a Tailwind color, or a CSS color.
If a Quasar color is used, the button will be styled according to the Quasar theme including the color of the text.
Note that there are colors like "red" being both a Quasar color and a CSS color.
In such cases the Quasar color will be used.

text: the label of the button
value: if the dropdown is open or not (default: False)
on_value_change:
 callback which is invoked when the dropdown is opened or closed
on_click: callback which is invoked when button is pressed
color: the color of the button (either a Quasar, Tailwind, or CSS color or None, default: 'primary')
icon: the name of an icon to be displayed on the button (default: None)
auto_close: whether the dropdown should close automatically when an item is clicked (default: False)
split: whether to split the dropdown icon into a separate button (default: False)


Coding example:
from nicegui import ui

with ui.dropdown_button('Open me!', auto_close=True):
    ui.item('Item 1', on_click=lambda: ui.notify('You clicked item 1'))
    ui.item('Item 2', on_click=lambda: ui.notify('You clicked item 2'))

ui.run()


Custom elements inside dropdown button

You can put any elements inside a dropdown button.
Here is a demo with a few switches.


Coding example:
from nicegui import ui

with ui.dropdown_button('Settings', icon='settings', split=True):
    with ui.row().classes('p-4 items-center'):
        ui.icon('volume_up', size='sm')
        ui.switch().props('color=negative')
        ui.separator().props('vertical')
        ui.icon('mic', size='sm')
        ui.switch().props('color=negative')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

text : BindableProperty

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

close () -> None


Close the dropdown.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

open () -> None


Open the dropdown.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle () -> None


Toggle the dropdown.

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
DisableableElement
BackgroundColorElement
ValueElement
Element
Visibility




____________________________________________________________
Section: 26. URL: http://localhost:8080/documentation/badge

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.badge Badge Reference Properties Methods Inheritance


ui. badge


Badge


A badge element wrapping Quasar's QBadge component.

text: the initial value of the text field
color: the color name for component (either a Quasar, Tailwind, or CSS color or None, default: "primary")
text_color: text color (either a Quasar, Tailwind, or CSS color or None, default: None)
outline: use 'outline' design (colored text and borders only) (default: False)


Coding example:
from nicegui import ui

with ui.button('Click me!', on_click=lambda: badge.set_text(int(badge.text) + 1)):
    badge = ui.badge('0', color='red').props('floating')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

text : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
BackgroundColorElement
TextColorElement
Element
Visibility




____________________________________________________________
Section: 27. URL: http://localhost:8080/documentation/chip

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.chip Chip Dynamic chip elements as labels/tags Reference Properties Methods Inheritance


ui. chip


Chip


A chip element wrapping Quasar's QChip component.
It can be clickable, selectable and removable.

text: the initial value of the text field (default: "")
icon: the name of an icon to be displayed on the chip (default: None)
color: the color name for component (either a Quasar, Tailwind, or CSS color or None, default: "primary")
text_color: text color (either a Quasar, Tailwind, or CSS color or None, default: None)
on_click: callback which is invoked when chip is clicked. Makes the chip clickable if set
selectable: whether the chip is selectable (default: False)
selected: whether the chip is selected (default: False)
on_selection_change:
 callback which is invoked when the chip's selection state is changed
removable: whether the chip is removable. Shows a small "x" button if True (default: False)
on_value_change:
 callback which is invoked when the chip is removed or unremoved


Coding example:
from nicegui import ui

with ui.row().classes('gap-1'):
    ui.chip('Click me', icon='ads_click', on_click=lambda: ui.notify('Clicked'))
    ui.chip('Selectable', selectable=True, icon='bookmark', color='orange')
    ui.chip('Removable', removable=True, icon='label', color='indigo-3')
    ui.chip('Styled', icon='star', color='green').props('outline square')
    ui.chip('Disabled', icon='block', color='red').set_enabled(False)

ui.run()


Dynamic chip elements as labels/tags

This demo shows how to implement a dynamic list of chips as labels or tags.
You can add new chips by typing a label and pressing Enter or pressing the plus button.
Removed chips still exist, but their value is set to False .


Coding example:
from nicegui import ui

def add_chip():
    with chips:
        ui.chip(label_input.value, icon='label', color='silver', removable=True)
    label_input.value = ''

label_input = ui.input('Add label').on('keydown.enter', add_chip)
with label_input.add_slot('append'):
    ui.button(icon='add', on_click=add_chip).props('round dense flat')

with ui.row().classes('gap-0') as chips:
    ui.chip('Label 1', icon='label', color='silver', removable=True)

ui.button('Restore removed chips', icon='unarchive',
          on_click=lambda: [chip.set_value(True) for chip in chips]) \
    .props('flat')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

selected : BindableProperty

text : BindableProperty

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_selected (target_object: Any, target_name: str = 'selected', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the selection state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_selected_from (target_object: Any, target_name: str = 'selected', backward: Callable[..., Any] = [...]) -> Self


Bind the selection state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_selected_to (target_object: Any, target_name: str = 'selected', forward: Callable[..., Any] = [...]) -> Self


Bind the selection state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_click (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the chip is clicked.

on_selection_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the selection state changes.

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_selected (selected: bool) -> None


Set the selection state of this element.

param selected: The new selection state.

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
TextElement
BackgroundColorElement
TextColorElement
DisableableElement
SelectableElement
Element
Visibility




____________________________________________________________
Section: 28. URL: http://localhost:8080/documentation/toggle

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.toggle Toggle Reference Properties Methods Inheritance


ui. toggle


Toggle


This element is based on Quasar's QBtnToggle component.
The options can be specified as a list of values, or as a dictionary mapping values to labels.
After manipulating the options, call update() to update the options in the UI.

options: a list ['value1', ...] or dictionary {'value1':'label1', ...} specifying the options
value: the initial value
on_change: callback to execute when selection changes
clearable: whether the toggle can be cleared by clicking the selected option


Coding example:
from nicegui import ui

toggle1 = ui.toggle([1, 2, 3], value=1)
toggle2 = ui.toggle({1: 'A', 2: 'B', 3: 'C'}).bind_value(toggle1, 'value')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_options (options: Union[List, Dict], value: Any = Ellipsis) -> None


Set the options of this choice element.

param options: The new options.
param value: The new value. If not given, the current value is kept.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Inheritance

ChoiceElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 29. URL: http://localhost:8080/documentation/radio

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.radio Radio Selection Inject arbitrary content Reference Properties Methods Inheritance


ui. radio


Radio Selection


This element is based on Quasar's QRadio component.
The options can be specified as a list of values, or as a dictionary mapping values to labels.
After manipulating the options, call update() to update the options in the UI.

options: a list ['value1', ...] or dictionary {'value1':'label1', ...} specifying the options
value: the initial value
on_change: callback to execute when selection changes


Coding example:
from nicegui import ui

radio1 = ui.radio([1, 2, 3], value=1).props('inline')
radio2 = ui.radio({1: 'A', 2: 'B', 3: 'C'}).props('inline').bind_value(radio1, 'value')

ui.run()


Inject arbitrary content

Thanks to the ui.teleport element , you can use arbitrary content for the radio options.


Coding example:
from nicegui import ui

options = ['Star', 'Thump Up', 'Heart']
radio = ui.radio({x: '' for x in options}, value='Star').props('inline')
with ui.teleport(f'#c{radio.id} > div:nth-child(1) .q-radio__label'):
    ui.icon('star', size='md')
with ui.teleport(f'#c{radio.id} > div:nth-child(2) .q-radio__label'):
    ui.icon('thumb_up', size='md')
with ui.teleport(f'#c{radio.id} > div:nth-child(3) .q-radio__label'):
    ui.icon('favorite', size='md')
ui.label().bind_text_from(radio, 'value')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_options (options: Union[List, Dict], value: Any = Ellipsis) -> None


Set the options of this choice element.

param options: The new options.
param value: The new value. If not given, the current value is kept.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Inheritance

ChoiceElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 30. URL: http://localhost:8080/documentation/select

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.select Dropdown Selection Search-as-you-type Multi selection Update options Reference Properties Methods Inheritance


ui. select


Dropdown Selection


This element is based on Quasar's QSelect component.
The options can be specified as a list of values, or as a dictionary mapping values to labels.
After manipulating the options, call update() to update the options in the UI.
If with_input is True, an input field is shown to filter the options.
If new_value_mode is not None, it implies with_input=True and the user can enter new values in the input field.
See Quasar's documentation for details.
Note that this mode is ineffective when setting the value property programmatically.
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too long!': lambda value: len(value) < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.

options: a list ['value1', ...] or dictionary {'value1':'label1', ...} specifying the options
label: the label to display above the selection
value: the initial value
on_change: callback to execute when selection changes
with_input: whether to show an input field to filter the options
new_value_mode: handle new values from user input (default: None, i.e. no new values)
multiple: whether to allow multiple selections
clearable: whether to add a button to clear the selection
validation: dictionary of validation rules or a callable that returns an optional error message
key_generator: a callback or iterator to generate a dictionary key for new values


Coding example:
from nicegui import ui

select1 = ui.select([1, 2, 3], value=1)
select2 = ui.select({1: 'One', 2: 'Two', 3: 'Three'}).bind_value(select1, 'value')

ui.run()


Search-as-you-type

You can activate with_input to get a text input with autocompletion.
The options will be filtered as you type.


Coding example:
from nicegui import ui

continents = [
    'Asia',
    'Africa',
    'Antarctica',
    'Europe',
    'Oceania',
    'North America',
    'South America',
]
ui.select(options=continents, with_input=True,
          on_change=lambda e: ui.notify(e.value)).classes('w-40')

ui.run()


Multi selection

You can activate multiple to allow the selection of more than one item.


Coding example:
from nicegui import ui

names = ['Alice', 'Bob', 'Carol']
ui.select(names, multiple=True, value=names[:2], label='comma-separated') \
    .classes('w-64')
ui.select(names, multiple=True, value=names[:2], label='with chips') \
    .classes('w-64').props('use-chips')

ui.run()


Update options

Options can be changed with the options property.
But then you also need to call update() afterwards to let the change take effect. set_options is a shortcut that does both and works well for lambdas.


Coding example:
from nicegui import ui

select = ui.select([1, 2, 3], value=1)
with ui.row():
    ui.button('4, 5, 6', on_click=lambda: select.set_options([4, 5, 6], value=4))
    ui.button('1, 2, 3', on_click=lambda: select.set_options([1, 2, 3], value=1))

ui.run()


Reference


Properties


enabled : BindableProperty

error : Optional[str] (settable)


The latest error message from the validation functions.

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_options (options: Union[List, Dict], value: Any = Ellipsis) -> None


Set the options of this choice element.

param options: The new options.
param value: The new value. If not given, the current value is kept.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None

validate () -> bool


Validate the current value and set the error message if necessary.

return: True if the value is valid, False otherwise

without_auto_validation () -> Self


Disable automatic validation on value change.


Inheritance

ValidationElement
ChoiceElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 31. URL: http://localhost:8080/documentation/checkbox

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.checkbox Checkbox Reference Properties Methods Inheritance


ui. checkbox


Checkbox


This element is based on Quasar's QCheckbox component.

text: the label to display next to the checkbox
value: whether it should be checked initially (default: False)
on_change: callback to execute when value changes


Coding example:
from nicegui import ui

checkbox = ui.checkbox('check me')
ui.label('Check!').bind_visibility_from(checkbox, 'value')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

text : BindableProperty

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 32. URL: http://localhost:8080/documentation/switch

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.switch Switch Reference Properties Methods Inheritance


ui. switch


Switch


This element is based on Quasar's QToggle component.

text: the label to display next to the switch
value: whether it should be active initially (default: False)
on_change: callback which is invoked when state is changed by the user


Coding example:
from nicegui import ui

switch = ui.switch('switch me')
ui.label('Switch!').bind_visibility_from(switch, 'value')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

text : BindableProperty

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 33. URL: http://localhost:8080/documentation/slider

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.slider Slider Throttle events with leading and trailing options Disable slider Reference Properties Methods Inheritance


ui. slider


Slider


This element is based on Quasar's QSlider component.

min: lower bound of the slider
max: upper bound of the slider
step: step size
value: initial value to set position of the slider
on_change: callback which is invoked when the user releases the slider


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=100, value=50)
ui.label().bind_text_from(slider, 'value')

ui.run()


Throttle events with leading and trailing options

By default the value change event of a slider is throttled to 0.05 seconds.
This means that if you move the slider quickly, the value will only be updated every 0.05 seconds.
By default both "leading" and "trailing" events are activated.
This means that the very first event is triggered immediately, and the last event is triggered after the throttle time.
This demo shows how disabling either of these options changes the behavior.
To see the effect more clearly, the throttle time is set to 1 second.
The first slider shows the default behavior, the second one only sends leading events, and the third only sends trailing events.


Coding example:
from nicegui import ui

ui.label('default')
ui.slider(min=0, max=10, step=0.1, value=5).props('label-always') \
    .on('update:model-value', lambda e: ui.notify(e.args),
        throttle=1.0)

ui.label('leading events only')
ui.slider(min=0, max=10, step=0.1, value=5).props('label-always') \
    .on('update:model-value', lambda e: ui.notify(e.args),
        throttle=1.0, trailing_events=False)

ui.label('trailing events only')
ui.slider(min=0, max=10, step=0.1, value=5).props('label-always') \
    .on('update:model-value', lambda e: ui.notify(e.args),
        throttle=1.0, leading_events=False)

ui.run()


Disable slider

You can disable a slider with the disable() method.
This will prevent the user from moving the slider.
The slider will also be grayed out.


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=100, value=50)
ui.button('Disable slider', on_click=slider.disable)
ui.button('Enable slider', on_click=slider.enable)

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 34. URL: http://localhost:8080/documentation/range

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.range Range Customize labels Change range limits Reference Properties Methods Inheritance


ui. range


Range


This element is based on Quasar's QRange component.

min: lower bound of the range
max: upper bound of the range
step: step size
value: initial value to set min and max position of the range
on_change: callback which is invoked when the user releases the range


Coding example:
from nicegui import ui

min_max_range = ui.range(min=0, max=100, value={'min': 20, 'max': 80})
ui.label().bind_text_from(min_max_range, 'value',
                          backward=lambda v: f'min: {v["min"]}, max: {v["max"]}')

ui.run()


Customize labels

You can customize the colors of the range and its labels by setting them individually or for the range in total.


Coding example:
from nicegui import ui

ui.label('Color the entire range')
ui.range(min=0, max=100, value={'min': 20, 'max': 80}) \
    .props('label snap color="secondary"')

ui.label('Customize the color of the labels')
ui.range(min=0, max=100, value={'min': 40, 'max': 80}) \
    .props('label-always snap label-color="secondary" right-label-text-color="black"')

ui.run()


Change range limits

This demo shows how to change the limits on the click of a button.


Coding example:
from nicegui import ui

def increase_limits():
    r.min -= 10
    r.max += 10

ui.button('Increase limits', on_click=increase_limits)
r = ui.range(min=0, max=100, value={'min': 30, 'max': 70}).props('label-always')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

max : float (settable)


The maximum value allowed.

min : float (settable)


The minimum value allowed.

step : float (settable)


The step size between valid values.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 35. URL: http://localhost:8080/documentation/joystick

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.joystick Joystick Reference Properties Methods Inheritance


ui. joystick


Joystick


Create a joystick based on nipple.js .

on_start: callback for when the user touches the joystick
on_move: callback for when the user moves the joystick
on_end: callback for when the user releases the joystick
throttle: throttle interval in seconds for the move event (default: 0.05)
options: arguments like color which should be passed to the underlying nipple.js library


Coding example:
from nicegui import ui

ui.joystick(color='blue', size=50,
            on_move=lambda e: coordinates.set_text(f'{e.x:.3f}, {e.y:.3f}'),
            on_end=lambda _: coordinates.set_text('0, 0'))
coordinates = ui.label('0, 0')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_end (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the user releases the joystick.

on_move (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the user moves the joystick.

on_start (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the user touches the joystick.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 36. URL: http://localhost:8080/documentation/input

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.input Text Input Autocompletion Clearable Styling Input validation Reference Properties Methods Inheritance


ui. input


Text Input


This element is based on Quasar's QInput component.
The on_change event is called on every keystroke and the value updates accordingly.
If you want to wait until the user confirms the input, you can register a custom event callback, e.g. ui.input(...).on('keydown.enter', ...) or ui.input(...).on('blur', ...) .
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too long!': lambda value: len(value) < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.
Note about styling the input:
Quasar's QInput component is a wrapper around a native input element.
This means that you cannot style the input directly,
but you can use the input-class and input-style props to style the native input element.
See the "Style" props section on the QInput documentation for more details.

label: displayed label for the text input
placeholder: text to show if no value is entered
value: the current value of the text input
password: whether to hide the input (default: False)
password_toggle_button:
 whether to show a button to toggle the password visibility (default: False)
on_change: callback to execute when the value changes
autocomplete: optional list of strings for autocompletion
validation: dictionary of validation rules or a callable that returns an optional error message


Coding example:
from nicegui import ui

ui.input(label='Text', placeholder='start typing',
         on_change=lambda e: result.set_text('you typed: ' + e.value),
         validation={'Input too long': lambda value: len(value) < 20})
result = ui.label()

ui.run()


Autocompletion

The autocomplete feature provides suggestions as you type, making input easier and faster.
The parameter options is a list of strings that contains the available options that will appear.


Coding example:
from nicegui import ui

options = ['AutoComplete', 'NiceGUI', 'Awesome']
ui.input(label='Text', placeholder='start typing', autocomplete=options)

ui.run()


Clearable

The clearable prop from Quasar adds a button to the input that clears the text.


Coding example:
from nicegui import ui

i = ui.input(value='some text').props('clearable')
ui.label().bind_text_from(i, 'value')

ui.run()


Styling

Quasar has a lot of props to change the appearance .
It is even possible to style the underlying input with input-style and input-class props
and use the provided slots to add custom elements.


Coding example:
from nicegui import ui

ui.input(placeholder='start typing').props('rounded outlined dense')
ui.input('styling', value='some text') \
    .props('input-style="color: blue" input-class="font-mono"')
with ui.input(value='custom clear button').classes('w-64') as i:
    ui.button(color='orange-8', on_click=lambda: i.set_value(None), icon='delete') \
        .props('flat dense').bind_visibility_from(i, 'value')

ui.run()


Input validation

You can validate the input in two ways:
by passing a callable that returns an error message or None , or
by passing a dictionary that maps error messages to callables that return True if the input is valid.


Coding example:
from nicegui import ui

ui.input('Name', validation=lambda value: 'Too short' if len(value) < 5 else None)
ui.input('Name', validation={'Too short': lambda value: len(value) >= 5})

ui.run()


Reference


Properties


enabled : BindableProperty

error : Optional[str] (settable)


The latest error message from the validation functions.

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_autocomplete (autocomplete: Optional[List[str]]) -> None


Set the autocomplete list.

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.

validate () -> bool


Validate the current value and set the error message if necessary.

return: True if the value is valid, False otherwise

without_auto_validation () -> Self


Disable automatic validation on value change.


Inheritance

ValidationElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 37. URL: http://localhost:8080/documentation/textarea

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.textarea Textarea Clearable Reference Properties Methods Inheritance


ui. textarea


Textarea


This element is based on Quasar's QInput component.
The type is set to textarea to create a multi-line text input.
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too long!': lambda value: len(value) < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.

label: displayed name for the textarea
placeholder: text to show if no value is entered
value: the initial value of the field
on_change: callback to execute when the value changes
validation: dictionary of validation rules or a callable that returns an optional error message


Coding example:
from nicegui import ui

ui.textarea(label='Text', placeholder='start typing',
            on_change=lambda e: result.set_text('you typed: ' + e.value))
result = ui.label()

ui.run()


Clearable

The clearable prop from Quasar adds a button to the input that clears the text.


Coding example:
from nicegui import ui

i = ui.textarea(value='some text').props('clearable')
ui.label().bind_text_from(i, 'value')

ui.run()


Reference


Properties


enabled : BindableProperty

error : Optional[str] (settable)


The latest error message from the validation functions.

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_autocomplete (autocomplete: Optional[List[str]]) -> None


Set the autocomplete list.

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.

validate () -> bool


Validate the current value and set the error message if necessary.

return: True if the value is valid, False otherwise

without_auto_validation () -> Self


Disable automatic validation on value change.


Inheritance

Input
ValidationElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 38. URL: http://localhost:8080/documentation/codemirror

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.codemirror CodeMirror Reference Properties Methods Inheritance


ui. codemirror


CodeMirror


An element to create a code editor using CodeMirror .
It supports syntax highlighting for over 140 languages, more than 30 themes, line numbers, code folding, (limited) auto-completion, and more. Supported languages and themes:
Languages: A list of supported languages can be found in the @codemirror/language-data package.
Themes: A list can be found in the @uiw/codemirror-themes-all package.
At runtime, the methods supported_languages and supported_themes can be used to get supported languages and themes.

value: initial value of the editor (default: "")
on_change: callback to be executed when the value changes (default: None)
language: initial language of the editor (case-insensitive, default: None)
theme: initial theme of the editor (default: "basicLight")
indent: string to use for indentation (any string consisting entirely of the same whitespace character, default: "    ")
line_wrapping: whether to wrap lines (default: False)
highlight_whitespace:
 whether to highlight whitespace (default: False)


Coding example:
from nicegui import ui

editor = ui.codemirror('print("Edit me!")', language='Python').classes('h-32')
ui.select(editor.supported_languages, label='Language', clearable=True) \
    .classes('w-32').bind_value(editor, 'language')
ui.select(editor.supported_themes, label='Theme') \
    .classes('w-32').bind_value(editor, 'theme')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

language : str (settable)


The current language of the editor.

supported_languages : List[str]


List of supported languages.

supported_themes : List[str]


List of supported themes.

theme : str (settable)


The current theme of the editor.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_language (language: Optional[str]) -> None


Sets the language of the editor (case-insensitive).

set_theme (theme: str) -> None


Sets the theme of the editor.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 39. URL: http://localhost:8080/documentation/number

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.number Number Input Clearable Number of decimal places Reference Properties Methods Inheritance


ui. number


Number Input


This element is based on Quasar's QInput component.
You can use the validation parameter to define a dictionary of validation rules,
e.g. {'Too small!': lambda value: value < 3} .
The key of the first rule that fails will be displayed as an error message.
Alternatively, you can pass a callable that returns an optional error message.
To disable the automatic validation on every value change, you can use the without_auto_validation method.

label: displayed name for the number input
placeholder: text to show if no value is entered
value: the initial value of the field
min: the minimum value allowed
max: the maximum value allowed
precision: the number of decimal places allowed (default: no limit, negative: decimal places before the dot)
step: the step size for the stepper buttons
prefix: a prefix to prepend to the displayed value
suffix: a suffix to append to the displayed value
format: a string like "%.2f" to format the displayed value
on_change: callback to execute when the value changes
validation: dictionary of validation rules or a callable that returns an optional error message


Coding example:
from nicegui import ui

ui.number(label='Number', value=3.1415927, format='%.2f',
          on_change=lambda e: result.set_text(f'you entered: {e.value}'))
result = ui.label()

ui.run()


Clearable

The clearable prop from Quasar adds a button to the input that clears the text.


Coding example:
from nicegui import ui

i = ui.number(value=42).props('clearable')
ui.label().bind_text_from(i, 'value')

ui.run()


Number of decimal places

You can specify the number of decimal places using the precision parameter.
A negative value means decimal places before the dot.
The rounding takes place when the input loses focus,
when sanitization parameters like min, max or precision change,
or when sanitize() is called manually.


Coding example:
from nicegui import ui

n = ui.number(value=3.14159265359, precision=5)
n.sanitize()

ui.run()


Reference


Properties


enabled : BindableProperty

error : Optional[str] (settable)


The latest error message from the validation functions.

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

max : float (settable)


The maximum value allowed.

min : float (settable)


The minimum value allowed.

out_of_limits : bool


Whether the current value is out of the allowed limits.

precision : Optional[int] (settable)


The number of decimal places allowed (default: no limit, negative: decimal places before the dot).

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

sanitize () -> None


Sanitize the current value to be within the allowed limits.

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.

validate () -> bool


Validate the current value and set the error message if necessary.

return: True if the value is valid, False otherwise

without_auto_validation () -> Self


Disable automatic validation on value change.


Inheritance

ValidationElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 40. URL: http://localhost:8080/documentation/knob

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.knob Knob Reference Properties Methods Inheritance


ui. knob


Knob


This element is based on Quasar's QKnob component.
The element is used to take a number input from the user through mouse/touch panning.

value: the initial value (default: 0.0)
min: the minimum value (default: 0.0)
max: the maximum value (default: 1.0)
step: the step size (default: 0.01)
color: knob color (either a Quasar, Tailwind, or CSS color or None, default: "primary")
center_color: color name for the center part of the component, examples: primary, teal-10
track_color: color name for the track of the component, examples: primary, teal-10
size: size in CSS units, including unit name or standard size name (xs|sm|md|lg|xl), examples: 16px, 2rem
show_value: whether to show the value as text
on_change: callback to execute when the value changes


Coding example:
from nicegui import ui

knob = ui.knob(0.3, show_value=True)

with ui.knob(color='orange', track_color='grey-2').bind_value(knob, 'value'):
    ui.icon('volume_up')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
TextColorElement
Element
Visibility




____________________________________________________________
Section: 41. URL: http://localhost:8080/documentation/color_input

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.color_input Color Input Reference Properties Methods Inheritance


ui. color_input


Color Input


This element extends Quasar's QInput component with a color picker.

label: displayed label for the color input
placeholder: text to show if no color is selected
value: the current color value
on_change: callback to execute when the value changes
preview: change button background to selected color (default: False)


Coding example:
from nicegui import ui

label = ui.label('Change my color!')
ui.color_input(label='Color', value='#000000',
               on_change=lambda e: label.style(f'color:{e.value}'))

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

open_picker () -> None


Open the color picker

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 42. URL: http://localhost:8080/documentation/color_picker

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.color_picker Color Picker Reference Properties Methods Inheritance


ui. color_picker


Color Picker


This element is based on Quasar's QMenu and QColor components.

on_pick: callback to execute when a color is picked
value: whether the menu is already opened (default: False)


Coding example:
from nicegui import ui

with ui.button(icon='colorize') as button:
    ui.color_picker(on_pick=lambda e: button.style(f'background-color:{e.color}!important'))

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

close () -> None


Close the menu.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_pick (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a color is picked.

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

open () -> None


Open the menu.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_color (color: str) -> None


Set the color of the picker.

param color: the color to set

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle () -> None


Toggle the menu.

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Menu
ValueElement
Element
Visibility




____________________________________________________________
Section: 43. URL: http://localhost:8080/documentation/date

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.date Date Input Input element with date picker Date filter Reference Properties Methods Inheritance


ui. date


Date Input


This element is based on Quasar's QDate component.
The date is a string in the format defined by the mask parameter.
Coding example:
ui.date({'from': '2023-01-01', 'to': '2023-01-05'}).props('range')
ui.date(['2023-01-01', '2023-01-02', '2023-01-03']).props('multiple')
ui.date([{'from': '2023-01-01', 'to': '2023-01-05'}, '2023-01-07']).props('multiple range')


value: the initial date
mask: the format of the date string (default: 'YYYY-MM-DD')
on_change: callback to execute when changing the date


Coding example:
from nicegui import ui

ui.date(value='2023-01-01', on_change=lambda e: result.set_text(e.value))
result = ui.label()

ui.run()


Input element with date picker

This demo shows how to implement a date picker with an input element.
We place an icon in the input element's append slot.
When the icon is clicked, we open a menu with a date picker. QMenu 's "no-parent-event" prop is used
to prevent opening the menu when clicking into the input field.
As the menu doesn't come with a "Close" button by default, we add one for convenience.
The date is bound to the input element's value.
So both the input element and the date picker will stay in sync whenever the date is changed.


Coding example:
from nicegui import ui

with ui.input('Date') as date:
    with ui.menu().props('no-parent-event') as menu:
        with ui.date().bind_value(date):
            with ui.row().classes('justify-end'):
                ui.button('Close', on_click=menu.close).props('flat')
    with date.add_slot('append'):
        ui.icon('edit_calendar').on('click', menu.open).classes('cursor-pointer')

ui.run()


Date filter

This demo shows how to filter the dates in a date picker.
In order to pass a function to the date picker, we use the :options property.
The leading : tells NiceGUI that the value is a JavaScript expression.


Coding example:
from nicegui import ui

ui.date().props('''default-year-month=2023/01 :options="date => date <= '2023/01/15'"''')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 44. URL: http://localhost:8080/documentation/time

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.time Time Input Input element with time picker Reference Properties Methods Inheritance


ui. time


Time Input


This element is based on Quasar's QTime component.
The time is a string in the format defined by the mask parameter.

value: the initial time
mask: the format of the time string (default: 'HH:mm')
on_change: callback to execute when changing the time


Coding example:
from nicegui import ui

ui.time(value='12:00', on_change=lambda e: result.set_text(e.value))
result = ui.label()

ui.run()


Input element with time picker

This demo shows how to implement a time picker with an input element.
We place an icon in the input element's append slot.
When the icon is clicked, we open a menu with a time picker. QMenu 's "no-parent-event" prop is used
to prevent opening the menu when clicking into the input field.
As the menu doesn't come with a "Close" button by default, we add one for convenience.
The time is bound to the input element's value.
So both the input element and the time picker will stay in sync whenever the time is changed.


Coding example:
from nicegui import ui

with ui.input('Time') as time:
    with ui.menu().props('no-parent-event') as menu:
        with ui.time().bind_value(time):
            with ui.row().classes('justify-end'):
                ui.button('Close', on_click=menu.close).props('flat')
    with time.add_slot('append'):
        ui.icon('access_time').on('click', menu.open).classes('cursor-pointer')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 45. URL: http://localhost:8080/documentation/upload

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.upload File Upload Upload restrictions Show file content Uploading large files Reference Properties Methods Inheritance


ui. upload


File Upload


Based on Quasar's QUploader component.

multiple: allow uploading multiple files at once (default: False)
max_file_size: maximum file size in bytes (default: 0)
max_total_size: maximum total size of all files in bytes (default: 0)
max_files: maximum number of files (default: 0)
on_upload: callback to execute for each uploaded file
on_multi_upload:
 callback to execute after multiple files have been uploaded
on_rejected: callback to execute for each rejected file
label: label for the uploader (default: '')
auto_upload: automatically upload files when they are selected (default: False)


Coding example:
from nicegui import ui

ui.upload(on_upload=lambda e: ui.notify(f'Uploaded {e.name}')).classes('max-w-full')

ui.run()


Upload restrictions

In this demo, the upload is restricted to a maximum file size of 1 MB.
When a file is rejected, a notification is shown.


Coding example:
from nicegui import ui

ui.upload(on_upload=lambda e: ui.notify(f'Uploaded {e.name}'),
          on_rejected=lambda: ui.notify('Rejected!'),
          max_file_size=1_000_000).classes('max-w-full')

ui.run()


Show file content

In this demo, the uploaded markdown file is shown in a dialog.


Coding example:
from nicegui import events, ui

with ui.dialog().props('full-width') as dialog:
    with ui.card():
        content = ui.markdown()

def handle_upload(e: events.UploadEventArguments):
    text = e.content.read().decode('utf-8')
    content.set_content(text)
    dialog.open()

ui.upload(on_upload=handle_upload).props('accept=.md').classes('max-w-full')

ui.run()


Uploading large files

Large file uploads may encounter issues due to the default file size parameter set within the underlying Starlette library.
To ensure smooth uploads of larger files, it is recommended to increase the max_file_size parameter in Starlette's MultiPartParser class from the default of 1024 * 1024 (1 MB) to a higher limit that aligns with the expected file sizes.
This demo increases Starlette Multiparser's max_file_size to be kept in RAM to 5 MB.
This change allows the system to handle larger files more efficiently by keeping them in RAM, thus avoiding the need to write data to temporary files on disk and preventing upload "stuttering".
However, be mindful of the potential impact on your server when allowing users to upload large files and retaining them in RAM.


Coding example:
from nicegui import ui
from starlette.formparsers import MultiPartParser

MultiPartParser.max_file_size = 1024 * 1024 * 5  # 5 MB

ui.upload(on_upload=lambda e: ui.notify(f'Uploaded {e.name}')).classes('max-w-full')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_multi_upload (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when multiple files have been uploaded.

on_rejected (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a file is rejected.

on_upload (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a file is uploaded.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

reset () -> None


Clear the upload queue.

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

DisableableElement
Element
Visibility




____________________________________________________________
Section: 46. URL: http://localhost:8080/documentation/teleport

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.teleport Teleport Radio element with arbitrary content Injecting a graph into a table cell Reference Properties Methods Inheritance


ui. teleport


Teleport


An element that allows us to transmit the content from within a component to any location on the page.

to: NiceGUI element or CSS selector of the target element for the teleported content


Coding example:
from nicegui import ui

markdown = ui.markdown('Enter your **name**!')

def inject_input():
    with ui.teleport(f'#c{markdown.id} strong'):
        ui.input('name').classes('inline-flex').props('dense outlined')

ui.button('inject input', on_click=inject_input)

ui.run()


Radio element with arbitrary content

With the right CSS selector, you can place any content inside a standard radio element.


Coding example:
from nicegui import ui

options = ['Star', 'Thump Up', 'Heart']
radio = ui.radio({x: '' for x in options}, value='Star').props('inline')
with ui.teleport(f'#c{radio.id} > div:nth-child(1) .q-radio__label'):
    ui.icon('star', size='md')
with ui.teleport(f'#c{radio.id} > div:nth-child(2) .q-radio__label'):
    ui.icon('thumb_up', size='md')
with ui.teleport(f'#c{radio.id} > div:nth-child(3) .q-radio__label'):
    ui.icon('favorite', size='md')
ui.label().bind_text_from(radio, 'value')

ui.run()


Injecting a graph into a table cell

This demo shows how to inject ECharts graphs into table cells.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Product', 'field': 'name', 'align': 'center'},
    {'name': 'sales', 'label': 'Sales', 'field': 'sales', 'align': 'center'},
]
rows = [
    {'name': 'A', 'data': [10, 8, 2, 4]},
    {'name': 'B', 'data': [3, 5, 7, 8]},
    {'name': 'C', 'data': [2, 1, 3, 7]},
]
table = ui.table(columns=columns, rows=rows, row_key='name').classes('w-72')
for r, row in enumerate(rows):
    with ui.teleport(f'#c{table.id} tr:nth-child({r+1}) td:nth-child(2)'):
        ui.echart({
            'xAxis': {'type': 'category', 'show': False},
            'yAxis': {'type': 'value', 'show': False},
            'series': [{'type': 'line', 'data': row['data']}],
        }).classes('w-44 h-20')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Force the internal content to be retransmitted to the specified location.
This method is usually called after the target container is rebuilt.


Inheritance

Element
Visibility




____________________________________________________________
Section: 47. URL: http://localhost:8080/documentation/interactive_image

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.interactive_image Interactive Image Nesting elements Force reload Blank canvas Loaded event Crosshairs SVG events Reference Properties Methods Inheritance


ui. interactive_image


Interactive Image


Create an image with an SVG overlay that handles mouse events and yields image coordinates.
It is also the best choice for non-flickering image updates.
If the source URL changes faster than images can be loaded by the browser, some images are simply skipped.
Thereby repeatedly updating the image source will automatically adapt to the available bandwidth.
See OpenCV Webcam for an example.
The mouse event handler is called with mouse event arguments containing
type (the name of the JavaScript event),
image_x and image_y (image coordinates in pixels),
button and buttons (mouse button numbers from the JavaScript event), as well as
alt , ctrl , meta , and shift (modifier keys from the JavaScript event).
You can also pass a tuple of width and height instead of an image source.
This will create an empty image with the given size.

source: the source of the image; can be an URL, local file path, a base64 string or just an image size
content: SVG content which should be overlaid; viewport has the same dimensions as the image
size: size of the image (width, height) in pixels; only used if source is not set
on_mouse: callback for mouse events (contains image coordinates image_x and image_y in pixels)
events: list of JavaScript events to subscribe to (default: ['click'])
cross: whether to show crosshairs or a color string (default: False)


Coding example:
from nicegui import events, ui

def mouse_handler(e: events.MouseEventArguments):
    color = 'SkyBlue' if e.type == 'mousedown' else 'SteelBlue'
    ii.content += f'<circle cx="{e.image_x}" cy="{e.image_y}" r="15" fill="none" stroke="{color}" stroke-width="4" />'
    ui.notify(f'{e.type} at ({e.image_x:.1f}, {e.image_y:.1f})')

src = 'https://picsum.photos/id/565/640/360'
ii = ui.interactive_image(src, on_mouse=mouse_handler, events=['mousedown', 'mouseup'], cross=True)

ui.run()


Nesting elements

You can nest elements inside an interactive image.
Use Tailwind classes like "absolute top-0 left-0" to position the label absolutely with respect to the image.
Of course this can be done with plain CSS as well.


Coding example:
from nicegui import ui

with ui.interactive_image('https://picsum.photos/id/147/640/360'):
    ui.button(on_click=lambda: ui.notify('thumbs up'), icon='thumb_up') \
        .props('flat fab color=white') \
        .classes('absolute bottom-0 left-0 m-2')

ui.run()


Force reload

You can force an image to reload by calling the force_reload method.
It will append a timestamp to the image URL, which will make the browser reload the image.


Coding example:
from nicegui import ui

img = ui.interactive_image('https://picsum.photos/640/360').classes('w-64')

ui.button('Force reload', on_click=img.force_reload)

ui.run()


Blank canvas

You can also create a blank canvas with a given size.
This is useful if you want to draw something without loading a background image.


Coding example:
from nicegui import ui

ui.interactive_image(
    size=(800, 600), cross=True,
    on_mouse=lambda e: e.sender.set_content(f'''
        <circle cx="{e.image_x}" cy="{e.image_y}" r="50" fill="orange" />
    '''),
).classes('w-64 bg-blue-50')

ui.run()


Loaded event

You can listen to the "loaded" event to know when the image has been loaded.


Coding example:
import time
from nicegui import ui

ii = ui.interactive_image('https://picsum.photos/640/360')
ii.on('loaded', lambda e: ui.notify(f'loaded {e.args}'))
ui.button('Change Source', on_click=lambda: ii.set_source(f'https://picsum.photos/640/360?time={time.time()}'))

ui.run()


Crosshairs

You can show crosshairs by passing cross=True .
You can also change the color of the crosshairs by passing a color string.


Coding example:
from nicegui import ui

ui.interactive_image('https://picsum.photos/id/565/640/360', cross='red')

ui.run()


SVG events

You can subscribe to events of the SVG elements by using the on method with an "svg:" prefix.
Make sure to set pointer-events="all" for the SVG elements you want to receive events from.
Currently the following SVG events are supported:
pointermove
pointerdown
pointerup
pointerover
pointerout
pointerenter
pointerleave
pointercancel


Coding example:
from nicegui import ui

ui.interactive_image('https://picsum.photos/id/565/640/360', cross=True, content='''
    <rect id="A" x="85" y="70" width="80" height="60" fill="none" stroke="red" pointer-events="all" cursor="pointer" />
    <rect id="B" x="180" y="70" width="80" height="60" fill="none" stroke="red" pointer-events="all" cursor="pointer" />
''').on('svg:pointerdown', lambda e: ui.notify(f'SVG clicked: {e.args}'))

ui.run()


Reference


Properties


content : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

source : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_content (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_content_from (target_object: Any, target_name: str = 'content', backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_content_to (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_source (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_source_from (target_object: Any, target_name: str = 'source', backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_source_to (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

force_reload () -> None


Force the image to reload from the source.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_mouse (on_mouse: Callable[..., Any]) -> Self


Add a callback to be invoked when a mouse event occurs.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_content (content: str) -> None


Set the content of this element.

param content: The new content.

set_source (source: "Union[str, Path, 'PIL_Image']") -> None

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

SourceElement
ContentElement
Element
Visibility




____________________________________________________________
Section: 48. URL: http://localhost:8080/documentation/audio

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.audio Audio Control the audio element Event subscription Reference Properties Methods Inheritance


ui. audio


Audio


Displays an audio player.

src: URL or local file path of the audio source
controls: whether to show the audio controls, like play, pause, and volume (default: True)
autoplay: whether to start playing the audio automatically (default: False)
muted: whether the audio should be initially muted (default: False)
loop: whether the audio should loop (default: False)
See here for a list of events you can subscribe to using the generic event subscription on() .


Coding example:
from nicegui import ui

a = ui.audio('https://cdn.pixabay.com/download/audio/2022/02/22/audio_d1718ab41b.mp3')
a.on('ended', lambda _: ui.notify('Audio playback completed'))

ui.button(on_click=lambda: a.props('muted'), icon='volume_off').props('outline')
ui.button(on_click=lambda: a.props(remove='muted'), icon='volume_up').props('outline')

ui.run()


Control the audio element

This demo shows how to play, pause and seek programmatically.


Coding example:
from nicegui import ui

a = ui.audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3')
ui.button('Play', on_click=a.play)
ui.button('Pause', on_click=a.pause)
ui.button('Jump to 0:30', on_click=lambda: a.seek(30))

ui.run()


Event subscription

This demo shows how to subscribe to some of the available events .


Coding example:
from nicegui import ui

a = ui.audio('https://cdn.pixabay.com/download/audio/2022/02/22/audio_d1718ab41b.mp3')
a.on('play', lambda _: ui.notify('Started'))
a.on('pause', lambda _: ui.notify('Paused'))
a.on('ended', lambda _: ui.notify('Completed'))

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

source : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_source (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_source_from (target_object: Any, target_name: str = 'source', backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_source_to (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

pause () -> None


Pause audio.

play () -> None


Play audio.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

seek (seconds: float) -> None


Seek to a specific position in the audio.

param seconds: the position in seconds

set_source (source: Union[str, pathlib.Path]) -> None

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

SourceElement
Element
Visibility




____________________________________________________________
Section: 49. URL: http://localhost:8080/documentation/video

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.video Video Control the video element Reference Properties Methods Inheritance


ui. video


Video


Displays a video.

src: URL or local file path of the video source
controls: whether to show the video controls, like play, pause, and volume (default: True)
autoplay: whether to start playing the video automatically (default: False)
muted: whether the video should be initially muted (default: False)
loop: whether the video should loop (default: False)
See here for a list of events you can subscribe to using the generic event subscription on() .


Coding example:
from nicegui import ui

v = ui.video('https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/360/Big_Buck_Bunny_360_10s_1MB.mp4')
v.on('ended', lambda _: ui.notify('Video playback completed'))

ui.run()


Control the video element

This demo shows how to play, pause and seek programmatically.


Coding example:
from nicegui import ui

v = ui.video('https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/360/Big_Buck_Bunny_360_10s_1MB.mp4')
ui.button('Play', on_click=v.play)
ui.button('Pause', on_click=v.pause)
ui.button('Jump to 0:05', on_click=lambda: v.seek(5))

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

source : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_source (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_source_from (target_object: Any, target_name: str = 'source', backward: Callable[..., Any] = [...]) -> Self


Bind the source of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_source_to (target_object: Any, target_name: str = 'source', forward: Callable[..., Any] = [...]) -> Self


Bind the source of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

pause () -> None


Pause video.

play () -> None


Play video.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

seek (seconds: float) -> None


Seek to a specific position in the video.

param seconds: the position in seconds

set_source (source: Union[str, pathlib.Path]) -> None

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

SourceElement
Element
Visibility




____________________________________________________________
Section: 50. URL: http://localhost:8080/documentation/icon

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.icon Icon Material icons and symbols Eva icons Other icon sets Lottie files Reference Properties Methods Inheritance


ui. icon


Icon


This element is based on Quasar's QIcon component.
Here is a reference of possible names.

name: name of the icon (snake case, e.g. add_circle)
size: size in CSS units, including unit name or standard size name (xs|sm|md|lg|xl), examples: 16px, 2rem
color: icon color (either a Quasar, Tailwind, or CSS color or None, default: None)


Coding example:
from nicegui import ui

ui.icon('thumb_up', color='primary').classes('text-5xl')

ui.run()


 thumb_up


Material icons and symbols

You can use different sets of Material icons and symbols.
The Quasar documentation gives an overview of all available icon sets and their name prefix:
None for filled icons
"o_" for outline icons
"r_" for round icons
"s_" for sharp icons
"sym_o_" for outline symbols
"sym_r_" for round symbols
"sym_s_" for sharp symbols


Coding example:
from nicegui import ui

with ui.row().classes('text-4xl'):
    ui.icon('home')
    ui.icon('o_home')
    ui.icon('r_home')
    ui.icon('sym_o_home')
    ui.icon('sym_r_home')

ui.run()


Eva icons

You can use Eva icons in your app.


Coding example:
from nicegui import ui

ui.add_head_html('<link href="https://unpkg.com/eva-icons@1.1.3/style/eva-icons.css" rel="stylesheet" />')

ui.icon('eva-github').classes('text-5xl')

ui.run()


Other icon sets

You can use the same approach for adding other icon sets to your app.
As a rule of thumb, you reference the corresponding CSS, and it in turn references font files.
This demo shows how to include Themify icons .


Coding example:
from nicegui import ui

ui.add_head_html('<link href="https://cdn.jsdelivr.net/themify-icons/0.1.2/css/themify-icons.css" rel="stylesheet" />')

ui.icon('ti-car').classes('text-5xl')

ui.run()


Lottie files

You can also use Lottie files with animations.


Coding example:
from nicegui import ui

ui.add_body_html('<script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>')

src = 'https://assets5.lottiefiles.com/packages/lf20_MKCnqtNQvg.json'
ui.html(f'<lottie-player src="{src}" loop autoplay />').classes('w-24')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

name : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_name (target_object: Any, target_name: str = 'name', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the name of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_name_from (target_object: Any, target_name: str = 'name', backward: Callable[..., Any] = [...]) -> Self


Bind the name of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_name_to (target_object: Any, target_name: str = 'name', forward: Callable[..., Any] = [...]) -> Self


Bind the name of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_name (name: str) -> None


Set the name of this element.

param name: The new name.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

NameElement
TextColorElement
Element
Visibility




____________________________________________________________
Section: 51. URL: http://localhost:8080/documentation/avatar

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.avatar Avatar Photos Reference Properties Methods Inheritance


ui. avatar


Avatar


A avatar element wrapping Quasar's QAvatar component.

icon: name of the icon or image path with "img:" prefix (e.g. "map", "img:path/to/image.png")
color: background color (either a Quasar, Tailwind, or CSS color or None, default: "primary")
text_color: color name from the Quasar Color Palette (e.g. "primary", "teal-10")
size: size in CSS units, including unit name or standard size name (xs|sm|md|lg|xl) (e.g. "16px", "2rem")
font_size: size in CSS units, including unit name, of the content (icon, text) (e.g. "18px", "2rem")
square: removes border-radius so borders are squared (default: False)
rounded: applies a small standard border-radius for a squared shape of the component (default: False)


Coding example:
from nicegui import ui

ui.avatar('favorite_border', text_color='grey-11', square=True)
ui.avatar('img:https://nicegui.io/logo_square.png', color='blue-2')

ui.run()


Photos

To use a photo as an avatar, you can use ui.image within ui.avatar .


Coding example:
from nicegui import ui

with ui.avatar():
    ui.image('https://robohash.org/robot?bgset=bg2')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

BackgroundColorElement
TextColorElement
Element
Visibility




____________________________________________________________
Section: 52. URL: http://localhost:8080/documentation/table

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.table Table Table with expandable rows Show and hide columns Table with drop down selection Table from Pandas DataFrame Adding rows Custom sorting and formatting Toggle fullscreen Pagination Handle pagination changes Computed props Computed fields Conditional formatting Table cells with links Table with masonry-like grid Reference Properties Methods Inheritance


ui. table


Table


A table based on Quasar's QTable component.

columns: list of column objects
rows: list of row objects
row_key: name of the column containing unique data identifying the row (default: "id")
title: title of the table
selection: selection type ("single" or "multiple"; default: None)
pagination: a dictionary correlating to a pagination object or number of rows per page (None hides the pagination, 0 means "infinite"; default: None).
on_select: callback which is invoked when the selection changes
on_pagination_change:
 callback which is invoked when the pagination changes
If selection is 'single' or 'multiple', then a selected property is accessible containing the selected rows.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name', 'required': True, 'align': 'left'},
    {'name': 'age', 'label': 'Age', 'field': 'age', 'sortable': True},
]
rows = [
    {'name': 'Alice', 'age': 18},
    {'name': 'Bob', 'age': 21},
    {'name': 'Carol'},
]
ui.table(columns=columns, rows=rows, row_key='name')

ui.run()


Table with expandable rows

Scoped slots can be used to insert buttons that toggle the expand state of a table row.
See the Quasar documentation for more information.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name'},
    {'name': 'age', 'label': 'Age', 'field': 'age'},
]
rows = [
    {'name': 'Alice', 'age': 18},
    {'name': 'Bob', 'age': 21},
    {'name': 'Carol'},
]

table = ui.table(columns=columns, rows=rows, row_key='name').classes('w-72')
table.add_slot('header', r'''
    <q-tr :props="props">
        <q-th auto-width />
        <q-th v-for="col in props.cols" :key="col.name" :props="props">
            {{ col.label }}
        </q-th>
    </q-tr>
''')
table.add_slot('body', r'''
    <q-tr :props="props">
        <q-td auto-width>
            <q-btn size="sm" color="accent" round dense
                @click="props.expand = !props.expand"
                :icon="props.expand ? 'remove' : 'add'" />
        </q-td>
        <q-td v-for="col in props.cols" :key="col.name" :props="props">
            {{ col.value }}
        </q-td>
    </q-tr>
    <q-tr v-show="props.expand" :props="props">
        <q-td colspan="100%">
            <div class="text-left">This is {{ props.row.name }}.</div>
        </q-td>
    </q-tr>
''')

ui.run()


Show and hide columns

Here is an example of how to show and hide columns in a table.


Coding example:
from nicegui import ui
from typing import Dict

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name', 'required': True, 'align': 'left'},
    {'name': 'age', 'label': 'Age', 'field': 'age', 'sortable': True},
]
rows = [
    {'name': 'Alice', 'age': 18},
    {'name': 'Bob', 'age': 21},
    {'name': 'Carol'},
]
table = ui.table(columns=columns, rows=rows, row_key='name')

def toggle(column: Dict, visible: bool) -> None:
    column['classes'] = '' if visible else 'hidden'
    column['headerClasses'] = '' if visible else 'hidden'
    table.update()

with ui.button(icon='menu'):
    with ui.menu(), ui.column().classes('gap-0 p-2'):
        for column in columns:
            ui.switch(column['label'], value=True, on_change=lambda e,
                      column=column: toggle(column, e.value))

ui.run()


Table with drop down selection

Here is an example of how to use a drop down selection in a table.
After emitting a rename event from the scoped slot, the rename function updates the table rows.


Coding example:
from nicegui import events, ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name'},
    {'name': 'age', 'label': 'Age', 'field': 'age'},
]
rows = [
    {'id': 0, 'name': 'Alice', 'age': 18},
    {'id': 1, 'name': 'Bob', 'age': 21},
    {'id': 2, 'name': 'Carol'},
]
name_options = ['Alice', 'Bob', 'Carol']

def rename(e: events.GenericEventArguments) -> None:
    for row in rows:
        if row['id'] == e.args['id']:
            row['name'] = e.args['name']
    ui.notify(f'Table.rows is now: {table.rows}')

table = ui.table(columns=columns, rows=rows).classes('w-full')
table.add_slot('body-cell-name', r'''
    <q-td key="name" :props="props">
        <q-select
            v-model="props.row.name"
            :options="''' + str(name_options) + r'''"
            @update:model-value="() => $parent.$emit('rename', props.row)"
        />
    </q-td>
''')
table.on('rename', rename)

ui.run()


Table from Pandas DataFrame

You can create a table from a Pandas DataFrame using the from_pandas method.
This method takes a Pandas DataFrame as input and returns a table.


Coding example:
import pandas as pd
from nicegui import ui

df = pd.DataFrame(data={'col1': [1, 2], 'col2': [3, 4]})
ui.table.from_pandas(df).classes('max-h-40')

ui.run()


Adding rows

It's simple to add new rows with the add_rows(dict) method.
With the "virtual-scroll" prop set, the table can be programmatically scrolled with the scrollTo JavaScript function.


Coding example:
from datetime import datetime
from nicegui import ui

def add():
    table.add_rows({'date': datetime.now().strftime('%c')})
    table.run_method('scrollTo', len(table.rows)-1)

columns = [{'name': 'date', 'label': 'Date', 'field': 'date'}]
table = ui.table(columns=columns, rows=[]).classes('h-52').props('virtual-scroll')
ui.button('Add row', on_click=add)

ui.run()


Custom sorting and formatting

You can define dynamic column attributes using a : prefix.
This way you can define custom sorting and formatting functions.
The following example allows sorting the name column by length.
The age column is formatted to show the age in years.


Coding example:
from nicegui import ui

columns = [
    {
        'name': 'name',
        'label': 'Name',
        'field': 'name',
        'sortable': True,
        ':sort': '(a, b, rowA, rowB) => b.length - a.length',
    },
    {
        'name': 'age',
        'label': 'Age',
        'field': 'age',
        ':format': 'value => value + " years"',
    },
]
rows = [
    {'name': 'Alice', 'age': 18},
    {'name': 'Bob', 'age': 21},
    {'name': 'Carl', 'age': 42},
]
ui.table(columns=columns, rows=rows, row_key='name')

ui.run()


Toggle fullscreen

You can toggle the fullscreen mode of a table using the toggle_fullscreen() method.


Coding example:
from nicegui import ui

table = ui.table(
    columns=[{'name': 'name', 'label': 'Name', 'field': 'name'}],
    rows=[{'name': 'Alice'}, {'name': 'Bob'}, {'name': 'Carol'}],
).classes('w-full')

with table.add_slot('top-left'):
    def toggle() -> None:
        table.toggle_fullscreen()
        button.props('icon=fullscreen_exit' if table.is_fullscreen else 'icon=fullscreen')
    button = ui.button('Toggle fullscreen', icon='fullscreen', on_click=toggle).props('flat')

ui.run()


Pagination

You can provide either a single integer or a dictionary to define pagination.
The dictionary can contain the following keys:
rowsPerPage : The number of rows per page.
sortBy : The column name to sort by.
descending : Whether to sort in descending order.
page : The current page (1-based).


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name', 'required': True, 'align': 'left'},
    {'name': 'age', 'label': 'Age', 'field': 'age', 'sortable': True},
]
rows = [
    {'name': 'Elsa', 'age': 18},
    {'name': 'Oaken', 'age': 46},
    {'name': 'Hans', 'age': 20},
    {'name': 'Sven'},
    {'name': 'Olaf', 'age': 4},
    {'name': 'Anna', 'age': 17},
]
ui.table(columns=columns, rows=rows, pagination=3)
ui.table(columns=columns, rows=rows, pagination={'rowsPerPage': 4, 'sortBy': 'age', 'page': 2})

ui.run()


Handle pagination changes

You can handle pagination changes using the on_pagination_change parameter.


Coding example:
from nicegui import ui

ui.table(
    columns=[{'id': 'Name', 'label': 'Name', 'field': 'Name', 'align': 'left'}],
    rows=[{'Name': f'Person {i}'} for i in range(100)],
    pagination=3,
    on_pagination_change=lambda e: ui.notify(e.value),
)

ui.run()


Computed props

You can access the computed props of a table within async callback functions.


Coding example:
from nicegui import ui

async def show_filtered_sorted_rows():
    ui.notify(await table.get_filtered_sorted_rows())

async def show_computed_rows():
    ui.notify(await table.get_computed_rows())

table = ui.table(
    columns=[
        {'name': 'name', 'label': 'Name', 'field': 'name', 'align': 'left', 'sortable': True},
        {'name': 'age', 'label': 'Age', 'field': 'age', 'align': 'left', 'sortable': True}
    ],
    rows=[
        {'name': 'Noah', 'age': 33},
        {'name': 'Emma', 'age': 21},
        {'name': 'Rose', 'age': 88},
        {'name': 'James', 'age': 59},
        {'name': 'Olivia', 'age': 62},
        {'name': 'Liam', 'age': 18},
    ],
    row_key='name',
    pagination=3,
)
ui.input('Search by name/age').bind_value(table, 'filter')
ui.button('Show filtered/sorted rows', on_click=show_filtered_sorted_rows)
ui.button('Show computed rows', on_click=show_computed_rows)

ui.run()


Computed fields

You can use functions to compute the value of a column.
The function receives the row as an argument.
See the Quasar documentation for more information.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name', 'align': 'left'},
    {'name': 'length', 'label': 'Length', ':field': 'row => row.name.length'},
]
rows = [
    {'name': 'Alice'},
    {'name': 'Bob'},
    {'name': 'Christopher'},
]
ui.table(columns=columns, rows=rows, row_key='name')

ui.run()


Conditional formatting

You can use scoped slots to conditionally format the content of a cell.
See the Quasar documentation for more information about body-cell slots.
In this demo we use a q-badge to display the age in red if the person is under 21 years old.
We use the body-cell-age slot to insert the q-badge into the age column.
The ":color" attribute of the q-badge is set to "red" if the age is under 21, otherwise it is set to "green".
The colon in front of the "color" attribute indicates that the value is a JavaScript expression.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name'},
    {'name': 'age', 'label': 'Age', 'field': 'age'},
]
rows = [
    {'name': 'Alice', 'age': 18},
    {'name': 'Bob', 'age': 21},
    {'name': 'Carol', 'age': 42},
]
table = ui.table(columns=columns, rows=rows, row_key='name')
table.add_slot('body-cell-age', '''
    <q-td key="age" :props="props">
        <q-badge :color="props.value < 21 ? 'red' : 'green'">
            {{ props.value }}
        </q-badge>
    </q-td>
''')

ui.run()


Table cells with links

Here is a demo of how to insert links into table cells.
We use the body-cell-link slot to insert an <a> tag into the link column.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name', 'align': 'left'},
    {'name': 'link', 'label': 'Link', 'field': 'link', 'align': 'left'},
]
rows = [
    {'name': 'Google', 'link': 'https://google.com'},
    {'name': 'Facebook', 'link': 'https://facebook.com'},
    {'name': 'Twitter', 'link': 'https://twitter.com'},
]
table = ui.table(columns=columns, rows=rows, row_key='name')
table.add_slot('body-cell-link', '''
    <q-td :props="props">
        <a :href="props.value">{{ props.value }}</a>
    </q-td>
''')

ui.run()


Table with masonry-like grid

You can use the grid prop to display the table as a masonry-like grid.
See the Quasar documentation for more information.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name'},
    {'name': 'age', 'label': 'Age', 'field': 'age'},
]
rows = [
    {'name': 'Alice', 'age': 18},
    {'name': 'Bob', 'age': 21},
    {'name': 'Carol', 'age': 42},
]
table = ui.table(columns=columns, rows=rows, row_key='name').props('grid')
table.add_slot('item', r'''
    <q-card flat bordered :props="props" class="m-1">
        <q-card-section class="text-center">
            <strong>{{ props.row.name }}</strong>
        </q-card-section>
        <q-separator />
        <q-card-section class="text-center">
            <div>{{ props.row.age }} years</div>
        </q-card-section>
    </q-card>
''')

ui.run()


Reference


Properties


columns : List[Dict] (settable)


List of columns.

filter : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_fullscreen : bool (settable)


Whether the table is in fullscreen mode.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

pagination : dict (settable)


Pagination object.

row_key : str (settable)


Name of the column containing unique data identifying the row.

rows : List[Dict] (settable)


List of rows.

selected : List[Dict] (settable)


List of selected rows.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_rows (*rows: Dict) -> None


Add rows to the table.

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_filter (target_object: Any, target_name: str = 'filter', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the filter of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_filter_from (target_object: Any, target_name: str = 'filter', backward: Callable[..., Any] = [...]) -> Self


Bind the filter of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_filter_to (target_object: Any, target_name: str = 'filter', forward: Callable[..., Any] = [...]) -> Self


Bind the filter of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

@classmethod from_pandas (df: pd.DataFrame, row_key: str = 'id', title: Optional[str] = None, selection: Optional[Literal['single', 'multiple']] = None, pagination: Union[int, dict, NoneType] = None, on_select: Optional[Callable[..., Any]] = None) -> Self


Create a table from a Pandas DataFrame.
Note:
If the DataFrame contains non-serializable columns of type datetime64[ns] , timedelta64[ns] , complex128 or period[M] ,
they will be converted to strings.
To use a different conversion, convert the DataFrame manually before passing it to this method.
See issue 1698 for more information.

param df: Pandas DataFrame
param row_key: name of the column containing unique data identifying the row (default: "id")
param title: title of the table
param selection:
 selection type ("single" or "multiple"; default: None)
param pagination:
 a dictionary correlating to a pagination object or number of rows per page (None hides the pagination, 0 means "infinite"; default: None).
param on_select:
 callback which is invoked when the selection changes
return: table element

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

get_computed_rows (timeout: float = 1) -> List[Dict]


Asynchronously return the computed rows of the table.

get_computed_rows_number (timeout: float = 1) -> int


Asynchronously return the number of computed rows of the table.

get_filtered_sorted_rows (timeout: float = 1) -> List[Dict]


Asynchronously return the filtered and sorted rows of the table.

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_pagination_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the pagination changes.

on_select (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the selection changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

remove_rows (*rows: Dict) -> None


Remove rows from the table.

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_filter (filter_: str) -> None


Set the filter of this element.

param filter: The new filter.

set_fullscreen (value: bool) -> None


Set fullscreen mode.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle_fullscreen () -> None


Toggle fullscreen mode.

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.

update_rows (rows: List[Dict], clear_selection: bool = True) -> None


Update rows in the table.

param rows: list of rows to update
param clear_selection:
 whether to clear the selection (default: True)


Inheritance

FilterElement
Element
Visibility




____________________________________________________________
Section: 53. URL: http://localhost:8080/documentation/aggrid

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.aggrid AG Grid Select AG Grid Rows Filter Rows using Mini Filters AG Grid with Conditional Cell Formatting Create Grid from Pandas DataFrame Render columns as HTML Respond to an AG Grid event AG Grid with complex objects AG Grid with dynamic row height Run row methods Filter return values Reference Properties Methods Inheritance


ui. aggrid


AG Grid


An element to create a grid using AG Grid .
The methods run_grid_method and run_column_method can be used to interact with the AG Grid instance on the client.

options: dictionary of AG Grid options
html_columns: list of columns that should be rendered as HTML (default: [])
theme: AG Grid theme (default: 'balham')
auto_size_columns:
 whether to automatically resize columns to fit the grid width (default: True)


Coding example:
from nicegui import ui

grid = ui.aggrid({
    'defaultColDef': {'flex': 1},
    'columnDefs': [
        {'headerName': 'Name', 'field': 'name'},
        {'headerName': 'Age', 'field': 'age'},
        {'headerName': 'Parent', 'field': 'parent', 'hide': True},
    ],
    'rowData': [
        {'name': 'Alice', 'age': 18, 'parent': 'David'},
        {'name': 'Bob', 'age': 21, 'parent': 'Eve'},
        {'name': 'Carol', 'age': 42, 'parent': 'Frank'},
    ],
    'rowSelection': 'multiple',
}).classes('max-h-40')

def update():
    grid.options['rowData'][0]['age'] += 1
    grid.update()

ui.button('Update', on_click=update)
ui.button('Select all', on_click=lambda: grid.run_grid_method('selectAll'))
ui.button('Show parent', on_click=lambda: grid.run_column_method('setColumnVisible', 'parent', True))

ui.run()


Select AG Grid Rows

You can add checkboxes to grid cells to allow the user to select single or multiple rows.
To retrieve the currently selected rows, use the get_selected_rows method.
This method returns a list of rows as dictionaries.
If rowSelection is set to 'single' or to get the first selected row,
you can also use the get_selected_row method.
This method returns a single row as a dictionary or None if no row is selected.
See the AG Grid documentation for more information.


Coding example:
from nicegui import ui

grid = ui.aggrid({
    'columnDefs': [
        {'headerName': 'Name', 'field': 'name', 'checkboxSelection': True},
        {'headerName': 'Age', 'field': 'age'},
    ],
    'rowData': [
        {'name': 'Alice', 'age': 18},
        {'name': 'Bob', 'age': 21},
        {'name': 'Carol', 'age': 42},
    ],
    'rowSelection': 'multiple',
}).classes('max-h-40')

async def output_selected_rows():
    rows = await grid.get_selected_rows()
    if rows:
        for row in rows:
            ui.notify(f"{row['name']}, {row['age']}")
    else:
        ui.notify('No rows selected.')

async def output_selected_row():
    row = await grid.get_selected_row()
    if row:
        ui.notify(f"{row['name']}, {row['age']}")
    else:
        ui.notify('No row selected!')

ui.button('Output selected rows', on_click=output_selected_rows)
ui.button('Output selected row', on_click=output_selected_row)

ui.run()


Filter Rows using Mini Filters

You can add mini filters to the header of each column to filter the rows.
Note how the "agTextColumnFilter" matches individual characters, like "a" in "Alice" and "Carol",
while the "agNumberColumnFilter" matches the entire number, like "18" and "21", but not "1".


Coding example:
from nicegui import ui

ui.aggrid({
    'columnDefs': [
        {'headerName': 'Name', 'field': 'name', 'filter': 'agTextColumnFilter', 'floatingFilter': True},
        {'headerName': 'Age', 'field': 'age', 'filter': 'agNumberColumnFilter', 'floatingFilter': True},
    ],
    'rowData': [
        {'name': 'Alice', 'age': 18},
        {'name': 'Bob', 'age': 21},
        {'name': 'Carol', 'age': 42},
    ],
}).classes('max-h-40')

ui.run()


AG Grid with Conditional Cell Formatting

This demo shows how to use cellClassRules to conditionally format cells based on their values.


Coding example:
from nicegui import ui

ui.aggrid({
    'columnDefs': [
        {'headerName': 'Name', 'field': 'name'},
        {'headerName': 'Age', 'field': 'age', 'cellClassRules': {
            'bg-red-300': 'x < 21',
            'bg-green-300': 'x >= 21',
        }},
    ],
    'rowData': [
        {'name': 'Alice', 'age': 18},
        {'name': 'Bob', 'age': 21},
        {'name': 'Carol', 'age': 42},
    ],
})

ui.run()


Create Grid from Pandas DataFrame

You can create an AG Grid from a Pandas DataFrame using the from_pandas method.
This method takes a Pandas DataFrame as input and returns an AG Grid.


Coding example:
import pandas as pd
from nicegui import ui

df = pd.DataFrame(data={'col1': [1, 2], 'col2': [3, 4]})
ui.aggrid.from_pandas(df).classes('max-h-40')

ui.run()


Render columns as HTML

You can render columns as HTML by passing a list of column indices to the html_columns argument.


Coding example:
from nicegui import ui

ui.aggrid({
    'columnDefs': [
        {'headerName': 'Name', 'field': 'name'},
        {'headerName': 'URL', 'field': 'url'},
    ],
    'rowData': [
        {'name': 'Google', 'url': '<a href="https://google.com">https://google.com</a>'},
        {'name': 'Facebook', 'url': '<a href="https://facebook.com">https://facebook.com</a>'},
    ],
}, html_columns=[1])

ui.run()


Respond to an AG Grid event

All AG Grid events are passed through to NiceGUI via the AG Grid global listener.
These events can be subscribed to using the .on() method.


Coding example:
from nicegui import ui

ui.aggrid({
    'columnDefs': [
        {'headerName': 'Name', 'field': 'name'},
        {'headerName': 'Age', 'field': 'age'},
    ],
    'rowData': [
        {'name': 'Alice', 'age': 18},
        {'name': 'Bob', 'age': 21},
        {'name': 'Carol', 'age': 42},
    ],
}).on('cellClicked', lambda event: ui.notify(f'Cell value: {event.args["value"]}'))

ui.run()


AG Grid with complex objects

You can use nested complex objects in AG Grid by separating the field names with a period.
(This is the reason why keys in rowData are not allowed to contain periods.)


Coding example:
from nicegui import ui

ui.aggrid({
    'columnDefs': [
        {'headerName': 'First name', 'field': 'name.first'},
        {'headerName': 'Last name', 'field': 'name.last'},
        {'headerName': 'Age', 'field': 'age'}
    ],
    'rowData': [
        {'name': {'first': 'Alice', 'last': 'Adams'}, 'age': 18},
        {'name': {'first': 'Bob', 'last': 'Brown'}, 'age': 21},
        {'name': {'first': 'Carol', 'last': 'Clark'}, 'age': 42},
    ],
}).classes('max-h-40')

ui.run()


AG Grid with dynamic row height

You can set the height of individual rows by passing a function to the getRowHeight argument.


Coding example:
from nicegui import ui

ui.aggrid({
    'columnDefs': [{'field': 'name'}, {'field': 'age'}],
    'rowData': [
        {'name': 'Alice', 'age': '18'},
        {'name': 'Bob', 'age': '21'},
        {'name': 'Carol', 'age': '42'},
    ],
    ':getRowHeight': 'params => params.data.age > 35 ? 50 : 25',
}).classes('max-h-40')

ui.run()


Run row methods

You can run methods on individual rows by using the run_row_method method.
This method takes the row ID, the method name and the method arguments as arguments.
The row ID is either the row index (as a string) or the value of the getRowId function.
The following demo shows how to use it to update cell values.
Note that the row selection is preserved when the value is updated.
This would not be the case if the grid was updated using the update method.


Coding example:
from nicegui import ui

grid = ui.aggrid({
    'columnDefs': [
        {'field': 'name', 'checkboxSelection': True},
        {'field': 'age'},
    ],
    'rowData': [
        {'name': 'Alice', 'age': 18},
        {'name': 'Bob', 'age': 21},
        {'name': 'Carol', 'age': 42},
    ],
    ':getRowId': '(params) => params.data.name',
})
ui.button('Update',
          on_click=lambda: grid.run_row_method('Alice', 'setDataValue', 'age', 99))

ui.run()


Filter return values

You can filter the return values of method calls by passing string that defines a JavaScript function.
This demo runs the grid method "getDisplayedRowAtIndex" and returns the "data" property of the result.


Coding example:
from nicegui import ui

grid = ui.aggrid({
    'columnDefs': [{'field': 'name'}],
    'rowData': [{'name': 'Alice'}, {'name': 'Bob'}],
})

async def get_first_name() -> None:
    row = await grid.run_grid_method('(g) => g.getDisplayedRowAtIndex(0).data')
    ui.notify(row['name'])

ui.button('Get First Name', on_click=get_first_name)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

options : Dict


The options dictionary.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

call_api_method (name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


DEPRECATED: Use run_grid_method instead.

call_column_method (name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


DEPRECATED: Use run_column_method instead.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

@classmethod from_pandas (df: pd.DataFrame, theme: str = 'balham', auto_size_columns: bool = True, options: Dict = {}) -> Self


Create an AG Grid from a Pandas DataFrame.
Note:
If the DataFrame contains non-serializable columns of type datetime64[ns] , timedelta64[ns] , complex128 or period[M] ,
they will be converted to strings.
To use a different conversion, convert the DataFrame manually before passing it to this method.
See issue 1698 for more information.

param df: Pandas DataFrame
param theme: AG Grid theme (default: 'balham')
param auto_size_columns:
 whether to automatically resize columns to fit the grid width (default: True)
param options: dictionary of additional AG Grid options
return: AG Grid element

get_client_data (timeout: float = 1, check_interval: float = 0.01) -> List[Dict]


Get the data from the client including any edits made by the client.
This method is especially useful when the grid is configured with 'editable': True .
See AG Grid API for more information.
Note that when editing a cell, the row data is not updated until the cell exits the edit mode.
This does not happen when the cell loses focus, unless stopEditingWhenCellsLoseFocus: True is set.

param timeout: timeout in seconds (default: 1 second)
return: list of row data

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

get_selected_row () -> Optional[Dict]


Get the single currently selected row.
This method is especially useful when the grid is configured with rowSelection: 'single' .

return: row data of the first selection if any row is selected, otherwise None

get_selected_rows () -> List[Dict]


Get the currently selected rows.
This method is especially useful when the grid is configured with rowSelection: 'multiple' .
See AG Grid API for more information.

return: list of selected row data

load_client_data () -> None


Obtain client data and update the element's row data with it.
This syncs edits made by the client in editable cells to the server.
Note that when editing a cell, the row data is not updated until the cell exits the edit mode.
This does not happen when the cell loses focus, unless stopEditingWhenCellsLoseFocus: True is set.

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_column_method (name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


Run an AG Grid Column API method.
See AG Grid Column API for a list of methods.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: timeout in seconds (default: 1 second)
return: AwaitableResponse that can be awaited to get the result of the method call

run_grid_method (name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


Run an AG Grid API method.
See AG Grid API for a list of methods.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: timeout in seconds (default: 1 second)
return: AwaitableResponse that can be awaited to get the result of the method call

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

run_row_method (row_id: str, name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


Run an AG Grid API method on a specific row.
See AG Grid Row Reference for a list of methods.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param row_id: id of the row (as defined by the getRowId option)
param name: name of the method
param args: arguments to pass to the method
param timeout: timeout in seconds (default: 1 second)
return: AwaitableResponse that can be awaited to get the result of the method call

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Inheritance

Element
Visibility




____________________________________________________________
Section: 54. URL: http://localhost:8080/documentation/echart

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.echart Apache EChart EChart with clickable points EChart with dynamic properties EChart from pyecharts Run methods Arbitrary chart events 3D Graphing Reference Properties Methods Inheritance


ui. echart


Apache EChart


An element to create a chart using ECharts .
Updates can be pushed to the chart by changing the options property.
After data has changed, call the update method to refresh the chart.

options: dictionary of EChart options
on_click_point: callback that is invoked when a point is clicked
enable_3d: enforce importing the echarts-gl library


Coding example:
from nicegui import ui
from random import random

echart = ui.echart({
    'xAxis': {'type': 'value'},
    'yAxis': {'type': 'category', 'data': ['A', 'B'], 'inverse': True},
    'legend': {'textStyle': {'color': 'gray'}},
    'series': [
        {'type': 'bar', 'name': 'Alpha', 'data': [0.1, 0.2]},
        {'type': 'bar', 'name': 'Beta', 'data': [0.3, 0.4]},
    ],
})

def update():
    echart.options['series'][0]['data'][0] = random()
    echart.update()

ui.button('Update', on_click=update)

ui.run()


EChart with clickable points

You can register a callback for an event when a series point is clicked.


Coding example:
from nicegui import ui

ui.echart({
    'xAxis': {'type': 'category'},
    'yAxis': {'type': 'value'},
    'series': [{'type': 'line', 'data': [20, 10, 30, 50, 40, 30]}],
}, on_point_click=ui.notify)

ui.run()


EChart with dynamic properties

Dynamic properties can be passed to chart elements to customize them such as apply an axis label format.
To make a property dynamic, prefix a colon ":" to the property name.


Coding example:
from nicegui import ui

ui.echart({
    'xAxis': {'type': 'category'},
    'yAxis': {'axisLabel': {':formatter': 'value => "$" + value'}},
    'series': [{'type': 'line', 'data': [5, 8, 13, 21, 34, 55]}],
})

ui.run()


EChart from pyecharts

You can create an EChart element from a pyecharts object using the from_pyecharts method.
For defining dynamic options like a formatter function, you can use the JsCode class from pyecharts.commons.utils .
Alternatively, you can use a colon ":" to prefix the property name to indicate that the value is a JavaScript expression.


Coding example:
from nicegui import ui
from pyecharts.charts import Bar
from pyecharts.commons.utils import JsCode
from pyecharts.options import AxisOpts

ui.echart.from_pyecharts(
    Bar()
    .add_xaxis(['A', 'B', 'C'])
    .add_yaxis('ratio', [1, 2, 4])
    .set_global_opts(
        xaxis_opts=AxisOpts(axislabel_opts={
            ':formatter': r'(val, idx) => `group ${val}`',
        }),
        yaxis_opts=AxisOpts(axislabel_opts={
            'formatter': JsCode(r'(val, idx) => `${val}%`'),
        }),
    )
)

ui.run()


Run methods

You can run methods of the EChart instance using the run_chart_method method.
This demo shows how to show and hide the loading animation, how to get the current width of the chart,
and how to add tooltips with a custom formatter.
The colon ":" in front of the method name "setOption" indicates that the argument is a JavaScript expression
that is evaluated on the client before it is passed to the method.


Coding example:
from nicegui import ui

echart = ui.echart({
    'xAxis': {'type': 'category', 'data': ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']},
    'yAxis': {'type': 'value'},
    'series': [{'type': 'line', 'data': [150, 230, 224, 218, 135]}],
})

ui.button('Show Loading', on_click=lambda: echart.run_chart_method('showLoading'))
ui.button('Hide Loading', on_click=lambda: echart.run_chart_method('hideLoading'))

async def get_width():
    width = await echart.run_chart_method('getWidth')
    ui.notify(f'Width: {width}')
ui.button('Get Width', on_click=get_width)

ui.button('Set Tooltip', on_click=lambda: echart.run_chart_method(
    ':setOption', r'{tooltip: {formatter: params => "$" + params.value}}',
))

ui.run()


Arbitrary chart events

You can register arbitrary event listeners for the chart using the on method and a "chart:" prefix.
This demo shows how to register a callback for the "selectchanged" event which is triggered when the user selects a point.


Coding example:
from nicegui import ui

ui.echart({
    'toolbox': {'feature': {'brush': {'type': ['rect']}}},
    'brush': {},
    'xAxis': {'type': 'category'},
    'yAxis': {'type': 'value'},
    'series': [{'type': 'line', 'data': [1, 2, 3]}],
}).on('chart:selectchanged', lambda e: label.set_text(
    f'Selected point {e.args["fromActionPayload"]["dataIndexInside"]}'
))
label = ui.label()

ui.run()


3D Graphing

Charts will automatically be 3D enabled if the initial options contain the string "3D".
If not, set the enable_3d argument to True .


Coding example:
from nicegui import ui

ui.echart({
    'xAxis3D': {},
    'yAxis3D': {},
    'zAxis3D': {},
    'grid3D': {},
    'series': [{
        'type': 'line3D',
        'data': [[1, 1, 1], [3, 3, 3]],
    }],
})

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

options : Dict


The options dictionary.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

@classmethod from_pyecharts (chart: Chart, on_point_click: Optional[Callable] = None) -> Self


Create an echart element from a pyecharts object.

param chart: pyecharts chart object
param on_click_point:
 callback which is invoked when a point is clicked
return: echart element

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_point_click (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a point is clicked.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_chart_method (name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


Run a method of the JSONEditor instance.
See the ECharts documentation for a list of methods.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method (a prefix ":" indicates that the arguments are JavaScript expressions)
param args: arguments to pass to the method (Python objects or JavaScript expressions)
param timeout: timeout in seconds (default: 1 second)
return: AwaitableResponse that can be awaited to get the result of the method call

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Inheritance

Element
Visibility




____________________________________________________________
Section: 55. URL: http://localhost:8080/documentation/pyplot

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.pyplot Pyplot Context Reference Properties Methods Inheritance


ui. pyplot


Pyplot Context


Create a context to configure a Matplotlib plot.

close: whether the figure should be closed after exiting the context; set to False if you want to update it later (default: True)
kwargs: arguments like figsize which should be passed to pyplot.figure


Coding example:
import numpy as np
from matplotlib import pyplot as plt
from nicegui import ui

with ui.pyplot(figsize=(3, 2)):
    x = np.linspace(0.0, 5.0)
    y = np.cos(2 * np.pi * x) * np.exp(-x)
    plt.plot(x, y, '-')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 56. URL: http://localhost:8080/documentation/matplotlib

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.matplotlib Matplotlib Reference Properties Methods Inheritance


ui. matplotlib


Matplotlib


Create a Matplotlib element rendering a Matplotlib figure.
The figure is automatically updated when leaving the figure context.

kwargs: arguments like figsize which should be passed to matplotlib.figure.Figure


Coding example:
import numpy as np
from nicegui import ui

with ui.matplotlib(figsize=(3, 2)).figure as fig:
    x = np.linspace(0.0, 5.0)
    y = np.cos(2 * np.pi * x) * np.exp(-x)
    ax = fig.gca()
    ax.plot(x, y, '-')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Inheritance

Element
Visibility




____________________________________________________________
Section: 57. URL: http://localhost:8080/documentation/line_plot

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.line_plot Line Plot Reference Properties Methods Inheritance


ui. line_plot


Line Plot


Create a line plot using pyplot.
The push method provides live updating when utilized in combination with ui.timer .

n: number of lines
limit: maximum number of datapoints per line (new points will displace the oldest)
update_every: update plot only after pushing new data multiple times to save CPU and bandwidth
close: whether the figure should be closed after exiting the context; set to False if you want to update it later (default: True)
kwargs: arguments like figsize which should be passed to pyplot.figure


Coding example:
import math
from datetime import datetime
from nicegui import ui

line_plot = ui.line_plot(n=2, limit=20, figsize=(3, 2), update_every=5) \
    .with_legend(['sin', 'cos'], loc='upper center', ncol=2)

def update_line_plot() -> None:
    now = datetime.now()
    x = now.timestamp()
    y1 = math.sin(x)
    y2 = math.cos(x)
    line_plot.push([now], [[y1], [y2]])

line_updates = ui.timer(0.1, update_line_plot, active=False)
line_checkbox = ui.checkbox('active').bind_value(line_updates, 'active')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Clear the line plot.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

push (x: List[float], Y: List[List[float]]) -> None


Push new data to the plot.

param x: list of x values
param Y: list of lists of y values (one list per line)

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.

with_legend (titles: List[str], kwargs: Any)


Add a legend to the plot.

param titles: list of titles for the lines
param kwargs: additional arguments which should be passed to pyplot.legend


Inheritance

Pyplot
Element
Visibility




____________________________________________________________
Section: 58. URL: http://localhost:8080/documentation/plotly

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.plotly Plotly Element Dictionary interface Plot updates Plot events Reference Properties Methods Inheritance


ui. plotly


Plotly Element


Renders a Plotly chart.
There are two ways to pass a Plotly figure for rendering, see parameter figure :
Pass a go.Figure object, see https://plotly.com/python/
Pass a Python dict object with keys data , layout , config (optional), see https://plotly.com/javascript/
For best performance, use the declarative dict approach for creating a Plotly chart.

figure: Plotly figure to be rendered. Can be either a go.Figure instance, or
a dict object with keys data, layout, config (optional).


Coding example:
import plotly.graph_objects as go
from nicegui import ui

fig = go.Figure(go.Scatter(x=[1, 2, 3, 4], y=[1, 2, 3, 2.5]))
fig.update_layout(margin=dict(l=0, r=0, t=0, b=0))
ui.plotly(fig).classes('w-full h-40')

ui.run()


Dictionary interface

This demo shows how to use the declarative dictionary interface to create a plot.
For plots with many traces and data points, this is more efficient than the object-oriented interface.
The definition corresponds to the JavaScript Plotly API .
Due to different defaults, the resulting plot may look slightly different from the same plot created with the object-oriented interface,
but the functionality is the same.


Coding example:
from nicegui import ui

fig = {
    'data': [
        {
            'type': 'scatter',
            'name': 'Trace 1',
            'x': [1, 2, 3, 4],
            'y': [1, 2, 3, 2.5],
        },
        {
            'type': 'scatter',
            'name': 'Trace 2',
            'x': [1, 2, 3, 4],
            'y': [1.4, 1.8, 3.8, 3.2],
            'line': {'dash': 'dot', 'width': 3},
        },
    ],
    'layout': {
        'margin': {'l': 15, 'r': 0, 't': 0, 'b': 15},
        'plot_bgcolor': '#E5ECF6',
        'xaxis': {'gridcolor': 'white'},
        'yaxis': {'gridcolor': 'white'},
    },
}
ui.plotly(fig).classes('w-full h-40')

ui.run()


Plot updates

This demo shows how to update the plot in real time.
Click the button to add a new trace to the plot.
To send the new plot to the browser, make sure to explicitly call plot.update() or ui.update(plot) .


Coding example:
import plotly.graph_objects as go
from nicegui import ui
from random import random

fig = go.Figure()
fig.update_layout(margin=dict(l=0, r=0, t=0, b=0))
plot = ui.plotly(fig).classes('w-full h-40')

def add_trace():
    fig.add_trace(go.Scatter(x=[1, 2, 3], y=[random(), random(), random()]))
    plot.update()

ui.button('Add trace', on_click=add_trace)

ui.run()


Plot events

This demo shows how to handle Plotly events.
Try clicking on a data point to see the event data.
Currently, the following events are supported:
"plotly_click",
"plotly_legendclick",
"plotly_selecting",
"plotly_selected",
"plotly_hover",
"plotly_unhover",
"plotly_legenddoubleclick",
"plotly_restyle",
"plotly_relayout",
"plotly_webglcontextlost",
"plotly_afterplot",
"plotly_autosize",
"plotly_deselect",
"plotly_doubleclick",
"plotly_redraw",
"plotly_animated".
For more information, see the Plotly documentation .


Coding example:
import plotly.graph_objects as go
from nicegui import ui

fig = go.Figure(go.Scatter(x=[1, 2, 3, 4], y=[1, 2, 3, 2.5]))
fig.update_layout(margin=dict(l=0, r=0, t=0, b=0))
plot = ui.plotly(fig).classes('w-full h-40')
plot.on('plotly_click', ui.notify)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None

update_figure (figure: Union[Dict, go.Figure])


Overrides figure instance of this Plotly chart and updates chart on client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 59. URL: http://localhost:8080/documentation/linear_progress

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.linear_progress Linear Progress Reference Properties Methods Inheritance


ui. linear_progress


Linear Progress


A linear progress bar wrapping Quasar's QLinearProgress component.

value: the initial value of the field (from 0.0 to 1.0)
size: the height of the progress bar (default: "20px" with value label and "4px" without)
show_value: whether to show a value label in the center (default: True)
color: color (either a Quasar, Tailwind, or CSS color or None, default: "primary")


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=1, step=0.01, value=0.5)
ui.linear_progress().bind_value_from(slider, 'value')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
TextColorElement
Element
Visibility




____________________________________________________________
Section: 60. URL: http://localhost:8080/documentation/circular_progress

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.circular_progress Circular Progress Nested Elements Reference Properties Methods Inheritance


ui. circular_progress


Circular Progress


A circular progress bar wrapping Quasar's QCircularProgress .

value: the initial value of the field
min: the minimum value (default: 0.0)
max: the maximum value (default: 1.0)
size: the size of the progress circle (default: "xl")
show_value: whether to show a value label in the center (default: True)
color: color (either a Quasar, Tailwind, or CSS color or None, default: "primary")


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=1, step=0.01, value=0.5)
ui.circular_progress().bind_value_from(slider, 'value')

ui.run()


Nested Elements

You can put any element like icon, button etc inside a circular progress using the with statement.
Just make sure it fits the bounds and disable the default behavior of showing the value.


Coding example:
from nicegui import ui

with ui.row().classes('items-center m-auto'):
    with ui.circular_progress(value=0.1, show_value=False) as progress:
        ui.button(
            icon='star',
            on_click=lambda: progress.set_value(progress.value + 0.1)
        ).props('flat round')
    ui.label('click to increase progress')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
TextColorElement
Element
Visibility




____________________________________________________________
Section: 61. URL: http://localhost:8080/documentation/spinner

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.spinner Spinner Reference Properties Methods Inheritance


ui. spinner


Spinner


This element is based on Quasar's QSpinner component.

type: type of spinner (e.g. "audio", "ball", "bars", ..., default: "default")
size: size of the spinner (e.g. "3em", "10px", "xl", ..., default: "1em")
color: color of the spinner (either a Quasar, Tailwind, or CSS color or None, default: "primary")
thickness: thickness of the spinner (applies to the "default" spinner only, default: 5.0)


Coding example:
from nicegui import ui

with ui.row():
    ui.spinner(size='lg')
    ui.spinner('audio', size='lg', color='green')
    ui.spinner('dots', size='lg', color='red')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextColorElement
Element
Visibility




____________________________________________________________
Section: 62. URL: http://localhost:8080/documentation/scene

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.scene 3D Scene Handling Click Events Draggable objects Rendering point clouds Wait for Initialization Scene View Camera Parameters Custom Background Custom Grid Reference Properties Methods Inheritance


ui. scene


3D Scene


Display a 3D scene using three.js .
Currently NiceGUI supports boxes, spheres, cylinders/cones, extrusions, straight lines, curves and textured meshes.
Objects can be translated, rotated and displayed with different color, opacity or as wireframes.
They can also be grouped to apply joint movements.

width: width of the canvas
height: height of the canvas
grid: whether to display a grid (boolean or tuple of size and divisions for Three.js' GridHelper, default: 100x100)
camera: camera definition, either instance of ui.scene.perspective_camera (default) or ui.scene.orthographic_camera
on_click: callback to execute when a 3D object is clicked
on_drag_start: callback to execute when a 3D object is dragged
on_drag_end: callback to execute when a 3D object is dropped
drag_constraints:
 comma-separated JavaScript expression for constraining positions of dragged objects (e.g. 'x = 0, z = y / 2')
background_color:
 background color of the scene (default: "#eee")


Coding example:
from nicegui import ui

with ui.scene().classes('w-full h-64') as scene:
    scene.sphere().material('#4488ff')
    scene.cylinder(1, 0.5, 2, 20).material('#ff8800', opacity=0.5).move(-2, 1)
    scene.extrusion([[0, 0], [0, 1], [1, 0.5]], 0.1).material('#ff8888').move(2, -1)

    with scene.group().move(z=2):
        scene.box().move(x=2)
        scene.box().move(y=2).rotate(0.25, 0.5, 0.75)
        scene.box(wireframe=True).material('#888888').move(x=2, y=2)

    scene.line([-4, 0, 0], [-4, 2, 0]).material('#ff0000')
    scene.curve([-4, 0, 0], [-4, -1, 0], [-3, -1, 0], [-3, 0, 0]).material('#008800')

    logo = 'https://avatars.githubusercontent.com/u/2843826'
    scene.texture(logo, [[[0.5, 2, 0], [2.5, 2, 0]],
                         [[0.5, 0, 0], [2.5, 0, 0]]]).move(1, -3)

    teapot = 'https://upload.wikimedia.org/wikipedia/commons/9/93/Utah_teapot_(solid).stl'
    scene.stl(teapot).scale(0.2).move(-3, 4)

    avocado = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/Avocado/glTF-Binary/Avocado.glb'
    scene.gltf(avocado).scale(40).move(-2, -3, 0.5)

    scene.text('2D', 'background: rgba(0, 0, 0, 0.2); border-radius: 5px; padding: 5px').move(z=2)
    scene.text3d('3D', 'background: rgba(0, 0, 0, 0.2); border-radius: 5px; padding: 5px').move(y=-2).scale(.05)

ui.run()


Handling Click Events

You can use the on_click argument to ui.scene to handle click events.
The callback receives a SceneClickEventArguments object with the following attributes:
click_type : the type of click ("click" or "dblclick").
button : the button that was clicked (1, 2, or 3).
alt , ctrl , meta , shift : whether the alt, ctrl, meta, or shift key was pressed.
hits : a list of SceneClickEventHit objects, sorted by distance from the camera.
The SceneClickEventHit object has the following attributes:
object_id : the id of the object that was clicked.
object_name : the name of the object that was clicked.
x , y , z : the x, y and z coordinates of the click.


Coding example:
from nicegui import events, ui

def handle_click(e: events.SceneClickEventArguments):
    hit = e.hits[0]
    name = hit.object_name or hit.object_id
    ui.notify(f'You clicked on the {name} at ({hit.x:.2f}, {hit.y:.2f}, {hit.z:.2f})')

with ui.scene(width=285, height=220, on_click=handle_click) as scene:
    scene.sphere().move(x=-1, z=1).with_name('sphere')
    scene.box().move(x=1, z=1).with_name('box')

ui.run()


Draggable objects

You can make objects draggable using the .draggable method.
There is an optional on_drag_start and on_drag_end argument to ui.scene to handle drag events.
The callbacks receive a SceneDragEventArguments object with the following attributes:
type : the type of drag event ("dragstart" or "dragend").
object_id : the id of the object that was dragged.
object_name : the name of the object that was dragged.
x , y , z : the x, y and z coordinates of the dragged object.
You can also use the drag_constraints argument to set comma-separated JavaScript expressions
for constraining positions of dragged objects.


Coding example:
from nicegui import events, ui

def handle_drag(e: events.SceneDragEventArguments):
    ui.notify(f'You dropped the sphere at ({e.x:.2f}, {e.y:.2f}, {e.z:.2f})')

with ui.scene(width=285, height=220,
              drag_constraints='z = 1', on_drag_end=handle_drag) as scene:
    sphere = scene.sphere().move(z=1).draggable()

ui.switch('draggable sphere',
          value=sphere.draggable_,
          on_change=lambda e: sphere.draggable(e.value))

ui.run()


Rendering point clouds

You can render point clouds using the point_cloud method.
The points argument is a list of point coordinates, and the colors argument is a list of RGB colors (0..1).


Coding example:
import numpy as np
from nicegui import ui

with ui.scene().classes('w-full h-64') as scene:
    x, y = np.meshgrid(np.linspace(-3, 3), np.linspace(-3, 3))
    z = np.sin(x) * np.cos(y) + 1
    points = np.dstack([x, y, z]).reshape(-1, 3)
    scene.point_cloud(points=points, colors=points, point_size=0.1)

ui.run()


Wait for Initialization

You can wait for the scene to be initialized with the initialized method.
This demo animates a camera movement after the scene has been fully loaded.


Coding example:
from nicegui import ui

with ui.scene(width=285, height=220) as scene:
    scene.sphere()
    await scene.initialized()
    scene.move_camera(x=1, y=-1, z=1.5, duration=2)

ui.run()


Scene View


Display an additional view of a 3D scene using three.js .
This component can only show a scene and not modify it.
You can, however, independently move the camera.
Current limitation: 2D and 3D text objects are not supported and will not be displayed in the scene view.

scene: the scene which will be shown on the canvas
width: width of the canvas
height: height of the canvas
camera: camera definition, either instance of ui.scene.perspective_camera (default) or ui.scene.orthographic_camera
on_click: callback to execute when a 3D object is clicked


Coding example:
from nicegui import ui

with ui.grid(columns=2).classes('w-full'):
    with ui.scene().classes('h-64 col-span-2') as scene:
        teapot = 'https://upload.wikimedia.org/wikipedia/commons/9/93/Utah_teapot_(solid).stl'
        scene.stl(teapot).scale(0.3)

    with ui.scene_view(scene).classes('h-32') as scene_view1:
        scene_view1.move_camera(x=1, y=-3, z=5)

    with ui.scene_view(scene).classes('h-32') as scene_view2:
        scene_view2.move_camera(x=0, y=4, z=3)

ui.run()


Camera Parameters

You can use the camera argument to ui.scene to use a custom camera.
This allows you to set the field of view of a perspective camera or the size of an orthographic camera.


Coding example:
from nicegui import ui

with ui.scene(camera=ui.scene.orthographic_camera(size=2)) \
        .classes('w-full h-64') as scene:
    scene.box()

ui.run()


Custom Background

You can set a custom background color using the background_color parameter of ui.scene .


Coding example:
from nicegui import ui

with ui.scene(background_color='#222').classes('w-full h-64') as scene:
    scene.box()

ui.run()


Custom Grid

You can set custom grid parameters using the grid parameter of ui.scene .
It accepts a tuple of two integers, the first one for the grid size and the second one for the number of divisions.


Coding example:
from nicegui import ui

with ui.scene(grid=(3, 2)).classes('w-full h-64') as scene:
    scene.sphere()

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all objects from the scene.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

delete_objects (predicate: Callable[[nicegui.elements.scene_object3d.Object3D], bool] = [...]) -> None


Remove objects from the scene.

param predicate:
 function which returns True for objects which should be deleted

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

initialized () -> None


Wait until the scene is initialized.

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

move_camera (x: Optional[float] = None, y: Optional[float] = None, z: Optional[float] = None, look_at_x: Optional[float] = None, look_at_y: Optional[float] = None, look_at_z: Optional[float] = None, up_x: Optional[float] = None, up_y: Optional[float] = None, up_z: Optional[float] = None, duration: float = 0.5) -> None


Move the camera to a new position.

param x: camera x position
param y: camera y position
param z: camera z position
param look_at_x:
 camera look-at x position
param look_at_y:
 camera look-at y position
param look_at_z:
 camera look-at z position
param up_x: x component of the camera up vector
param up_y: y component of the camera up vector
param up_z: z component of the camera up vector
param duration: duration of the movement in seconds (default: 0.5)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_click (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a 3D object is clicked.

on_drag_end (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a 3D object is dropped.

on_drag_start (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a 3D object is dragged.

@staticmethod orthographic_camera (size: float = 10, near: float = 0.1, far: float = 1000) -> nicegui.elements.scene.SceneCamera


Create a orthographic camera.
The size defines the vertical size of the view volume, i.e. the distance between the top and bottom clipping planes.
The left and right clipping planes are set such that the aspect ratio matches the viewport.

param size: vertical size of the view volume
param near: near clipping plane
param far: far clipping plane

@staticmethod perspective_camera (fov: float = 75, near: float = 0.1, far: float = 1000) -> nicegui.elements.scene.SceneCamera


Create a perspective camera.

param fov: vertical field of view in degrees
param near: near clipping plane
param far: far clipping plane

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 63. URL: http://localhost:8080/documentation/leaflet

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.leaflet Leaflet map Changing the Map Style Add Markers on Click Move Markers Vector Layers Disable Pan and Zoom Draw on Map Run Map Methods Run Layer Methods Wait for Initialization Reference Properties Methods Inheritance


ui. leaflet


Leaflet map


This element is a wrapper around the Leaflet JavaScript library.

center: initial center location of the map (latitude/longitude, default: (0.0, 0.0))
zoom: initial zoom level of the map (default: 13)
draw_control: whether to show the draw toolbar (default: False)
options: additional options passed to the Leaflet map (default: {})


Coding example:
from nicegui import ui

m = ui.leaflet(center=(51.505, -0.09))
ui.label().bind_text_from(m, 'center', lambda center: f'Center: {center[0]:.3f}, {center[1]:.3f}')
ui.label().bind_text_from(m, 'zoom', lambda zoom: f'Zoom: {zoom}')

with ui.grid(columns=2):
    ui.button('London', on_click=lambda: m.set_center((51.505, -0.090)))
    ui.button('Berlin', on_click=lambda: m.set_center((52.520, 13.405)))
    ui.button(icon='zoom_in', on_click=lambda: m.set_zoom(m.zoom + 1))
    ui.button(icon='zoom_out', on_click=lambda: m.set_zoom(m.zoom - 1))

ui.run()


Changing the Map Style

The default map style is OpenStreetMap.
You can find more map styles at https://leaflet-extras.github.io/leaflet-providers/preview/ .
Each call to tile_layer stacks upon the previous ones.
So if you want to change the map style, you have to remove the default one first.


Coding example:
from nicegui import ui

m = ui.leaflet(center=(51.505, -0.090), zoom=3)
m.clear_layers()
m.tile_layer(
    url_template=r'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
    options={
        'maxZoom': 17,
        'attribution':
            'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="https://viewfinderpanoramas.org/">SRTM</a> | '
            'Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
    },
)

ui.run()


Add Markers on Click

You can add markers to the map with marker .
The center argument is a tuple of latitude and longitude.
This demo adds markers by clicking on the map.
Note that the "map-click" event refers to the click event of the map object,
while the "click" event refers to the click event of the container div.


Coding example:
from nicegui import events, ui

m = ui.leaflet(center=(51.505, -0.09))

def handle_click(e: events.GenericEventArguments):
    lat = e.args['latlng']['lat']
    lng = e.args['latlng']['lng']
    m.marker(latlng=(lat, lng))
m.on('map-click', handle_click)

ui.run()


Move Markers

You can move markers with the move method.


Coding example:
from nicegui import ui

m = ui.leaflet(center=(51.505, -0.09))
marker = m.marker(latlng=m.center)
ui.button('Move marker', on_click=lambda: marker.move(51.51, -0.09))

ui.run()


Vector Layers

Leaflet supports a set of vector layers like circle, polygon etc.
These can be added with the generic_layer method.
We are happy to review any pull requests to add more specific layers to simplify usage.


Coding example:
from nicegui import ui

m = ui.leaflet(center=(51.505, -0.09)).classes('h-32')
m.generic_layer(name='circle', args=[m.center, {'color': 'red', 'radius': 300}])

ui.run()


Disable Pan and Zoom

There are several options to configure the map in Leaflet .
This demo disables the pan and zoom controls.


Coding example:
from nicegui import ui

options = {
    'zoomControl': False,
    'scrollWheelZoom': False,
    'doubleClickZoom': False,
    'boxZoom': False,
    'keyboard': False,
    'dragging': False,
}
ui.leaflet(center=(51.505, -0.09), options=options)

ui.run()


Draw on Map

You can enable a toolbar to draw on the map.
The draw_control can be used to configure the toolbar.
This demo adds markers and polygons by clicking on the map.


Coding example:
from nicegui import events, ui

def handle_draw(e: events.GenericEventArguments):
    if e.args['layerType'] == 'marker':
        m.marker(latlng=(e.args['layer']['_latlng']['lat'],
                         e.args['layer']['_latlng']['lng']))
    if e.args['layerType'] == 'polygon':
        m.generic_layer(name='polygon', args=[e.args['layer']['_latlngs']])

draw_control = {
    'draw': {
        'polygon': True,
        'marker': True,
        'circle': False,
        'rectangle': False,
        'polyline': False,
        'circlemarker': False,
    },
    'edit': False,
}
m = ui.leaflet(center=(51.505, -0.09), zoom=13, draw_control=draw_control)
m.on('draw:created', handle_draw)

ui.run()


Run Map Methods

You can run methods of the Leaflet map object with run_map_method .
This demo shows how to fit the map to the whole world.


Coding example:
from nicegui import ui

m = ui.leaflet(center=(51.505, -0.09)).classes('h-32')
ui.button('Fit world', on_click=lambda: m.run_map_method('fitWorld'))

ui.run()


Run Layer Methods

You can run methods of the Leaflet layer objects with run_layer_method .
This demo shows how to change the opacity of a marker or change its icon.


Coding example:
from nicegui import ui

m = ui.leaflet(center=(51.505, -0.09)).classes('h-32')
marker = m.marker(latlng=m.center)
ui.button('Hide', on_click=lambda: marker.run_method('setOpacity', 0.3))
ui.button('Show', on_click=lambda: marker.run_method('setOpacity', 1.0))

icon = 'L.icon({iconUrl: "https://leafletjs.com/examples/custom-icons/leaf-green.png"})'
ui.button('Change icon', on_click=lambda: marker.run_method(':setIcon', icon))

ui.run()


Wait for Initialization

You can wait for the map to be initialized with the initialized method.
This is necessary when you want to run methods like fitting the bounds of the map right after the map is created.


Coding example:
from nicegui import ui

m = ui.leaflet(zoom=5)
central_park = m.generic_layer(name='polygon', args=[[
    (40.767809, -73.981249),
    (40.800273, -73.958291),
    (40.797011, -73.949683),
    (40.764704, -73.973741),
]])
await m.initialized()
bounds = await central_park.run_method('getBounds')
m.run_map_method('fitBounds', [[bounds['_southWest'], bounds['_northEast']]])

ui.run()


Reference


Properties


center : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty

zoom : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

clear_layers () -> None


Remove all layers from the map.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

initialized () -> None


Wait until the map is initialized.

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

remove_layer (layer: nicegui.elements.leaflet_layer.Layer) -> None


Remove a layer from the map.

run_layer_method (layer_id: str, name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


Run a method of a Leaflet layer.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param layer_id: ID of the layer
param name: name of the method (a prefix ":" indicates that the arguments are JavaScript expressions)
param args: arguments to pass to the method
param timeout: timeout in seconds (default: 1 second)
return: AwaitableResponse that can be awaited to get the result of the method call

run_map_method (name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


Run a method of the Leaflet map instance.
Refer to the Leaflet documentation for a list of methods.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method (a prefix ":" indicates that the arguments are JavaScript expressions)
param args: arguments to pass to the method
param timeout: timeout in seconds (default: 1 second)
return: AwaitableResponse that can be awaited to get the result of the method call

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse

set_center (center: Tuple[float, float]) -> None


Set the center location of the map.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

set_zoom (zoom: int) -> None


Set the zoom level of the map.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 64. URL: http://localhost:8080/documentation/tree

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.tree Tree Tree with custom header and body Expand and collapse programmatically Tree with checkboxes Reference Properties Methods Inheritance


ui. tree


Tree


Display hierarchical data using Quasar's QTree component.
If using IDs, make sure they are unique within the whole tree.
To use checkboxes and on_tick , set the tick_strategy parameter to "leaf", "leaf-filtered" or "strict".

nodes: hierarchical list of node objects
node_key: property name of each node object that holds its unique id (default: "id")
label_key: property name of each node object that holds its label (default: "label")
children_key: property name of each node object that holds its list of children (default: "children")
on_select: callback which is invoked when the node selection changes
on_expand: callback which is invoked when the node expansion changes
on_tick: callback which is invoked when a node is ticked or unticked
tick_strategy: whether and how to use checkboxes ("leaf", "leaf-filtered" or "strict"; default: None)


Coding example:
from nicegui import ui

ui.tree([
    {'id': 'numbers', 'children': [{'id': '1'}, {'id': '2'}]},
    {'id': 'letters', 'children': [{'id': 'A'}, {'id': 'B'}]},
], label_key='id', on_select=lambda e: ui.notify(e.value))

ui.run()


Tree with custom header and body

Scoped slots can be used to insert custom content into the header and body of a tree node.
See the Quasar documentation for more information.


Coding example:
from nicegui import ui

tree = ui.tree([
    {'id': 'numbers', 'description': 'Just some numbers', 'children': [
        {'id': '1', 'description': 'The first number'},
        {'id': '2', 'description': 'The second number'},
    ]},
    {'id': 'letters', 'description': 'Some latin letters', 'children': [
        {'id': 'A', 'description': 'The first letter'},
        {'id': 'B', 'description': 'The second letter'},
    ]},
], label_key='id', on_select=lambda e: ui.notify(e.value))

tree.add_slot('default-header', '''
    <span :props="props">Node <strong>{{ props.node.id }}</strong></span>
''')
tree.add_slot('default-body', '''
    <span :props="props">Description: "{{ props.node.description }}"</span>
''')

ui.run()


Expand and collapse programmatically

The whole tree or individual nodes can be toggled programmatically using the expand() and collapse() methods.
This even works if a node is disabled (e.g. not clickable by the user).


Coding example:
from nicegui import ui

t = ui.tree([
    {'id': 'A', 'children': [{'id': 'A1'}, {'id': 'A2'}], 'disabled': True},
    {'id': 'B', 'children': [{'id': 'B1'}, {'id': 'B2'}]},
], label_key='id').expand()

with ui.row():
    ui.button('+ all', on_click=t.expand)
    ui.button('- all', on_click=t.collapse)
    ui.button('+ A', on_click=lambda: t.expand(['A']))
    ui.button('- A', on_click=lambda: t.collapse(['A']))

ui.run()


Tree with checkboxes

The tree can be used with checkboxes by setting the "tick-strategy" prop.


Coding example:
from nicegui import ui

ui.tree([
    {'id': 'A', 'children': [{'id': 'A1'}, {'id': 'A2'}]},
    {'id': 'B', 'children': [{'id': 'B1'}, {'id': 'B2'}]},
], label_key='id', tick_strategy='leaf', on_tick=lambda e: ui.notify(e.value))

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

collapse (node_keys: Optional[List[str]] = None) -> Self


Collapse the given nodes.

param node_keys:
 list of node keys to collapse (default: all nodes)

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

expand (node_keys: Optional[List[str]] = None) -> Self


Expand the given nodes.

param node_keys:
 list of node keys to expand (default: all nodes)

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_expand (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the expansion changes.

on_select (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the selection changes.

on_tick (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when a node is ticked or unticked.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 65. URL: http://localhost:8080/documentation/log

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.log Log View Attach to a logger Reference Properties Methods Inheritance


ui. log


Log View


Create a log view that allows to add new lines without re-transmitting the whole history to the client.

max_lines: maximum number of lines before dropping oldest ones (default: None)


Coding example:
from datetime import datetime
from nicegui import ui

log = ui.log(max_lines=10).classes('w-full h-20')
ui.button('Log time', on_click=lambda: log.push(datetime.now().strftime('%X.%f')[:-5]))

ui.run()


Attach to a logger

You can attach a ui.log element to a Python logger object so that log messages are pushed to the log element.


Coding example:
import logging
from datetime import datetime
from nicegui import ui

logger = logging.getLogger()

class LogElementHandler(logging.Handler):
    """A logging handler that emits messages to a log element."""

    def __init__(self, element: ui.log, level: int = logging.NOTSET) -> None:
        self.element = element
        super().__init__(level)

    def emit(self, record: logging.LogRecord) -> None:
        try:
            msg = self.format(record)
            self.element.push(msg)
        except Exception:
            self.handleError(record)

log = ui.log(max_lines=10).classes('w-full')
handler = LogElementHandler(log)
logger.addHandler(handler)
ui.context.client.on_disconnect(lambda: logger.removeHandler(handler))
ui.button('Log time', on_click=lambda: logger.warning(datetime.now().strftime('%X.%f')[:-5]))

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

push (line: Any) -> None


Add a new line to the log.

param line: the line to add (can contain line breaks)

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 66. URL: http://localhost:8080/documentation/editor

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.editor Editor Reference Properties Methods Inheritance


ui. editor


Editor


A WYSIWYG editor based on Quasar's QEditor .
The value is a string containing the formatted text as HTML code.

value: initial value
on_change: callback to be invoked when the value changes


Coding example:
from nicegui import ui

editor = ui.editor(placeholder='Type something here')
ui.markdown().bind_content_from(editor, 'value',
                                backward=lambda v: f'HTML code:\n```\n{v}\n```')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 67. URL: http://localhost:8080/documentation/code

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.code Code Reference Properties Methods Inheritance


ui. code


Code


This element displays a code block with syntax highlighting.

content: code to display
language: language of the code (default: "python")


Coding example:
from nicegui import ui

ui.code('''
    from nicegui import ui

    ui.label('Code inception!')

    ui.run()
''').classes('w-full')

ui.run()


Reference


Properties


content : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_content (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_content_from (target_object: Any, target_name: str = 'content', backward: Callable[..., Any] = [...]) -> Self


Bind the content of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_content_to (target_object: Any, target_name: str = 'content', forward: Callable[..., Any] = [...]) -> Self


Bind the content of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_content (content: str) -> None


Set the content of this element.

param content: The new content.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

show_checkmark () -> None


Show a checkmark icon for 3 seconds.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ContentElement
Element
Visibility




____________________________________________________________
Section: 68. URL: http://localhost:8080/documentation/json_editor

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.json_editor JSONEditor Run methods Reference Properties Methods Inheritance


ui. json_editor


JSONEditor


An element to create a JSON editor using JSONEditor .
Updates can be pushed to the editor by changing the properties property.
After data has changed, call the update method to refresh the editor.

properties: dictionary of JSONEditor properties
on_select: callback which is invoked when some of the content has been selected
on_change: callback which is invoked when the content has changed


Coding example:
from nicegui import ui

json = {
    'array': [1, 2, 3],
    'boolean': True,
    'color': '#82b92c',
    None: None,
    'number': 123,
    'object': {
        'a': 'b',
        'c': 'd',
    },
    'time': 1575599819000,
    'string': 'Hello World',
}
ui.json_editor({'content': {'json': json}},
               on_select=lambda e: ui.notify(f'Select: {e}'),
               on_change=lambda e: ui.notify(f'Change: {e}'))

ui.run()


Run methods

You can run methods of the JSONEditor instance using the run_editor_method method.
This demo shows how to expand and collapse all nodes and how to get the current data.
The colon ":" in front of the method name "expand" indicates that the value "path => true" is a JavaScript expression
that is evaluated on the client before it is passed to the method.


Coding example:
from nicegui import ui

json = {
    'Name': 'Alice',
    'Age': 42,
    'Address': {
        'Street': 'Main Street',
        'City': 'Wonderland',
    },
}
editor = ui.json_editor({'content': {'json': json}})

ui.button('Expand', on_click=lambda: editor.run_editor_method(':expand', 'path => true'))
ui.button('Collapse', on_click=lambda: editor.run_editor_method(':expand', 'path => false'))
ui.button('Readonly', on_click=lambda: editor.run_editor_method('updateProps', {'readOnly': True}))

async def get_data() -> None:
    data = await editor.run_editor_method('get')
    ui.notify(data)
ui.button('Get Data', on_click=get_data)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

properties : Dict


The property dictionary.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the content changes.

on_select (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when some of the content has been selected.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_editor_method (name: str, *args, timeout: float = 1, check_interval: float = 0.01) -> nicegui.awaitable_response.AwaitableResponse


Run a method of the JSONEditor instance.
See the JSONEditor README for a list of methods.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method (a prefix ":" indicates that the arguments are JavaScript expressions)
param args: arguments to pass to the method (Python objects or JavaScript expressions)
param timeout: timeout in seconds (default: 1 second)
return: AwaitableResponse that can be awaited to get the result of the method call

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Inheritance

Element
Visibility




____________________________________________________________
Section: 69. URL: http://localhost:8080/documentation/storage

menu
Installation Features Demos Documentation Examples Why? search


← back

Storage Storage Counting page visits Storing UI state Storing data per browser tab Short-term memory Indentation


Storage


Storage

It features five built-in storage types:
app.storage.tab :
Stored server-side in memory, this dictionary is unique to each tab session and can hold arbitrary objects.
Data will be lost when restarting the server until https://github.com/zauberzeug/nicegui/discussions/2841 is implemented.
This storage is only available within page builder functions and requires an established connection, obtainable via await client.connected() .
app.storage.client :
Also stored server-side in memory, this dictionary is unique to each client connection and can hold arbitrary objects.
Data will be discarded when the page is reloaded or the user navigates to another page.
Unlike data stored in app.storage.tab which can be persisted on the server even for days, app.storage.client helps caching resource-hungry objects such as a streaming or database connection you need to keep alive
for dynamic site updates but would like to discard as soon as the user leaves the page or closes the browser.
This storage is only available within page builder functions .
app.storage.user :
Stored server-side, each dictionary is associated with a unique identifier held in a browser session cookie.
Unique to each user, this storage is accessible across all their browser tabs. app.storage.browser['id'] is used to identify the user.
app.storage.general :
Also stored server-side, this dictionary provides a shared storage space accessible to all users.
app.storage.browser :
Unlike the previous types, this dictionary is stored directly as the browser session cookie, shared among all browser tabs for the same user.
However, app.storage.user is generally preferred due to its advantages in reducing data payload, enhancing security, and offering larger storage capacity.
By default, NiceGUI holds a unique identifier for the browser session in app.storage.browser['id'] .
The user storage and browser storage are only available within page builder functions </documentation/page> _
because they are accessing the underlying Request object from FastAPI.
Additionally these two types require the storage_secret parameter in ui.run() to sign the browser session cookie.

Storage type tab client user general browser
Location Server Server Server Server Browser
Across tabs No No Yes Yes Yes
Across browsers No No No Yes No
Across server restarts No No No Yes No
Across page reloads Yes No Yes Yes Yes
Needs page builder function Yes Yes Yes No Yes
Needs client connection Yes No No No No
Write only before response No No No No Yes
Needs serializable data No No Yes Yes Yes


Coding example:
from nicegui import app, ui

@ui.page('/')
def index():
    app.storage.user['count'] = app.storage.user.get('count', 0) + 1
    with ui.row():
       ui.label('your own page visits:')
       ui.label().bind_text_from(app.storage.user, 'count')

ui.run(storage_secret='private key to secure the browser session cookie')


Counting page visits

Here we are using the automatically available browser-stored session ID to count the number of unique page visits.


Coding example:
from collections import Counter
from datetime import datetime
from nicegui import app, ui

counter = Counter()
start = datetime.now().strftime('%H:%M, %d %B %Y')

@ui.page('/')
def index():
    counter[app.storage.browser['id']] += 1
    ui.label(f'{len(counter)} unique views ({sum(counter.values())} overall) since {start}')

ui.run(storage_secret='private key to secure the browser session cookie')


Storing UI state

Storage can also be used in combination with bindings .
Here we are storing the value of a textarea between visits.
The note is also shared between all tabs of the same user.


Coding example:
from nicegui import app, ui

@ui.page('/')
def index():
    ui.textarea('This note is kept between visits') \
        .classes('w-full').bind_value(app.storage.user, 'note')

ui.run()


Storing data per browser tab

When storing data in app.storage.tab , a single user can open multiple tabs of the same app, each with its own storage data.
This may be beneficial in certain scenarios like search or when performing data analysis.
It is also more secure to use such a volatile storage for scenarios like logging into a bank account or accessing a password manager.


Coding example:
from nicegui import app, ui

@ui.page('/')
async def index():
    await ui.context.client.connected()
    app.storage.tab['count'] = app.storage.tab.get('count', 0) + 1
    ui.label(f'Tab reloaded {app.storage.tab["count"]} times')
    ui.button('Reload page', on_click=ui.navigate.reload)

ui.run()


Short-term memory

The goal of app.storage.client is to store data only for the duration of the current page visit.
In difference to data stored in app.storage.tab - which is persisted between page changes and even browser restarts as long as the tab is kept open -
the data in app.storage.client will be discarded if the user closes the browser, reloads the page or navigates to another page.
This is beneficial for resource-hungry, intentionally short-lived or sensitive data.
An example is a database connection, which should be closed as soon as the user leaves the page.
Additionally, this storage useful if you want to return a page with default settings every time a user reloads.
Meanwhile, it keeps the data alive during in-page navigation.
This is also helpful when updating elements on the site at intervals, such as a live feed.


Coding example:
from nicegui import app, ui

@ui.page('/')
async def index():
    cache = app.storage.client
    cache['count'] = 0
    ui.label().bind_text_from(cache, 'count', lambda n: f'Updated {n} times')
    ui.button('Update content',
              on_click=lambda: cache.update(count=cache['count'] + 1))
    ui.button('Reload page', on_click=ui.navigate.reload)

ui.run()


Indentation

By default, the general and user storage data is stored in JSON format without indentation.
You can change this to an indentation of 2 spaces by setting app.storage.general.indent = True or app.storage.user.indent = True .




____________________________________________________________
Section: 70. URL: http://localhost:8080/documentation/page

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.page Page Pages with Path Parameters Wait for Client Connection Modularize with APIRouter


ui. page


Page


This decorator marks a function to be a page builder.
Each user accessing the given route will see a new instance of the page.
This means it is private to the user and not shared with others
(as it is done when placing elements outside of a page decorator ).
Note:
The name of the decorated function is unused and can be anything.
The page route is determined by the path argument and registered globally.

path: route of the new page (path must start with '/')
title: optional page title
viewport: optional viewport meta tag content
favicon: optional relative filepath or absolute URL to a favicon (default: None, NiceGUI icon will be used)
dark: whether to use Quasar's dark mode (defaults to dark argument of run command)
language: language of the page (defaults to language argument of run command)
response_timeout:
 maximum time for the decorated function to build the page (default: 3.0 seconds)
reconnect_timeout:
 maximum time the server waits for the browser to reconnect (default: 0.0 seconds)
api_router: APIRouter instance to use, can be left None to use the default
kwargs: additional keyword arguments passed to FastAPI's @app.get method


Coding example:
from nicegui import ui

@ui.page('/other_page')
def other_page():
    ui.label('Welcome to the other side')

@ui.page('/dark_page', dark=True)
def dark_page():
    ui.label('Welcome to the dark side')

ui.link('Visit other page', other_page)
ui.link('Visit dark page', dark_page)

ui.run()


Pages with Path Parameters

Page routes can contain parameters like FastAPI .
If type-annotated, they are automatically converted to bool, int, float and complex values.
If the page function expects a request argument, the request object is automatically provided.
The client argument provides access to the websocket connection, layout, etc.


Coding example:
from nicegui import ui

@ui.page('/repeat/{word}/{count}')
def page(word: str, count: int):
    ui.label(word * count)

ui.link('Say hi to Santa!', '/repeat/Ho! /3')

ui.run()


Wait for Client Connection

To wait for a client connection, you can add a client argument to the decorated page function
and await client.connected() .
All code below that statement is executed after the websocket connection between server and client has been established.
For example, this allows you to run JavaScript commands; which is only possible with a client connection (see #112 ).
Also it is possible to do async stuff while the user already sees some content.


Coding example:
import asyncio
from nicegui import ui

@ui.page('/wait_for_connection')
async def wait_for_connection():
    ui.label('This text is displayed immediately.')
    await ui.context.client.connected()
    await asyncio.sleep(2)
    ui.label('This text is displayed 2 seconds after the page has been fully loaded.')
    ui.label(f'The IP address {ui.context.client.ip} was obtained from the websocket.')

ui.link('wait for connection', wait_for_connection)

ui.run()


Modularize with APIRouter

You can use the NiceGUI specialization of FastAPI's APIRouter to modularize your code by grouping pages and other routes together.
This is especially useful if you want to reuse the same prefix for multiple pages.
The router and its pages can be neatly tugged away in a separate module (e.g. file) and
the router is simply imported and included in the main app.
See our modularization example for a multi-file app structure using an API router.


Coding example:
from nicegui import APIRouter, app, ui

router = APIRouter(prefix='/sub-path')

@router.page('/')
def page():
    ui.label('This is content on /sub-path')

@router.page('/sub-sub-path')
def page():
    ui.label('This is content on /sub-path/sub-sub-path')

ui.link('Visit sub-path', '/sub-path')
ui.link('Visit sub-sub-path', '/sub-path/sub-sub-path')

app.include_router(router)

ui.run()


/sub-path




____________________________________________________________
Section: 71. URL: http://localhost:8080/documentation/card

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.card Card Card without shadow The issue with nested borders Reference Properties Methods Inheritance


ui. card


Card


This element is based on Quasar's QCard component.
It provides a container with a dropped shadow.
Note:
There are subtle differences between the Quasar component and this element.
In contrast to this element, the original QCard has no padding by default and hides outer borders of nested elements.
If you want the original behavior, use the tight method.
If you want the padding and borders for nested children, move the children into another container.

align_items: alignment of the items in the card (default: None)


Coding example:
from nicegui import ui

with ui.card().tight():
    ui.image('https://picsum.photos/id/684/640/360')
    with ui.card_section():
        ui.label('Lorem ipsum dolor sit amet, consectetur adipiscing elit, ...')

ui.run()


Card without shadow

You can remove the shadow from a card by adding the no-shadow class.
The following demo shows a 1 pixel wide border instead.


Coding example:
from nicegui import ui

with ui.card().classes('no-shadow border-[1px]'):
    ui.label('See, no shadow!')

ui.run()


The issue with nested borders

The following example shows a table nested in a card.
Cards have a default padding in NiceGUI, so the table is not flush with the card's border.
The table has the flat and bordered props set, so it should have a border.
However, due to the way QCard is designed, the border is not visible (first card).
There are two ways to fix this:

To get the original QCard behavior, use the tight method (second card).
It removes the padding and the table border collapses with the card border.

To preserve the padding and the table border, move the table into another container like a ui.row (third card).
See https://github.com/zauberzeug/nicegui/issues/726 for more information.


Coding example:
from nicegui import ui

columns = [{'name': 'age', 'label': 'Age', 'field': 'age'}]
rows = [{'age': '16'}, {'age': '18'}, {'age': '21'}]

with ui.row():
    with ui.card():
        ui.table(columns, rows).props('flat bordered')

    with ui.card().tight():
        ui.table(columns, rows).props('flat bordered')

    with ui.card():
        with ui.row():
            ui.table(columns, rows).props('flat bordered')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tight () -> Self


Remove padding and gaps between nested elements.

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 72. URL: http://localhost:8080/documentation/column

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.column Column Element Masonry or Pinterest-Style Layout Reference Properties Methods Inheritance


ui. column


Column Element


Provides a container which arranges its child in a column.

wrap: whether to wrap the content (default: False)
align_items: alignment of the items in the column (default: None)


Coding example:
from nicegui import ui

with ui.column():
    ui.label('label 1')
    ui.label('label 2')
    ui.label('label 3')

ui.run()


Masonry or Pinterest-Style Layout

To create a masonry/Pinterest layout, the normal ui.column can not be used.
But it can be achieved with a few TailwindCSS classes.


Coding example:
from nicegui import ui

with ui.element('div').classes('columns-3 w-full gap-2'):
    for i, height in enumerate([50, 50, 50, 150, 100, 50]):
        tailwind = f'mb-2 p-2 h-[{height}px] bg-blue-100 break-inside-avoid'
        with ui.card().classes(tailwind):
            ui.label(f'Card #{i+1}')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 73. URL: http://localhost:8080/documentation/row

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.row Row Element Reference Properties Methods Inheritance


ui. row


Row Element


Provides a container which arranges its child in a row.

wrap: whether to wrap the content (default: True)
align_items: alignment of the items in the row (default: None)


Coding example:
from nicegui import ui

with ui.row():
    ui.label('label 1')
    ui.label('label 2')
    ui.label('label 3')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 74. URL: http://localhost:8080/documentation/grid

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.grid Grid Element Custom grid layout Cells spanning multiple columns Reference Properties Methods Inheritance


ui. grid


Grid Element


Provides a container which arranges its child in a grid.

rows: number of rows in the grid or a string with the grid-template-rows CSS property (e.g. 'auto 1fr')
columns: number of columns in the grid or a string with the grid-template-columns CSS property (e.g. 'auto 1fr')


Coding example:
from nicegui import ui

with ui.grid(columns=2):
    ui.label('Name:')
    ui.label('Tom')

    ui.label('Age:')
    ui.label('42')

    ui.label('Height:')
    ui.label('1.80m')

ui.run()


Custom grid layout

This demo shows how to create a custom grid layout passing a string with the grid-template-columns CSS property.
You can use any valid CSS dimensions, such as 'auto', '1fr', '80px', etc.
'auto' will make the column as wide as its content.
'1fr' or '2fr' will make the corresponding columns fill the remaining space, with fractions in a 1:2 ratio.
'80px' will make the column 80 pixels wide.


Coding example:
from nicegui import ui

with ui.grid(columns='auto 80px 1fr 2fr').classes('w-full gap-0'):
    for _ in range(3):
        ui.label('auto').classes('border p-1')
        ui.label('80px').classes('border p-1')
        ui.label('1fr').classes('border p-1')
        ui.label('2fr').classes('border p-1')

ui.run()


Cells spanning multiple columns

This demo shows how to span cells over multiple columns.
Note that there is no Tailwind class for spanning 15 columns ,
but we can set arbitrary values using square brackets.
Alternatively you could use the corresponding CSS definition: .style('grid-column: span 15 / span 15') .


Coding example:
from nicegui import ui

with ui.grid(columns=16).classes('w-full gap-0'):
    ui.label('full').classes('col-span-full border p-1')
    ui.label('8').classes('col-span-8 border p-1')
    ui.label('8').classes('col-span-8 border p-1')
    ui.label('12').classes('col-span-12 border p-1')
    ui.label('4').classes('col-span-4 border p-1')
    ui.label('15').classes('col-[span_15] border p-1')
    ui.label('1').classes('col-span-1 border p-1')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 75. URL: http://localhost:8080/documentation/list

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.list List Items, Sections and Labels Reference for ui.list Properties Methods Inheritance Reference for ui.item Properties Methods Inheritance Reference for ui.item_section Properties Methods Inheritance Reference for ui.item_label Properties Methods Inheritance


ui. list


List


A list element based on Quasar's QList component.
It provides a container for ui.item elements.


Coding example:
from nicegui import ui

with ui.list().props('dense separator'):
    ui.item('3 Apples')
    ui.item('5 Bananas')
    ui.item('8 Strawberries')
    ui.item('13 Walnuts')

ui.run()


Items, Sections and Labels

List items use item sections to structure their content.
Item labels take different positions depending on their props.


Coding example:
from nicegui import ui

with ui.list().props('bordered separator'):
    ui.item_label('Contacts').props('header').classes('text-bold')
    ui.separator()
    with ui.item(on_click=lambda: ui.notify('Selected contact 1')):
        with ui.item_section().props('avatar'):
            ui.icon('person')
        with ui.item_section():
            ui.item_label('Nice Guy')
            ui.item_label('name').props('caption')
        with ui.item_section().props('side'):
            ui.icon('chat')
    with ui.item(on_click=lambda: ui.notify('Selected contact 2')):
        with ui.item_section().props('avatar'):
            ui.icon('person')
        with ui.item_section():
            ui.item_label('Nice Person')
            ui.item_label('name').props('caption')
        with ui.item_section().props('side'):
            ui.icon('chat')

ui.run()


Reference for ui.list


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility


Reference for ui.item


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_click (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the List Item is clicked.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

DisableableElement
Element
Visibility


Reference for ui.item_section


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

text : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
Element
Visibility


Reference for ui.item_label


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

text : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
Element
Visibility




____________________________________________________________
Section: 76. URL: http://localhost:8080/documentation/expansion

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.expansion Expansion Element Expansion with Custom Header Expansion with Custom Caption Expansion with Grouping Reference Properties Methods Inheritance


ui. expansion


Expansion Element


Provides an expandable container based on Quasar's QExpansionItem component.

text: title text
caption: optional caption (or sub-label) text
icon: optional icon (default: None)
group: optional group name for coordinated open/close state within the group a.k.a. "accordion mode"
value: whether the expansion should be opened on creation (default: False)
on_value_change:
 callback to execute when value changes


Coding example:
from nicegui import ui

with ui.expansion('Expand!', icon='work').classes('w-full'):
    ui.label('inside the expansion')

ui.run()


Expansion with Custom Header

Instead of setting a plain-text title, you can fill the expansion header with UI elements by adding them to the "header" slot.


Coding example:
from nicegui import ui

with ui.expansion() as expansion:
    with expansion.add_slot('header'):
        ui.image('https://nicegui.io/logo.png').classes('w-16')
    ui.label('What a nice GUI!')

ui.run()


Expansion with Custom Caption

A caption, or sub-label, can be added below the title.


Coding example:
from nicegui import ui

with ui.expansion('Expand!', caption='Expansion Caption').classes('w-full'):
    ui.label('inside the expansion')

ui.run()


Expansion with Grouping

An expansion group can be defined to enable coordinated open/close states a.k.a. "accordion mode".


Coding example:
from nicegui import ui

with ui.expansion(text='Expand One!', group='group'):
    ui.label('inside expansion one')
with ui.expansion(text='Expand Two!', group='group'):
    ui.label('inside expansion two')
with ui.expansion(text='Expand Three!', group='group'):
    ui.label('inside expansion three')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

text : BindableProperty

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

close () -> None


Close the expansion.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

open () -> None


Open the expansion.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 77. URL: http://localhost:8080/documentation/scroll_area

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.scroll_area Scroll Area Handling Scroll Events Setting the scroll position Reference Properties Methods Inheritance


ui. scroll_area


Scroll Area


A way of customizing the scrollbars by encapsulating your content.
This element exposes the Quasar ScrollArea component.

on_scroll: function to be called when the scroll position changes


Coding example:
from nicegui import ui

with ui.row():
    with ui.scroll_area().classes('w-32 h-32 border'):
        ui.label('I scroll. ' * 20)
    with ui.column().classes('p-4 w-32 h-32 border'):
        ui.label('I will not scroll. ' * 10)

ui.run()


Handling Scroll Events

You can use the on_scroll argument in ui.scroll_area to handle scroll events.
The callback receives a ScrollEventArguments object with the following attributes:
sender : the scroll area that generated the event
client : the matching client
additional arguments as described in Quasar's documentation for the ScrollArea API


Coding example:
from nicegui import ui

position = ui.number('scroll position:').props('readonly')
with ui.card().classes('w-32 h-32'):
    with ui.scroll_area(on_scroll=lambda e: position.set_value(e.vertical_percentage)):
        ui.label('I scroll. ' * 20)

ui.run()


Setting the scroll position

You can use scroll_to to programmatically set the scroll position.
This can be useful for navigation or synchronization of multiple scroll areas.


Coding example:
from nicegui import ui

ui.number('position', value=0, min=0, max=1, step=0.1,
          on_change=lambda e: area1.scroll_to(percent=e.value)).classes('w-32')

with ui.row():
    with ui.card().classes('w-32 h-48'):
        with ui.scroll_area(on_scroll=lambda e: area2.scroll_to(percent=e.vertical_percentage)) as area1:
            ui.label('I scroll. ' * 20)

    with ui.card().classes('w-32 h-48'):
        with ui.scroll_area() as area2:
            ui.label('I scroll. ' * 20)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_scroll (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the scroll position changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

scroll_to (pixels: Optional[float] = None, percent: Optional[float] = None, axis: Literal['vertical', 'horizontal'] = 'vertical', duration: float = 0.0) -> None


Set the scroll area position in percentage (float) or pixel number (int).
You can add a delay to the actual scroll action with the duration_ms parameter.

param pixels: scroll position offset from top in pixels
param percent: scroll position offset from top in percentage of the total scrolling size
param axis: scroll axis
param duration: animation duration (in seconds, default: 0.0 means no animation)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 78. URL: http://localhost:8080/documentation/separator

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.separator Separator Reference Properties Methods Inheritance


ui. separator


Separator


This element is based on Quasar's QSeparator component.
It serves as a separator for cards, menus and other component containers and is similar to HTML's <hr> tag.


Coding example:
from nicegui import ui

ui.label('text above')
ui.separator()
ui.label('text below')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 79. URL: http://localhost:8080/documentation/space

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.space Space Vertical space Reference Properties Methods Inheritance


ui. space


Space


This element is based on Quasar's QSpace component.
Its purpose is to simply fill all available space inside of a flexbox element.


Coding example:
from nicegui import ui

with ui.row().classes('w-full border'):
    ui.label('Left')
    ui.space()
    ui.label('Right')

ui.run()


Vertical space

This element can also be used to fill vertical space.


Coding example:
from nicegui import ui

with ui.column().classes('h-32 border'):
    ui.label('Top')
    ui.space()
    ui.label('Bottom')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 80. URL: http://localhost:8080/documentation/skeleton

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.skeleton Skeleton Styling and animation YouTube Skeleton


ui. skeleton


Skeleton


This element is based on Quasar's QSkeleton component.
It serves as a placeholder for loading content in cards, menus and other component containers.
See the Quasar documentation for a list of available types.

type: type of skeleton to display (default: "rect")
tag: HTML tag to use for this element (default: "div")
animation: animation effect of the skeleton placeholder (default: "wave")
animation_speed:
 animation speed in seconds (default: 1.5)
square: whether to remover border-radius so borders are squared (default: False)
bordered: whether to apply a default border to the component (default: False)
size: size in CSS units (overrides width and height)
width: width in CSS units (overridden by size if set)
height: height in CSS units (overridden by size if set)


Coding example:
from nicegui import ui

ui.skeleton().classes('w-full')

ui.run()


Styling and animation

The square and bordered parameters can be set to True to remove the border-radius and add a border to the skeleton.
The animation parameter can be set to "pulse", "wave", "pulse-x", "pulse-y", "fade", "blink", or "none"
to change the animation effect.
The default value is "wave".


Coding example:
from nicegui import ui

ui.skeleton('QToolbar', square=True, bordered=True, animation='pulse-y') \
    .classes('w-full')

ui.run()


YouTube Skeleton

Here is an example skeleton for a YouTube video.


Coding example:
from nicegui import ui

with ui.card().tight().classes('w-full'):
    ui.skeleton(square=True, animation='fade', height='150px', width='100%')
    with ui.card_section().classes('w-full'):
        ui.skeleton('text').classes('text-subtitle1')
        ui.skeleton('text').classes('text-subtitle1 w-1/2')
        ui.skeleton('text').classes('text-caption')

ui.run()




____________________________________________________________
Section: 81. URL: http://localhost:8080/documentation/splitter

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.splitter Splitter Advanced usage Image fun Reference Properties Methods Inheritance


ui. splitter


Splitter


The ui.splitter element divides the screen space into resizable sections,
allowing for flexible and responsive layouts in your application.
Based on Quasar's Splitter component: Splitter
It provides three customizable slots, before , after , and separator ,
which can be used to embed other elements within the splitter.

horizontal: Whether to split horizontally instead of vertically
limits: Two numbers representing the minimum and maximum split size of the two panels
value: Size of the first panel (or second if using reverse)
reverse: Whether to apply the model size to the second panel instead of the first
on_change: callback which is invoked when the user releases the splitter


Coding example:
from nicegui import ui

with ui.splitter() as splitter:
    with splitter.before:
        ui.label('This is some content on the left hand side.').classes('mr-2')
    with splitter.after:
        ui.label('This is some content on the right hand side.').classes('ml-2')

ui.run()


Advanced usage

This demo shows all the slots and parameters including a tooltip, a custom separator, and a callback.


Coding example:
from nicegui import ui

with ui.splitter(horizontal=False, reverse=False, value=60,
                 on_change=lambda e: ui.notify(e.value)) as splitter:
    ui.tooltip('This is the default slot.').classes('bg-green')
    with splitter.before:
        ui.label('This is the left hand side.').classes('mr-2')
    with splitter.after:
        ui.label('This is the right hand side.').classes('ml-2')
    with splitter.separator:
        ui.icon('lightbulb').classes('text-green')

ui.number('Split value', format='%.1f').bind_value(splitter)

ui.run()


Image fun

This demo shows how to use the splitter to display images side by side.


Coding example:
from nicegui import ui

with ui.splitter().classes('w-72 h-48') \
        .props('before-class=overflow-hidden after-class=overflow-hidden') as splitter:
    with splitter.before:
        ui.image('https://cdn.quasar.dev/img/parallax1.jpg').classes('w-72 absolute-top-left')
    with splitter.after:
        ui.image('https://cdn.quasar.dev/img/parallax1-bw.jpg').classes('w-72 absolute-top-right')

ui.run()


Reference


Properties


enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 82. URL: http://localhost:8080/documentation/tabs

menu
Installation Features Demos Documentation Examples Why? search


← back

Tabs Tabs Name, label, icon Switch tabs programmatically Vertical tabs with splitter Reference for ui.tabs Properties Methods Inheritance Reference for ui.tab Properties Methods Inheritance Reference for ui.tab_panels Properties Methods Inheritance Reference for ui.tab_panel Properties Methods Inheritance


Tabs


Tabs

The elements ui.tabs , ui.tab , ui.tab_panels , and ui.tab_panel resemble Quasar's tabs and tab panels API.
ui.tabs creates a container for the tabs. This could be placed in a ui.header for example. ui.tab_panels creates a container for the tab panels with the actual content.
Each ui.tab_panel is associated with a ui.tab element.


Coding example:
from nicegui import ui

with ui.tabs().classes('w-full') as tabs:
    one = ui.tab('One')
    two = ui.tab('Two')
with ui.tab_panels(tabs, value=two).classes('w-full'):
    with ui.tab_panel(one):
        ui.label('First tab')
    with ui.tab_panel(two):
        ui.label('Second tab')

ui.run()


Name, label, icon

The ui.tab element has a label property that can be used to display a different text than the name .
The name can also be used instead of the ui.tab objects to associate a ui.tab with a ui.tab_panel .
Additionally each tab can have an icon .


Coding example:
from nicegui import ui

with ui.tabs() as tabs:
    ui.tab('h', label='Home', icon='home')
    ui.tab('a', label='About', icon='info')
with ui.tab_panels(tabs, value='h').classes('w-full'):
    with ui.tab_panel('h'):
        ui.label('Main Content')
    with ui.tab_panel('a'):
        ui.label('Infos')

ui.run()


Switch tabs programmatically

The ui.tabs and ui.tab_panels elements are derived from ValueElement which has a set_value method.
That can be used to switch tabs programmatically.


Coding example:
from nicegui import ui

content = {'Tab 1': 'Content 1', 'Tab 2': 'Content 2', 'Tab 3': 'Content 3'}
with ui.tabs() as tabs:
    for title in content:
        ui.tab(title)
with ui.tab_panels(tabs).classes('w-full') as panels:
    for title, text in content.items():
        with ui.tab_panel(title):
            ui.label(text)

ui.button('GoTo 1', on_click=lambda: panels.set_value('Tab 1'))
ui.button('GoTo 2', on_click=lambda: tabs.set_value('Tab 2'))

ui.run()


Vertical tabs with splitter

Like in Quasar's vertical tabs example ,
we can combine ui.splitter and tab elements to create a vertical tabs layout.


Coding example:
from nicegui import ui

with ui.splitter(value=30).classes('w-full h-56') as splitter:
    with splitter.before:
        with ui.tabs().props('vertical').classes('w-full') as tabs:
            mail = ui.tab('Mails', icon='mail')
            alarm = ui.tab('Alarms', icon='alarm')
            movie = ui.tab('Movies', icon='movie')
    with splitter.after:
        with ui.tab_panels(tabs, value=mail) \
                .props('vertical').classes('w-full h-full'):
            with ui.tab_panel(mail):
                ui.label('Mails').classes('text-h4')
                ui.label('Content of mails')
            with ui.tab_panel(alarm):
                ui.label('Alarms').classes('text-h4')
                ui.label('Content of alarms')
            with ui.tab_panel(movie):
                ui.label('Movies').classes('text-h4')
                ui.label('Content of movies')

ui.run()


Reference for ui.tabs


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility


Reference for ui.tab


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility


Reference for ui.tab_panels


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility


Reference for ui.tab_panel


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility




____________________________________________________________
Section: 83. URL: http://localhost:8080/documentation/stepper

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.stepper Stepper Dynamic Stepper Reference Properties Methods Inheritance


ui. stepper


Stepper


This element represents Quasar's QStepper component.
It contains individual steps.
To avoid issues with dynamic elements when switching steps,
this element uses Vue's keep-alive component.
If client-side performance is an issue, you can disable this feature.

value: ui.step or name of the step to be initially selected (default: None meaning the first step)
on_value_change:
 callback to be executed when the selected step changes
keep_alive: whether to use Vue's keep-alive component on the content (default: True)


Coding example:
from nicegui import ui

with ui.stepper().props('vertical').classes('w-full') as stepper:
    with ui.step('Preheat'):
        ui.label('Preheat the oven to 350 degrees')
        with ui.stepper_navigation():
            ui.button('Next', on_click=stepper.next)
    with ui.step('Ingredients'):
        ui.label('Mix the ingredients')
        with ui.stepper_navigation():
            ui.button('Next', on_click=stepper.next)
            ui.button('Back', on_click=stepper.previous).props('flat')
    with ui.step('Bake'):
        ui.label('Bake for 20 minutes')
        with ui.stepper_navigation():
            ui.button('Done', on_click=lambda: ui.notify('Yay!', type='positive'))
            ui.button('Back', on_click=stepper.previous).props('flat')

ui.run()


Dynamic Stepper

Steps can be added dynamically and positioned via ui.move() .


Coding example:
from nicegui import ui

def next_step() -> None:
    if extra_step.value and len(stepper.default_slot.children) == 2:
        with stepper:
            with ui.step('extra') as extra:
                ui.label('Extra')
                with ui.stepper_navigation():
                    ui.button('Back', on_click=stepper.previous).props('flat')
                    ui.button('Next', on_click=stepper.next)
            extra.move(target_index=1)
    stepper.next()

with ui.stepper().props('vertical').classes('w-full') as stepper:
    with ui.step('start'):
        ui.label('Start')
        extra_step = ui.checkbox('do extra step')
        with ui.stepper_navigation():
            ui.button('Next', on_click=next_step)
    with ui.step('finish'):
        ui.label('Finish')
        with ui.stepper_navigation():
            ui.button('Back', on_click=stepper.previous).props('flat')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

next () -> None


Show the next step.

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

previous () -> None


Show the previous step.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility




____________________________________________________________
Section: 84. URL: http://localhost:8080/documentation/timeline

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.timeline Timeline Reference Properties Methods Inheritance


ui. timeline


Timeline


This element represents Quasar's QTimeline component.

side: Side ("left" or "right"; default: "left").
layout: Layout ("dense", "comfortable" or "loose"; default: "dense").
color: Color of the icons.


Coding example:
from nicegui import ui

with ui.timeline(side='right'):
    ui.timeline_entry('Rodja and Falko start working on NiceGUI.',
                      title='Initial commit',
                      subtitle='May 07, 2021')
    ui.timeline_entry('The first PyPI package is released.',
                      title='Release of 0.1',
                      subtitle='May 14, 2021')
    ui.timeline_entry('Large parts are rewritten to remove JustPy '
                      'and to upgrade to Vue 3 and Quasar 2.',
                      title='Release of 1.0',
                      subtitle='December 15, 2022',
                      icon='rocket')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 85. URL: http://localhost:8080/documentation/carousel

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.carousel Carousel Reference Properties Methods Inheritance


ui. carousel


Carousel


This element represents Quasar's QCarousel component.
It contains individual carousel slides.

value: ui.carousel_slide or name of the slide to be initially selected (default: None meaning the first slide)
on_value_change:
 callback to be executed when the selected slide changes
animated: whether to animate slide transitions (default: False)
arrows: whether to show arrows for manual slide navigation (default: False)
navigation: whether to show navigation dots for manual slide navigation (default: False)


Coding example:
from nicegui import ui

with ui.carousel(animated=True, arrows=True, navigation=True).props('height=180px'):
    with ui.carousel_slide().classes('p-0'):
        ui.image('https://picsum.photos/id/30/270/180').classes('w-[270px]')
    with ui.carousel_slide().classes('p-0'):
        ui.image('https://picsum.photos/id/31/270/180').classes('w-[270px]')
    with ui.carousel_slide().classes('p-0'):
        ui.image('https://picsum.photos/id/32/270/180').classes('w-[270px]')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

next () -> None


Show the next slide.

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

previous () -> None


Show the previous slide.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility




____________________________________________________________
Section: 86. URL: http://localhost:8080/documentation/pagination

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.pagination Pagination Reference Properties Methods Inheritance


ui. pagination


Pagination


A pagination element wrapping Quasar's QPagination component.

min: minimum page number
max: maximum page number
direction_links:
 whether to show first/last page links
value: initial page (defaults to min if no value is provided)
on_change: callback to be invoked when the value changes


Coding example:
from nicegui import ui

p = ui.pagination(1, 5, direction_links=True)
ui.label().bind_text_from(p, 'value', lambda v: f'Page {v}')

ui.run()


Reference


Properties


direction_links : bool (settable)


Whether to show first/last page links

enabled : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : bool


Return whether the element is currently ignoring events.

max : int (settable)


Maximum page number

min : int (settable)


Minimum page number

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_enabled (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_from (target_object: Any, target_name: str = 'enabled', backward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_enabled_to (target_object: Any, target_name: str = 'enabled', forward: Callable[..., Any] = [...]) -> Self


Bind the enabled state of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable the element.

enable () -> None


Enable the element.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_enabled (value: bool) -> None


Set the enabled state of the element.

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
DisableableElement
Element
Visibility




____________________________________________________________
Section: 87. URL: http://localhost:8080/documentation/menu

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.menu Menu Client-side auto-close Reference Properties Methods Inheritance


ui. menu


Menu


Creates a menu based on Quasar's QMenu component.
The menu should be placed inside the element where it should be shown.
Advanced tip:
Use the auto-close prop to automatically close the menu on any click event directly without a server round-trip.

value: whether the menu is already opened (default: False)


Coding example:
from nicegui import ui

with ui.row().classes('w-full items-center'):
    result = ui.label().classes('mr-auto')
    with ui.button(icon='menu'):
        with ui.menu() as menu:
            ui.menu_item('Menu item 1', lambda: result.set_text('Selected item 1'))
            ui.menu_item('Menu item 2', lambda: result.set_text('Selected item 2'))
            ui.menu_item('Menu item 3 (keep open)',
                         lambda: result.set_text('Selected item 3'), auto_close=False)
            ui.separator()
            ui.menu_item('Close', menu.close)

ui.run()


Client-side auto-close

Use the auto-close prop to automatically close the menu on any click event directly without a server round-trip.


Coding example:
from nicegui import ui

with ui.button(icon='menu'):
    with ui.menu().props('auto-close'):
        toggle = ui.toggle(['fastfood', 'cake', 'icecream'], value='fastfood')
ui.icon('', size='md').bind_name_from(toggle, 'value')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

close () -> None


Close the menu.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

open () -> None


Open the menu.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle () -> None


Toggle the menu.

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility




____________________________________________________________
Section: 88. URL: http://localhost:8080/documentation/context_menu

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.context_menu Context Menu Reference Properties Methods Inheritance


ui. context_menu


Context Menu


Creates a context menu based on Quasar's QMenu component.
The context menu should be placed inside the element where it should be shown.
It is automatically opened when the user right-clicks on the element and appears at the mouse position.


Coding example:
from nicegui import ui

with ui.image('https://picsum.photos/id/377/640/360'):
    with ui.context_menu():
        ui.menu_item('Flip horizontally')
        ui.menu_item('Flip vertically')
        ui.separator()
        ui.menu_item('Reset', auto_close=False)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

close () -> None


Close the context menu.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

open () -> None


Open the context menu.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 89. URL: http://localhost:8080/documentation/tooltip

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.tooltip Tooltip Tooltip method Tooltip with HTML Tooltip with other content Tooltip on HTML and Markdown Tooltip for the upload element Reference Properties Methods Inheritance


ui. tooltip


Tooltip


This element is based on Quasar's QTooltip component.
It can be placed in another element to show additional information on hover.
Instead of passing a string as the first argument, you can also nest other elements inside the tooltip.

text: the content of the tooltip (default: '')


Coding example:
from nicegui import ui

with ui.button(icon='thumb_up'):
    ui.tooltip('I like this').classes('bg-green')

ui.run()


Tooltip method

Instead of nesting a tooltip element inside another element, you can also use the tooltip method.
Note that with this method you cannot apply additional properties (props) or styling directly to the tooltip.
If you need custom styling or properties, nest a ui.tooltip element instead.


Coding example:
from nicegui import ui

ui.label('Tooltips...').tooltip('...are shown on mouse over')

ui.run()


Tooltip with HTML

You can use HTML in tooltips by nesting a ui.html element.


Coding example:
from nicegui import ui

with ui.label('HTML...'):
    with ui.tooltip():
        ui.html('<b>b</b>, <em>em</em>, <u>u</u>, <s>s</s>')

ui.run()


Tooltip with other content

Other elements like ui.images can also be nested inside a tooltip.


Coding example:
from nicegui import ui

with ui.label('Mountains...'):
    with ui.tooltip().classes('bg-transparent'):
        ui.image('https://picsum.photos/id/377/640/360').classes('w-64')

ui.run()


Tooltip on HTML and Markdown

Some elements like ui.html and ui.markdown do not support nested elements.
In this case, you can nest such elements inside a container element with a tooltip.


Coding example:
from nicegui import ui

with ui.element().tooltip('...with a tooltip!'):
    ui.html('This is <u>HTML</u>...')

ui.run()


Tooltip for the upload element

Components like ui.upload do not support tooltips directly.
You can wrap them in a ui.element to add tooltips and props.


Coding example:
from nicegui import ui

with ui.element():
    ui.upload(on_upload=lambda e: ui.notify(f'Uploaded {e.name}')).classes('w-72')
    ui.tooltip('Upload files').props('delay=1000 transition-show=rotate')

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

text : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_text (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_text_from (target_object: Any, target_name: str = 'text', backward: Callable[..., Any] = [...]) -> Self


Bind the text of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_text_to (target_object: Any, target_name: str = 'text', forward: Callable[..., Any] = [...]) -> Self


Bind the text of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_text (text: str) -> None


Set the text of this element.

param text: The new text.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

TextElement
Element
Visibility




____________________________________________________________
Section: 90. URL: http://localhost:8080/documentation/notify

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.notify Notification Notification Types Multiline Notifications


ui. notify


Notification


Displays a notification on the screen.

message: content of the notification
position: position on the screen ("top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right" or "center", default: "bottom")
close_button: optional label of a button to dismiss the notification (default: False)
type: optional type ("positive", "negative", "warning", "info" or "ongoing")
color: optional color name
multi_line: enable multi-line notifications
Note: You can pass additional keyword arguments according to Quasar's Notify API .


Coding example:
from nicegui import ui

ui.button('Say hi!', on_click=lambda: ui.notify('Hi!', close_button='OK'))

ui.run()


Notification Types

There are different types that can be used to indicate the nature of the notification.


Coding example:
from nicegui import ui

ui.button('negative', on_click=lambda: ui.notify('error', type='negative'))
ui.button('positive', on_click=lambda: ui.notify('success', type='positive'))
ui.button('warning', on_click=lambda: ui.notify('warning', type='warning'))

ui.run()


Multiline Notifications

To allow a notification text to span multiple lines, it is sufficient to set multi_line=True .
If manual newline breaks are required (e.g. \n ), you need to define a CSS style and pass it to the notification as shown in the example.


Coding example:
from nicegui import ui

ui.html('<style>.multi-line-notification { white-space: pre-line; }</style>')
ui.button('show', on_click=lambda: ui.notify(
    'Lorem ipsum dolor sit amet, consectetur adipisicing elit. \n'
    'Hic quisquam non ad sit assumenda consequuntur esse inventore officia. \n'
    'Corrupti reiciendis impedit vel, '
    'fugit odit quisquam quae porro exercitationem eveniet quasi.',
    multi_line=True,
    classes='multi-line-notification',
))

ui.run()




____________________________________________________________
Section: 91. URL: http://localhost:8080/documentation/notification

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.notification Notification element Reference Properties Methods Inheritance


ui. notification


Notification element


Displays a notification on the screen.
In contrast to ui.notify , this element allows to update the notification message and other properties once the notification is displayed.
The notification can be removed with dismiss() .

message: content of the notification
position: position on the screen ("top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right" or "center", default: "bottom")
close_button: optional label of a button to dismiss the notification (default: False)
type: optional type ("positive", "negative", "warning", "info" or "ongoing")
color: optional color name
multi_line: enable multi-line notifications
icon: optional name of an icon to be displayed in the notification (default: None)
spinner: display a spinner in the notification (default: False)
timeout: optional timeout in seconds after which the notification is dismissed (default: 5.0)
on_dismiss: optional callback to be invoked when the notification is dismissed
options: optional dictionary with all options (overrides all other arguments)
Note: You can pass additional keyword arguments according to Quasar's Notify API .


Coding example:
import asyncio
from nicegui import ui

async def compute():
    n = ui.notification(timeout=None)
    for i in range(10):
        n.message = f'Computing {i/10:.0%}'
        n.spinner = True
        await asyncio.sleep(0.2)
    n.message = 'Done!'
    n.spinner = False
    await asyncio.sleep(1)
    n.dismiss()

ui.button('Compute', on_click=compute)

ui.run()


Reference


Properties


close_button : Union[bool, str] (settable)


Whether the notification has a close button.

color : Optional[str] (settable)


Color of the notification.

icon : Optional[str] (settable)


Icon of the notification.

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

message : str (settable)


Message text.

multi_line : bool (settable)


Whether the notification is multi-line.

position : Literal['top-left', 'top-right', 'bottom-left', 'bottom-right', 'top', 'bottom', 'left', 'right', 'center'] (settable)


Position on the screen.

spinner : bool (settable)


Whether the notification is a spinner.

type : Optional[Literal['positive', 'negative', 'warning', 'info', 'ongoing']] (settable)


Type of the notification.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

dismiss () -> None


Dismiss the notification.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_dismiss (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the notification is dismissed.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 92. URL: http://localhost:8080/documentation/dialog

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.dialog Dialog Awaitable dialog Replacing content Reference Properties Methods Inheritance


ui. dialog


Dialog


Creates a dialog based on Quasar's QDialog component.
By default it is dismissible by clicking or pressing ESC.
To make it persistent, set .props('persistent') on the dialog element.
NOTE: The dialog is an element.
That means it is not removed when closed, but only hidden.
You should either create it only once and then reuse it, or remove it with .clear() after dismissal.

value: whether the dialog should be opened on creation (default: False)


Coding example:
from nicegui import ui

with ui.dialog() as dialog, ui.card():
    ui.label('Hello world!')
    ui.button('Close', on_click=dialog.close)

ui.button('Open a dialog', on_click=dialog.open)

ui.run()


Awaitable dialog

Dialogs can be awaited.
Use the submit method to close the dialog and return a result.
Canceling the dialog by clicking in the background or pressing the escape key yields None .


Coding example:
from nicegui import ui

with ui.dialog() as dialog, ui.card():
    ui.label('Are you sure?')
    with ui.row():
        ui.button('Yes', on_click=lambda: dialog.submit('Yes'))
        ui.button('No', on_click=lambda: dialog.submit('No'))

async def show():
    result = await dialog
    ui.notify(f'You chose {result}')

ui.button('Await a dialog', on_click=show)

ui.run()


Replacing content

The content of a dialog can be changed.


Coding example:
from nicegui import ui

def replace():
    dialog.clear()
    with dialog, ui.card().classes('w-64 h-64'):
        ui.label('New Content')
    dialog.open()

with ui.dialog() as dialog, ui.card():
    ui.label('Hello world!')

ui.button('Open', on_click=dialog.open)
ui.button('Replace', on_click=replace)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

submitted : asyncio.locks.Event


An event that is set when the dialog is submitted.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

close () -> None


Close the dialog.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

open () -> None


Open the dialog.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

submit (result: Any) -> None


Submit the dialog with the given result.

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility




____________________________________________________________
Section: 93. URL: http://localhost:8080/documentation/query

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.query Query Selector Set background gradient Modify default page padding Reference Methods


ui. query


Query Selector


To manipulate elements like the document body, you can use the ui.query function.
With the query result you can add classes, styles, and attributes like with every other UI element.
This can be useful for example to change the background color of the page (e.g. ui.query('body').classes('bg-green') ).

selector: the CSS selector (e.g. "body", "#my-id", ".my-class", "div > p")


Coding example:
from nicegui import ui

def set_background(color: str) -> None:
    ui.query('body').style(f'background-color: {color}')

ui.button('Blue', on_click=lambda: set_background('#ddeeff'))
ui.button('Orange', on_click=lambda: set_background('#ffeedd'))

ui.run()


Set background gradient

It's easy to set a background gradient, image or similar.
See w3schools.com for more information about setting background with CSS.


Coding example:
from nicegui import ui

ui.query('body').classes('bg-gradient-to-t from-blue-400 to-blue-100')

ui.run()


Modify default page padding

By default, NiceGUI provides a built-in padding around the content of the page.
You can modify it using the class selector .nicegui-content .


Coding example:
from nicegui import ui

ui.query('.nicegui-content').classes('p-0')
with ui.column().classes('h-screen w-full bg-gray-400 justify-between'):
    ui.label('top left')
    ui.label('bottom right').classes('self-end')

ui.run()


Reference


Methods


classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones




____________________________________________________________
Section: 94. URL: http://localhost:8080/documentation/colors

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.colors Color Theming Reference Properties Methods Inheritance


ui. colors


Color Theming


Sets the main colors (primary, secondary, accent, ...) used by Quasar .


Coding example:
from nicegui import ui

ui.button('Default', on_click=lambda: ui.colors())
ui.button('Gray', on_click=lambda: ui.colors(primary='#555'))

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 95. URL: http://localhost:8080/documentation/dark_mode

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.dark_mode Dark mode Reference Properties Methods Inheritance


ui. dark_mode


Dark mode


You can use this element to enable, disable or toggle dark mode on the page.
The value None represents auto mode, which uses the client's system preference.
Note that this element overrides the dark parameter of the ui.run function and page decorators.

value: Whether dark mode is enabled. If None, dark mode is set to auto.
on_change: Callback that is invoked when the value changes.


Coding example:
from nicegui import ui

dark = ui.dark_mode()
ui.label('Switch mode:')
ui.button('Dark', on_click=dark.enable)
ui.button('Light', on_click=dark.disable)

ui.run()


Reference


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

auto () -> None


Set dark mode to auto.
This will use the client's system preference.

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

disable () -> None


Disable dark mode.

enable () -> None


Enable dark mode.

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle () -> None


Toggle dark mode.
This method will raise a ValueError if dark mode is set to auto.

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility




____________________________________________________________
Section: 96. URL: http://localhost:8080/documentation/add_style

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.add_css Add CSS style definitions to the page Add SCSS style definitions to the page Add SASS style definitions to the page


ui. add_css


Add CSS style definitions to the page


This function can be used to add CSS style definitions to the head of the HTML page.

content: CSS content (string or file path)


Coding example:
from nicegui import ui

ui.add_css('''
    .red {
        color: red;
    }
''')
ui.label('This is red with CSS.').classes('red')

ui.run()


Add SCSS style definitions to the page


This function can be used to add SCSS style definitions to the head of the HTML page.

content: SCSS content (string or file path)
indented: whether the content is indented (SASS) or not (SCSS) (default: False)


Coding example:
from nicegui import ui

ui.add_scss('''
    .green {
        background-color: lightgreen;
        .blue {
            color: blue;
        }
    }
''')
with ui.element().classes('green'):
    ui.label('This is blue on green with SCSS.').classes('blue')

ui.run()


Add SASS style definitions to the page


This function can be used to add SASS style definitions to the head of the HTML page.

content: SASS content (string or file path)


Coding example:
from nicegui import ui

ui.add_sass('''
    .yellow
        background-color: yellow
        .purple
            color: purple
''')
with ui.element().classes('yellow'):
    ui.label('This is purple on yellow with SASS.').classes('purple')

ui.run()




____________________________________________________________
Section: 97. URL: http://localhost:8080/documentation/timer

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.timer Timer Activate, deactivate and cancel a timer Call a function after a delay Reference Properties Methods Inheritance


ui. timer


Timer


One major drive behind the creation of NiceGUI was the necessity to have a simple approach to update the interface in regular intervals,
for example to show a graph with incoming measurements.
A timer will execute a callback repeatedly with a given interval.

interval: the interval in which the timer is called (can be changed during runtime)
callback: function or coroutine to execute when interval elapses
active: whether the callback should be executed or not (can be changed during runtime)
once: whether the callback is only executed once after a delay specified by interval (default: False)


Coding example:
from datetime import datetime
from nicegui import ui

label = ui.label()
ui.timer(1.0, lambda: label.set_text(f'{datetime.now():%X}'))

ui.run()


Activate, deactivate and cancel a timer

You can activate and deactivate a timer using the active property.
You can cancel a timer using the cancel method.
After canceling a timer, it cannot be activated anymore.


Coding example:
from nicegui import ui

slider = ui.slider(min=0, max=1, value=0.5)
timer = ui.timer(0.1, lambda: slider.set_value((slider.value + 0.01) % 1.0))
ui.switch('active').bind_value_to(timer, 'active')
ui.button('Cancel', on_click=timer.cancel)

ui.run()


Call a function after a delay

You can call a function after a delay using a timer with the once parameter.


Coding example:
from nicegui import ui

def handle_click():
    ui.timer(1.0, lambda: ui.notify('Hi!'), once=True)
ui.button('Notify after 1 second', on_click=handle_click)

ui.run()


Reference


Properties


active : BindableProperty

interval : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


activate () -> None


Activate the timer.

add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

cancel () -> None


Cancel the timer.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

deactivate () -> None


Deactivate the timer.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 98. URL: http://localhost:8080/documentation/keyboard

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.keyboard Keyboard Reference Properties Methods Inheritance


ui. keyboard


Keyboard


Adds global keyboard event tracking.
The on_key callback receives a KeyEventArguments object with the following attributes:
sender : the Keyboard element
client : the client object
action : a KeyboardAction object with the following attributes:
keydown : whether the key was pressed
keyup : whether the key was released
repeat : whether the key event was a repeat
key : a KeyboardKey object with the following attributes:
name : the name of the key (e.g. "a", "Enter", "ArrowLeft"; see here for a list of possible values)
code : the code of the key (e.g. "KeyA", "Enter", "ArrowLeft")
location : the location of the key (0 for standard keys, 1 for left keys, 2 for right keys, 3 for numpad keys)
modifiers : a KeyboardModifiers object with the following attributes:
alt : whether the alt key was pressed
ctrl : whether the ctrl key was pressed
meta : whether the meta key was pressed
shift : whether the shift key was pressed For convenience, the KeyboardKey object also has the following properties:
is_cursorkey : whether the key is a cursor (arrow) key
number : the integer value of a number key (0-9, None for other keys)
backspace , tab , enter , shift , control , alt , pause , caps_lock , escape , space , page_up , page_down , end , home , arrow_left , arrow_up , arrow_right , arrow_down , print_screen , insert , delete , meta , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 : whether the key is the respective key

on_key: callback to be executed when keyboard events occur.
active: boolean flag indicating whether the callback should be executed or not (default: True)
repeating: boolean flag indicating whether held keys should be sent repeatedly (default: True)
ignore: ignore keys when one of these element types is focussed (default: ['input', 'select', 'button', 'textarea'])


Coding example:
from nicegui import ui
from nicegui.events import KeyEventArguments

def handle_key(e: KeyEventArguments):
    if e.key == 'f' and not e.action.repeat:
        if e.action.keyup:
            ui.notify('f was just released')
        elif e.action.keydown:
            ui.notify('f was just pressed')
    if e.modifiers.shift and e.action.keydown:
        if e.key.arrow_left:
            ui.notify('going left')
        elif e.key.arrow_right:
            ui.notify('going right')
        elif e.key.arrow_up:
            ui.notify('going up')
        elif e.key.arrow_down:
            ui.notify('going down')

keyboard = ui.keyboard(on_key=handle_key)
ui.label('Key events can be caught globally by using the keyboard element.')
ui.checkbox('Track key events').bind_value_to(keyboard, 'active')

ui.run()


Reference


Properties


active : BindableProperty

is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_key (handler: Callable[..., Any]) -> Self


Add a callback to be invoked when keyboard events occur.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 99. URL: http://localhost:8080/documentation/refreshable

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.refreshable Refreshable UI functions Refreshable UI with parameters Refreshable UI for input validation Refreshable UI with reactive state Global scope Local scope (variant A) Local scope (variant B) Local scope (variant C) Reference Methods


ui. refreshable


Refreshable UI functions


The @ui.refreshable decorator allows you to create functions that have a refresh method.
This method will automatically delete all elements created by the function and recreate them.


Coding example:
import random
from nicegui import ui

numbers = []

@ui.refreshable
def number_ui() -> None:
    ui.label(', '.join(str(n) for n in sorted(numbers)))

def add_number() -> None:
    numbers.append(random.randint(0, 100))
    number_ui.refresh()

number_ui()
ui.button('Add random number', on_click=add_number)

ui.run()


Refreshable UI with parameters

Here is a demo of how to use the refreshable decorator to create a UI that can be refreshed with different parameters.


Coding example:
import pytz
from datetime import datetime
from nicegui import ui

@ui.refreshable
def clock_ui(timezone: str):
    ui.label(f'Current time in {timezone}:')
    ui.label(datetime.now(tz=pytz.timezone(timezone)).strftime('%H:%M:%S'))

clock_ui('Europe/Berlin')
ui.button('Refresh', on_click=clock_ui.refresh)
ui.button('Refresh for New York', on_click=lambda: clock_ui.refresh('America/New_York'))
ui.button('Refresh for Tokyo', on_click=lambda: clock_ui.refresh('Asia/Tokyo'))

ui.run()


Refreshable UI for input validation

Here is a demo of how to use the refreshable decorator to give feedback about the validity of user input.


Coding example:
import re
from nicegui import ui

pwd = ui.input('Password', password=True, on_change=lambda: show_info.refresh())

rules = {
    'Lowercase letter': lambda s: re.search(r'[a-z]', s),
    'Uppercase letter': lambda s: re.search(r'[A-Z]', s),
    'Digit': lambda s: re.search(r'\d', s),
    'Special character': lambda s: re.search(r"[!@#$%^&*(),.?':{}|<>]", s),
    'min. 8 characters': lambda s: len(s) >= 8,
}

@ui.refreshable
def show_info():
    for rule, check in rules.items():
        with ui.row().classes('items-center gap-2'):
            if check(pwd.value or ''):
                ui.icon('done', color='green')
                ui.label(rule).classes('text-xs text-green strike-through')
            else:
                ui.icon('radio_button_unchecked', color='red')
                ui.label(rule).classes('text-xs text-red')

show_info()

ui.run()


Refreshable UI with reactive state

You can create reactive state variables with the ui.state function, like count and color in this demo.
They can be used like normal variables for creating UI elements like the ui.label .
Their corresponding setter functions can be used to set new values, which will automatically refresh the UI.


Coding example:
from nicegui import ui

@ui.refreshable
def counter(name: str):
    with ui.card():
        count, set_count = ui.state(0)
        color, set_color = ui.state('black')
        ui.label(f'{name} = {count}').classes(f'text-{color}')
        ui.button(f'{name} += 1', on_click=lambda: set_count(count + 1))
        ui.select(['black', 'red', 'green', 'blue'],
                  value=color, on_change=lambda e: set_color(e.value))

with ui.row():
    counter('A')
    counter('B')

ui.run()


Global scope

When defining a refreshable function in the global scope,
every refreshable UI that is created by calling this function will share the same state.
In this demo, time() will show the current date and time.
When opening the page in a new tab, both tabs will be updated simultaneously when clicking the "Refresh" button.
See the "local scope" demos below for a way to create independent refreshable UIs instead.


Coding example:
from datetime import datetime
from nicegui import ui

@ui.refreshable
def time():
    ui.label(f'Time: {datetime.now()}')

@ui.page('/global_refreshable')
def demo():
    time()
    ui.button('Refresh', on_click=time.refresh)

ui.link('Open demo', demo)

ui.run()


Local scope (variant A)

When defining a refreshable function in a local scope,
refreshable UI that is created by calling this function will refresh independently.
In contrast to the "global scope" demo,
the time will be updated only in the tab where the "Refresh" button was clicked.


Coding example:
from datetime import datetime
from nicegui import ui

@ui.page('/local_refreshable_a')
def demo():
    @ui.refreshable
    def time():
        ui.label(f'Time: {datetime.now()}')

    time()
    ui.button('Refresh', on_click=time.refresh)

ui.link('Open demo', demo)

ui.run()


Local scope (variant B)

In order to define refreshable UIs with local state outside of page functions,
you can, e.g., define a class with a refreshable method.
This way, you can create multiple instances of the class with independent state,
because the ui.refreshable decorator acts on the class instance rather than the class itself.


Coding example:
from datetime import datetime
from nicegui import ui

class Clock:
    @ui.refreshable
    def time(self):
        ui.label(f'Time: {datetime.now()}')

@ui.page('/local_refreshable_b')
def demo():
    clock = Clock()
    clock.time()
    ui.button('Refresh', on_click=clock.time.refresh)

ui.link('Open demo', demo)

ui.run()


Local scope (variant C)

As an alternative to the class definition shown above, you can also define the UI function in global scope,
but apply the ui.refreshable decorator inside the page function.
This way the refreshable UI will refresh independently.


Coding example:
from datetime import datetime
from nicegui import ui

def time():
    ui.label(f'Time: {datetime.now()}')

@ui.page('/local_refreshable_c')
def demo():
    refreshable_time = ui.refreshable(time)
    refreshable_time()
    ui.button('Refresh', on_click=refreshable_time.refresh)

ui.link('Open demo', demo)

ui.run()


Reference


Methods


prune () -> None


Remove all targets that are no longer on a page with a client connection.
This method is called automatically before each refresh.

refresh (*args: Any, kwargs: Any) -> None


Refresh the UI elements created by this function.
This method accepts the same arguments as the function itself or a subset of them.
It will combine the arguments passed to the function with the arguments passed to this method.




____________________________________________________________
Section: 100. URL: http://localhost:8080/documentation/generic_events

menu
Installation Features Demos Documentation Examples Why? search


← back

Generic Events Generic Events Specifying event attributes Modifiers Custom events Pure JavaScript events


Generic Events


Generic Events

Most UI elements come with predefined events.
For example, a ui.button like "A" in the demo has an on_click parameter that expects a coroutine or function.
But you can also use the on method to register a generic event handler like for "B".
This allows you to register handlers for any event that is supported by JavaScript and Quasar.
For example, you can register a handler for the mousemove event like for "C", even though there is no on_mousemove parameter for ui.button .
Some events, like mousemove , are fired very often.
To avoid performance issues, you can use the throttle parameter to only call the handler every throttle seconds ("D").
The generic event handler can be synchronous or asynchronous and optionally takes GenericEventArguments as argument ("E").
You can also specify which attributes of the JavaScript or Quasar event should be passed to the handler ("F").
This can reduce the amount of data that needs to be transferred between the server and the client.
Here you can find more information about the events that are supported:
https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#events for HTML elements
https://quasar.dev/vue-components for Quasar-based elements (see the "Events" tab on the individual component page)


Coding example:
from nicegui import ui

with ui.row():
    ui.button('A', on_click=lambda: ui.notify('You clicked the button A.'))
    ui.button('B').on('click', lambda: ui.notify('You clicked the button B.'))
with ui.row():
    ui.button('C').on('mousemove', lambda: ui.notify('You moved on button C.'))
    ui.button('D').on('mousemove', lambda: ui.notify('You moved on button D.'), throttle=0.5)
with ui.row():
    ui.button('E').on('mousedown', lambda e: ui.notify(e))
    ui.button('F').on('mousedown', lambda e: ui.notify(e), ['ctrlKey', 'shiftKey'])

ui.run()


Specifying event attributes

A list of strings names the attributes of the JavaScript event object:
Coding example:
ui.button().on('click', handle_click, ['clientX', 'clientY'])

An empty list requests no attributes:
Coding example:
ui.button().on('click', handle_click, [])

The value None represents all attributes (the default):
Coding example:
ui.button().on('click', handle_click, None)

If the event is called with multiple arguments like QTable's "row-click" (evt, row, index) => void ,
you can define a list of argument definitions:
Coding example:
ui.table(...).on('rowClick', handle_click, [[], ['name'], None])

In this example the "row-click" event will omit all arguments of the first evt argument,
send only the "name" attribute of the row argument and send the full index .
If the retrieved list of event arguments has length 1, the argument is automatically unpacked.
So you can write
Coding example:
ui.button().on('click', lambda e: print(e.args['clientX'], flush=True))

instead of
Coding example:
ui.button().on('click', lambda e: print(e.args[0]['clientX'], flush=True))

Note that by default all JSON-serializable attributes of all arguments are sent.
This is to simplify registering for new events and discovering their attributes.
If bandwidth is an issue, the arguments should be limited to what is actually needed on the server.


Coding example:
from nicegui import ui

columns = [
    {'name': 'name', 'label': 'Name', 'field': 'name'},
    {'name': 'age', 'label': 'Age', 'field': 'age'},
]
rows = [
    {'name': 'Alice', 'age': 42},
    {'name': 'Bob', 'age': 23},
]
ui.table(columns, rows, 'name').on('rowClick', ui.notify, [[], ['name'], None])

ui.run()


Modifiers

You can also include key modifiers (shown in input "A"),
modifier combinations (shown in input "B"),
and event modifiers (shown in input "C").


Coding example:
from nicegui import ui

with ui.row():
    ui.input('A').classes('w-12').on('keydown.space', lambda: ui.notify('You pressed space.'))
    ui.input('B').classes('w-12').on('keydown.y.shift', lambda: ui.notify('You pressed Shift+Y'))
    ui.input('C').classes('w-12').on('keydown.once', lambda: ui.notify('You started typing.'))

ui.run()


Custom events

It is fairly easy to emit custom events from JavaScript with emitEvent(...) which can be listened to with ui.on(...) .
This can be useful if you want to call Python code when something happens in JavaScript.
In this example we are listening to the visibilitychange event of the browser tab.


Coding example:
from nicegui import ui

tabwatch = ui.checkbox('Watch browser tab re-entering')
ui.on('tabvisible', lambda: ui.notify('Welcome back!') if tabwatch.value else None)
ui.add_head_html('''
    <script>
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            emitEvent('tabvisible');
        }
    });
    </script>
''')

ui.run()


Pure JavaScript events

You can also use the on method to register a pure JavaScript event handler.
This can be useful if you want to call JavaScript code without sending any data to the server.
In this example we are using the navigator.clipboard API to copy a string to the clipboard.


Coding example:
from nicegui import ui

ui.button('Copy to clipboard') \
    .on('click', js_handler='''() => {
        navigator.clipboard.writeText("Hello, NiceGUI!");
    }''')

ui.run()




____________________________________________________________
Section: 101. URL: http://localhost:8080/documentation/run_javascript

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.run_javascript Run JavaScript Run async JavaScript


ui. run_javascript


Run JavaScript


This function runs arbitrary JavaScript code on a page that is executed in the browser.
The client must be connected before this function is called.
To access a client-side object by ID, use the JavaScript function getElement() .
If the function is awaited, the result of the JavaScript code is returned.
Otherwise, the JavaScript code is executed without waiting for a response.

code: JavaScript code to run
timeout: timeout in seconds (default: 1.0)
return: AwaitableResponse that can be awaited to get the result of the JavaScript code


Coding example:
from nicegui import ui

def alert():
    ui.run_javascript('alert("Hello!")')

async def get_date():
    time = await ui.run_javascript('Date()')
    ui.notify(f'Browser time: {time}')

def access_elements():
    ui.run_javascript(f'getElement({label.id}).innerText += " Hello!"')

ui.button('fire and forget', on_click=alert)
ui.button('receive result', on_click=get_date)
ui.button('access elements', on_click=access_elements)
label = ui.label()

ui.run()


Run async JavaScript

Using run_javascript you can also run asynchronous code in the browser.
The following demo shows how to get the current location of the user.


Coding example:
from nicegui import ui

async def show_location():
    response = await ui.run_javascript('''
        return await new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
                reject(new Error('Geolocation is not supported by your browser'));
            } else {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                        });
                    },
                    () => {
                        reject(new Error('Unable to retrieve your location'));
                    }
                );
            }
        });
    ''', timeout=5.0)
    ui.notify(f'Your location is {response["latitude"]}, {response["longitude"]}')

ui.button('Show location', on_click=show_location)

ui.run()




____________________________________________________________
Section: 102. URL: http://localhost:8080/documentation/clipboard

menu
Installation Features Demos Documentation Examples Why? search


← back

Read and write to the clipboard Read and write to the clipboard Client-side clipboard


Read and write to the clipboard


Read and write to the clipboard

The following demo shows how to use ui.clipboard.read() and ui.clipboard.write() to interact with the clipboard.
Because auto-index page can be accessed by multiple browser tabs simultaneously, reading the clipboard is not supported on this page.
This is only possible within page-builder functions decorated with ui.page , as shown in this demo.
Note that your browser may ask for permission to access the clipboard or may not support this feature at all.


Coding example:
from nicegui import ui

@ui.page('/')
async def index():
    ui.button('Write', on_click=lambda: ui.clipboard.write('Hi!'))

    async def read() -> None:
        ui.notify(await ui.clipboard.read())
    ui.button('Read', on_click=read)

ui.run()


Client-side clipboard

In order to avoid the round-trip to the server, you can also use the client-side clipboard API directly.
This might be supported by more browsers because the clipboard access is directly triggered by a user action.


Coding example:
from nicegui import ui

ui.button('Write').on('click', js_handler='''
    () => navigator.clipboard.writeText("Ho!")
''')
ui.button('Read').on('click', js_handler='''
    async () => emitEvent("clipboard", await navigator.clipboard.readText())
''')
ui.on('clipboard', lambda e: ui.notify(e.args))

ui.run()




____________________________________________________________
Section: 103. URL: http://localhost:8080/documentation/page_layout

menu
Installation Features Demos Documentation Examples Why? search


← back

Page Layout Page Layout Reference for ui.header Properties Methods Inheritance Reference for ui.left_drawer Properties Methods Inheritance Reference for ui.right_drawer Properties Methods Inheritance Reference for ui.footer Properties Methods Inheritance Reference for ui.page_sticky Properties Methods Inheritance


Page Layout


Page Layout

With ui.header , ui.footer , ui.left_drawer and ui.right_drawer you can add additional layout elements to a page.
The fixed argument controls whether the element should scroll or stay fixed on the screen.
The top_corner and bottom_corner arguments indicate whether a drawer should expand to the top or bottom of the page.
See https://quasar.dev/layout/header-and-footer and https://quasar.dev/layout/drawer for more information about possible props.
With ui.page_sticky you can place an element "sticky" on the screen.
See https://quasar.dev/layout/page-sticky for more information.


Coding example:
from nicegui import ui

@ui.page('/page_layout')
def page_layout():
    ui.label('CONTENT')
    [ui.label(f'Line {i}') for i in range(100)]
    with ui.header(elevated=True).style('background-color: #3874c8').classes('items-center justify-between'):
        ui.label('HEADER')
        ui.button(on_click=lambda: right_drawer.toggle(), icon='menu').props('flat color=white')
    with ui.left_drawer(top_corner=True, bottom_corner=True).style('background-color: #d7e3f4'):
        ui.label('LEFT DRAWER')
    with ui.right_drawer(fixed=False).style('background-color: #ebf1fa').props('bordered') as right_drawer:
        ui.label('RIGHT DRAWER')
    with ui.footer().style('background-color: #3874c8'):
        ui.label('FOOTER')

ui.link('show page with fancy layout', page_layout)

ui.run()


Reference for ui.header


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

hide ()


Hide the header

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

show ()


Show the header

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle ()


Toggle the header

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility


Reference for ui.left_drawer


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

hide () -> None


Hide the drawer

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

show () -> None


Show the drawer

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle () -> None


Toggle the drawer

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Drawer
Element
Visibility


Reference for ui.right_drawer


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

hide () -> None


Hide the drawer

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

show () -> None


Show the drawer

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle () -> None


Toggle the drawer

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Drawer
Element
Visibility


Reference for ui.footer


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

value : BindableProperty

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_value (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.

bind_value_from (target_object: Any, target_name: str = 'value', backward: Callable[..., Any] = [...]) -> Self


Bind the value of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.

bind_value_to (target_object: Any, target_name: str = 'value', forward: Callable[..., Any] = [...]) -> Self


Bind the value of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

hide () -> None


Hide the footer

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

on_value_change (callback: Callable[..., Any]) -> Self


Add a callback to be invoked when the value changes.

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_value (value: Any) -> None


Set the value of this element.

param value: The value to set.

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

show () -> None


Show the footer

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

toggle () -> None


Toggle the footer

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

ValueElement
Element
Visibility


Reference for ui.page_sticky


Properties


is_deleted : 'bool'


Whether the element has been deleted.

is_ignoring_events : 'bool'


Return whether the element is currently ignoring events.

visible : BindableProperty


Methods


add_resource (path: Union[str, Path]) -> None


Add a resource to the element.

param path: path to the resource (e.g. folder with CSS and JavaScript files)

add_slot (name: str, template: Optional[str] = None) -> Slot


Add a slot to the element.
Elements can have multiple slots, each possibly with a number of children.
Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot.
But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on.
If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot.
But if you use with table.add_slot(...): ... , you enter a different slot.
The slot stack helps NiceGUI to keep track of which slot is currently used for new elements.
The parent field holds a reference to its element.
Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name: name of the slot
param template: Vue template of the slot
return: the slot

ancestors (include_self: bool = False) -> Iterator[Element]


Iterate over the ancestors of the element.

param include_self:
 whether to include the element itself in the iteration

bind_visibility (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...], backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works both ways, from this element to the target and from the target to this element.
The update happens immediately and whenever a value changes.
The backward binding takes precedence for the initial synchronization.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_from (target_object: Any, target_name: str = 'visible', backward: Callable[..., Any] = [...], value: Any = None) -> Self


Bind the visibility of this element from the target object's target_name property.
The binding works one way only, from the target to this element.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind from.
param target_name:
 The name of the property to bind from.
param backward: A function to apply to the value before applying it to this element.
param value: If specified, the element will be visible only when the target value is equal to this value.

bind_visibility_to (target_object: Any, target_name: str = 'visible', forward: Callable[..., Any] = [...]) -> Self


Bind the visibility of this element to the target object's target_name property.
The binding works one way only, from this element to the target.
The update happens immediately and whenever a value changes.

param target_object:
 The object to bind to.
param target_name:
 The name of the property to bind to.
param forward: A function to apply to the value before applying it to the target.

classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

clear () -> None


Remove all child elements.

default_classes (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default HTML classes.
This allows modifying the look of the element or its layout using Tailwind or Quasar classes.
Removing or replacing classes can be helpful if predefined classes are not desired.
All elements of this class will share these HTML classes.
These must be defined before element instantiation.

param add: whitespace-delimited string of classes
param remove: whitespace-delimited string of classes to remove from the element
param replace: whitespace-delimited string of classes to use instead of existing ones

default_props (add: Optional[str] = None, remove: Optional[str] = None) -> type[Self]


Add or remove default props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
All elements of this class will share these props.
These must be defined before element instantiation.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

default_style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> type[Self]


Apply, remove, or replace default CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.
All elements of this class will share these CSS definitions.
These must be defined before element instantiation.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

delete () -> None


Delete the element and all its children.

descendants (include_self: bool = False) -> Iterator[Element]


Iterate over the descendants of the element.

param include_self:
 whether to include the element itself in the iteration

get_computed_prop (prop_name: str, timeout: float = 1) -> AwaitableResponse


Return a computed property.
This function should be awaited so that the computed property is properly returned.

param prop_name:
 name of the computed prop
param timeout: maximum time to wait for a response (default: 1 second)

mark (*markers: str) -> Self


Replace markers of the element.
Markers are used to identify elements for querying with ElementFilter which is heavily used in testing
but can also be used to reduce the number of global variables or passing around dependencies.

param markers: list of strings or single string with whitespace-delimited markers; replaces existing markers

move (target_container: Optional[Element] = None, target_index: int = -1, target_slot: Optional[str] = None) -> None


Move the element to another container.

param target_container:
 container to move the element to (default: the parent container)
param target_index:
 index within the target slot (default: append to the end)
param target_slot:
 slot within the target container (default: default slot)

on (type: str, handler: Optional[Callable[..., Any]] = None, args: Union[None, Sequence[str], Sequence[Optional[Sequence[str]]]] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: Optional[str] = None) -> Self


Subscribe to an event.

param type: name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler: callback that is called upon occurrence of the event
param args: arguments included in the event message sent to the event handler (default: None meaning all)
param throttle: minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 JavaScript code that is executed upon occurrence of the event, e.g. (evt) => alert(evt) (default: None)

props (add: Optional[str] = None, remove: Optional[str] = None) -> Self


Add or remove props.
This allows modifying the look of the element or its layout using Quasar props.
Since props are simply applied as HTML attributes, they can be used with any HTML element.
Boolean properties are assumed True if no value is specified.

param add: whitespace-delimited list of either boolean values or key=value pair to add
param remove: whitespace-delimited list of property keys to remove

remove (element: Union[Element, int]) -> None


Remove a child element.

param element: either the element instance or its ID

run_method (name: str, *args: Any, timeout: float = 1, check_interval: float = 0.01) -> AwaitableResponse


Run a method on the client side.
If the function is awaited, the result of the method call is returned.
Otherwise, the method is executed without waiting for a response.

param name: name of the method
param args: arguments to pass to the method
param timeout: maximum time to wait for a response (default: 1 second)

set_visibility (visible: bool) -> None


Set the visibility of this element.

param visible: Whether the element should be visible.

style (add: Optional[str] = None, remove: Optional[str] = None, replace: Optional[str] = None) -> Self


Apply, remove, or replace CSS definitions.
Removing or replacing styles can be helpful if the predefined style is not desired.

param add: semicolon-separated list of styles to add to the element
param remove: semicolon-separated list of styles to remove from the element
param replace: semicolon-separated list of styles to use instead of existing ones

tooltip (text: str) -> Self


Add a tooltip to the element.

param text: text of the tooltip

update () -> None


Update the element on the client side.


Inheritance

Element
Visibility




____________________________________________________________
Section: 104. URL: http://localhost:8080/documentation/page_title

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.page_title Page title


ui. page_title


Page title


Set the page title for the current client.

title: page title


Coding example:
from nicegui import ui

ui.button('Change page title', on_click=lambda: ui.page_title('New Title'))

ui.run()




____________________________________________________________
Section: 105. URL: http://localhost:8080/documentation/navigate

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.navigate Navigation functions ui.navigate.to (formerly ui.open)


ui. navigate


Navigation functions


These functions allow you to navigate within the browser history and to external URLs.


Coding example:
from nicegui import ui

with ui.row():
    ui.button('Back', on_click=ui.navigate.back)
    ui.button('Forward', on_click=ui.navigate.forward)
    ui.button(icon='savings',
              on_click=lambda: ui.navigate.to('https://github.com/sponsors/zauberzeug'))

ui.run()


ui.navigate.to (formerly ui.open)


Can be used to programmatically open a different page or URL.
When using the new_tab parameter, the browser might block the new tab.
This is a browser setting and cannot be changed by the application.
You might want to use ui.link and its new_tab parameter instead.
This functionality was previously available as ui.open which is now deprecated.
Note: When using an auto-index page (e.g. no @page decorator),
all clients (i.e. browsers) connected to the page will open the target URL unless a socket is specified.
User events like button clicks provide such a socket.

target: page function, NiceGUI element on the same page or string that is a an absolute URL or relative path from base URL
new_tab: whether to open the target in a new tab (might be blocked by the browser)


Coding example:
from nicegui import ui

url = 'https://github.com/zauberzeug/nicegui/'
ui.button('Open GitHub', on_click=lambda: ui.navigate.to(url, new_tab=True))

ui.run()




____________________________________________________________
Section: 106. URL: http://localhost:8080/documentation/download

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.download Download Download raw bytes from memory


ui. download


Download


Function to trigger the download of a file, URL or bytes.

src: target URL, local path of a file or raw data which should be downloaded
filename: name of the file to download (default: name of the file on the server)
media_type: media type of the file to download (default: "")


Coding example:
from nicegui import ui

ui.button('Logo', on_click=lambda: ui.download('https://nicegui.io/logo.png'))

ui.run()


Download raw bytes from memory

The download function can also be used to download raw bytes from memory.


Coding example:
from nicegui import ui

ui.button('Download', on_click=lambda: ui.download(b'Hello World', 'hello.txt'))

ui.run()




____________________________________________________________
Section: 107. URL: http://localhost:8080/documentation/run

menu
Installation Features Demos Documentation Examples Why? search


← back

ui.run ui.run Emoji favicon Base64 favicon SVG favicon Custom welcome message


ui. run


ui.run


You can call ui.run() with optional arguments.
Most of them only apply after stopping and fully restarting the app and do not apply with auto-reloading.

host: start server with this host (defaults to '127.0.0.1 in native mode, otherwise '0.0.0.0')
port: use this port (default: 8080 in normal mode, and an automatically determined open port in native mode)
title: page title (default: 'NiceGUI', can be overwritten per page)
viewport: page meta viewport content (default: 'width=device-width, initial-scale=1', can be overwritten per page)
favicon: relative filepath, absolute URL to a favicon (default: None, NiceGUI icon will be used) or emoji (e.g. '🚀', works for most browsers)
dark: whether to use Quasar's dark mode (default: False, use None for "auto" mode)
language: language for Quasar elements (default: 'en-US')
binding_refresh_interval:
 time between binding updates (default: 0.1 seconds, bigger is more CPU friendly)
reconnect_timeout:
 maximum time the server waits for the browser to reconnect (default: 3.0 seconds)
show: automatically open the UI in a browser tab (default: True)
on_air: tech preview: allows temporary remote access if set to True (default: disabled)
native: open the UI in a native window of size 800x600 (default: False, deactivates show, automatically finds an open port)
window_size: open the UI in a native window with the provided size (e.g. (1024, 786), default: None, also activates native)
fullscreen: open the UI in a fullscreen window (default: False, also activates native)
frameless: open the UI in a frameless window (default: False, also activates native)
reload: automatically reload the UI on file changes (default: True)
uvicorn_logging_level:
 logging level for uvicorn server (default: 'warning')
uvicorn_reload_dirs:
 string with comma-separated list for directories to be monitored (default is current working directory only)
uvicorn_reload_includes:
 string with comma-separated list of glob-patterns which trigger reload on modification (default: '*.py')
uvicorn_reload_excludes:
 string with comma-separated list of glob-patterns which should be ignored for reload (default: '.*, .py[cod], .sw.*, ~*')
tailwind: whether to use Tailwind (experimental, default: True)
prod_js: whether to use the production version of Vue and Quasar dependencies (default: True)
endpoint_documentation:
 control what endpoints appear in the autogenerated OpenAPI docs (default: 'none', options: 'none', 'internal', 'page', 'all')
storage_secret: secret key for browser-based storage (default: None, a value is required to enable ui.storage.individual and ui.storage.browser)
show_welcome_message:
 whether to show the welcome message (default: True)
kwargs: additional keyword arguments are passed to uvicorn.run


Coding example:
from nicegui import ui

ui.label('page with custom title')

ui.run(title='My App')


My App


Emoji favicon

You can use an emoji as favicon.
This works in Chrome, Firefox and Safari.


Coding example:
from nicegui import ui

ui.label('NiceGUI rocks!')

ui.run(favicon='🚀')


🚀  NiceGUI


Base64 favicon

You can also use an base64-encoded image as favicon.


Coding example:
from nicegui import ui

ui.label('NiceGUI with a red dot!')

icon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=='

ui.run(favicon=icon)


SVG favicon

And directly use an SVG as favicon.
Works in Chrome, Firefox and Safari.


Coding example:
from nicegui import ui

ui.label('NiceGUI makes you smile!')

smiley = '''
    <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
        <circle cx="100" cy="100" r="78" fill="#ffde34" stroke="black" stroke-width="3" />
        <circle cx="80" cy="85" r="8" />
        <circle cx="120" cy="85" r="8" />
        <path d="m60,120 C75,150 125,150 140,120" style="fill:none; stroke:black; stroke-width:8; stroke-linecap:round" />
    </svg>
'''

ui.run(favicon=smiley)


Custom welcome message

You can mute the default welcome message on the command line setting the show_welcome_message to False .
Instead you can print your own welcome message with a custom startup handler.


Coding example:
from nicegui import app, ui

ui.label('App with custom welcome message')

app.on_startup(lambda: print('Visit your app on one of these URLs:', app.urls))

ui.run(show_welcome_message=False)




____________________________________________________________
Section: 108. URL: http://localhost:8080/documentation/project_structure

menu
Installation Features Demos Documentation Examples Why? search


← back

Project Structure Project Structure Simple Modular


Project Structure


Project Structure

The NiceGUI package provides a pytest plugin which can be activated via pytest_plugins = ['nicegui.testing.plugin'] .
This makes specialized fixtures available for testing your NiceGUI user interface.
With the screen fixture you can run the tests through a headless browser (slow)
and with the user fixture fully simulated in Python (fast).
There are a multitude of ways to structure your project and tests.
Here we only present two approaches which we found useful,
one for small apps and experiments and a modular one for larger projects .
You can find more information in the pytest documentation .


Simple

For small apps and experiments you can put the tests in a separate file,
as we do in the examples chat-app and authentication .
To properly re-initialize your main.py in the tests,
you place an empty __init__.py file next to your code to make it a package
and use the module_under_test marker to automatically reload your main file for each test.
Also don't forget the pytest.ini file
to enable the asyncio_mode = auto option for the user fixture
and make sure you properly guard the ui.run() call in your main.py to prevent the server from starting during the tests:


Coding example:
from nicegui import ui

def hello() -> None:
    ui.notify('Hello World!')

ui.button('Click me', on_click=hello)

if __name__ in {'__main__', '__mp_main__'}:
    ui.run()


test_app.py


Coding example:
import pytest
from nicegui import ui
from nicegui.testing import User
from . import main

pytest_plugins = ['nicegui.testing.plugin']

@pytest.mark.module_under_test(main)
async def test_click(user: User) -> None:
    await user.open('/')
    await user.should_see('Click me')
    user.find(ui.button).click()
    await user.should_see('Hello World!')


bash


Coding example:
$ ls
__init__.py         main.py        test_app.py       pytest.ini

$ pytest
==================== test session starts =====================
test_app.py .                                     [100%]
===================== 1 passed in 0.51 s ======================


Modular

A more modular approach is to create a package for your code with an empty __init__.py and a separate tests folder for your tests.
In your package a startup.py file can be used to register pages and do all necessary app initialization.
The main.py at root level then only imports the startup routine and calls ui.run() .
An empty conftest.py file in the root directory makes the package with its startup routine available to the tests.
Also don't forget the pytest.ini file
to enable the asyncio_mode = auto option for the user fixture.


Coding example:
from nicegui import ui, app
from app.startup import startup

app.on_startup(startup)

ui.run()


app/startup.py


Coding example:
from nicegui import ui

def hello() -> None:
    ui.notify('Hello World!')

def startup() -> None:
    @ui.page('/')
    def index():
        ui.button('Click me', on_click=hello)


tests/test_app.py


Coding example:
from nicegui import ui
from nicegui.testing import User
from app.startup import startup

pytest_plugins = ['nicegui.testing.plugin']

async def test_click(user: User) -> None:
    startup()
    await user.open('/')
    await user.should_see('Click me')
    user.find(ui.button).click()
    await user.should_see('Hello World!')


bash


Coding example:
$ tree
.
├── main.py
├── pytest.ini
├── app
│   ├── __init__.py
│   └── startup.py
└── tests
    ├── conftest.py
    └── test_app.py


You can also define your own fixtures in the conftest.py which call the startup routine.
Pytest has some magic to automatically find and use this specialized fixture in your tests.
This way you can keep your tests clean and simple.
See the pytests example for a full demonstration of this setup.


tests/test_app.py


Coding example:
from nicegui import ui
from nicegui.testing import User

async def test_click(user: User) -> None:
    await user.open('/')
    await user.should_see('Click me')
    user.find(ui.button).click()
    await user.should_see('Hello World!')


conftest.py


Coding example:
import pytest
from nicegui.testing import User
from app.startup import startup

pytest_plugins = ['nicegui.testing.plugin']

@pytest.fixture
def user(user: User) -> User:
    startup()
    return user




____________________________________________________________
Section: 109. URL: http://localhost:8080/documentation/screen

menu
Installation Features Demos Documentation Examples Why? search


← back

Screen Fixture Screen Fixture Web driver Reference Properties Methods


Screen Fixture


Screen Fixture

The screen fixture starts a real (headless) browser to interact with your application.
This is only necessary if you have browser-specific behavior to test.
So only use it if you have to.


example


Coding example:
from selenium.webdriver.common.keys import Keys

screen.open('/')
screen.type(Keys.TAB) # to focus on the first input
screen.type('user1')
screen.type(Keys.TAB) # to focus the second input
screen.type('pass1')
screen.click('Log in')
screen.should_contain('Hello user1!')
screen.click('logout')
screen.should_contain('Log in')


Web driver

The screen fixture uses Selenium under the hood.
Currently it is only tested with the Chrome driver.
To automatically use it for the tests we suggest to add the option --driver Chrome to your pytest.ini :


pytest.ini


Coding example:
[pytest]
asyncio_mode = auto
addopts = "--driver Chrome"


Reference


Properties


is_open : bool


Check if the browser is open.


Methods


assert_py_logger (level: str, message: Union[str, re.Pattern]) -> None


Assert that the Python logger has received a message with the given level and text or regex pattern.

click (target_text: str) -> selenium.webdriver.remote.webelement.WebElement


Click on the element containing the given text.

click_at_position (element: selenium.webdriver.remote.webelement.WebElement, x: int, y: int) -> None


Click on the given element at the given position.

close () -> None


Close the browser.

context_click (target_text: str) -> selenium.webdriver.remote.webelement.WebElement


Right-click on the element containing the given text.

find (text: str) -> selenium.webdriver.remote.webelement.WebElement


Find the element containing the given text.

find_all (text: str) -> List[selenium.webdriver.remote.webelement.WebElement]


Find all elements containing the given text.

find_all_by_class (name: str) -> List[selenium.webdriver.remote.webelement.WebElement]


Find all elements with the given CSS class.

find_all_by_tag (name: str) -> List[selenium.webdriver.remote.webelement.WebElement]


Find all elements with the given HTML tag.

find_by_class (name: str) -> selenium.webdriver.remote.webelement.WebElement


Find the element with the given CSS class.

find_by_css (selector: str) -> selenium.webdriver.remote.webelement.WebElement


Find the element with the given CSS selector.

find_by_tag (name: str) -> selenium.webdriver.remote.webelement.WebElement


Find the element with the given HTML tag.

find_element (element: nicegui.element.Element) -> selenium.webdriver.remote.webelement.WebElement


Find the given NiceGUI element.

implicitly_wait (t: float) -> Generator[NoneType, NoneType, NoneType]


Temporarily change the implicit wait time.

open (path: str, timeout: float = 3.0) -> None


Try to open the page until the server is ready or we time out.
If the server is not yet running, start it.

render_js_logs () -> str


Render the browser console logs as a string.

shot (name: str) -> None


Take a screenshot and store it in the screenshots directory.

should_contain (text: str) -> None


Assert that the page contains the given text.

should_contain_input (text: str) -> None


Assert that the page contains an input with the given value.

should_load_image (image: selenium.webdriver.remote.webelement.WebElement, timeout: float = 2.0) -> None


Assert that the given image has loaded.

should_not_contain (text: str, wait: float = 0.5) -> None


Assert that the page does not contain the given text.

start_server () -> None


Start the webserver in a separate thread. This is the equivalent of ui.run() in a normal script.

stop_server () -> None


Stop the webserver.

switch_to (tab_id: int) -> None


Switch to the tab with the given index, or create it if it does not exist.

type (text: str) -> None


Type the given text into the currently focused element.

wait (t: float) -> None


Wait for the given number of seconds.

wait_for (target: Union[str, Callable[..., bool]]) -> None


Wait until the page contains the given text or the given condition is met.




____________________________________________________________
Section: 110. URL: http://localhost:8080/documentation/user

menu
Installation Features Demos Documentation Examples Why? search


← back

User Fixture User Fixture Async execution Querying Comparison with the screen fixture User Reference Properties Methods UserInteraction Reference Methods


User Fixture


User Fixture

We recommend utilizing the user fixture instead of the screen fixture wherever possible
because execution is as fast as unit tests and it does not need Selenium as a dependency.
The user fixture cuts away the browser and replaces it by a lightweight simulation entirely in Python.
You can assert to "see" specific elements or content, click buttons, type into inputs and trigger events.
We aimed for a nice API to write acceptance tests which read like a story and are easy to understand.
Due to the fast execution, the classical test pyramid ,
where UI tests are considered slow and expensive, does not apply anymore.


example


Coding example:
await user.open('/')
user.find('Username').type('user1')
user.find('Password').type('pass1').trigger('keydown.enter')
await user.should_see('Hello user1!')
user.find('logout').click()
await user.should_see('Log in')


NOTE: The user fixture is quite new and still misses some features.
Please let us know in separate feature requests over on GitHub .


Async execution

The user simulation runs in the same async context as your app
to make querying and interaction as easy as possible.
But that also means that your tests must be async .
We suggest to activate the pytest-asyncio auto-mode by either creating a pytest.ini file in your project root
or adding the activation directly to your pyproject.toml .


pytest.ini


Coding example:
[pytest]
asyncio_mode = auto

or


pyproject.toml


Coding example:
[tool.pytest.ini_options]
asyncio_mode = "auto"


Querying

The querying capabilities of the User are built upon the ElementFilter .
The user.should_see(...) method and user.find(...) method
provide parameters to filter for content, markers , types, etc.
If you do not provide a named property, the string will match against the text content and markers.


some UI code


Coding example:
with ui.row():
    ui.label('Hello World!').mark('greeting')
    ui.icon('star')
with ui.row():
    ui.label('Hello Universe!')
    ui.input(placeholder='Type here')


user assertions


Coding example:
await user.should_see('greeting')
await user.should_see('star')
await user.should_see('Hello Universe!')
await user.should_see('Type here')
await user.should_see('Hello')
await user.should_see(marker='greeting')
await user.should_see(kind=ui.icon)


Comparison with the screen fixture

By cutting out the browser, test execution becomes much faster than the screen fixture .
Of course, some features like screenshots or browser-specific behavior are not available.
See our pytests example which implements the same tests with both fixtures.


User Reference


Properties


current_layout : 'Element'


Return the root layout element of the current page.


Methods


find (target: Union[str, Type[T], None] = None, kind: Optional[Type[T]] = None, marker: Union[str, list[str], None] = None, content: Union[str, list[str], None] = None) -> UserInteraction[T]


Select elements for interaction.

open (path: str, clear_forward_history: bool = True) -> None


Open the given path.

should_not_see (target: Union[str, Type[T], None] = None, kind: Optional[Type[T]] = None, marker: Union[str, list[str], None] = None, content: Union[str, list[str], None] = None, retries: int = 3) -> None


Assert that the page does not contain an input with the given value.

should_see (target: Union[str, Type[T], None] = None, kind: Optional[Type[T]] = None, marker: Union[str, list[str], None] = None, content: Union[str, list[str], None] = None, retries: int = 3) -> None


Assert that the page contains an element fulfilling certain filter rules.
Note that there is no scrolling in the user simulation -- the entire page is always visible .
Due to asynchronous execution, sometimes the expected elements only appear after a short delay.
By default should_see makes three attempts to find the element before failing.
This can be adjusted with the retries parameter.


UserInteraction Reference


Methods


click () -> Self


Click the selected elements.

trigger (event: str) -> Self


Trigger the given event on the elements selected by the simulated user.
Examples: "keydown.enter", "click", ...

type (text: str) -> Self


Type the given text into the selected elements.



